* 第 1 章：你的第一个随机迷宫 *Your First Random Mazes*

从外部看, 迷宫制作似乎很神奇, 但别被骗了. 这里没有魔法. 从这一页开始, 我们将揭开驱动迷宫生成的神秘面纱. 我们将看到其表面之下的脚手架.

我们将具体讨论迷宫到底是什么, 然后我们将通过两种简单的方法创建迷宫, 用纸和铅笔一起逐步演示.

最终, 我们的迷宫会让我们陶醉, 但我们要从零开始, 一切都始于算法.

我们将专注于那些随机生成迷宫的算法. 通道的长度, 死胡同的数量, 十字路口的频率, 以及通道分支的频率, 都将通过从预设的可能性列表中随机选择来确定.

没有一个普遍理想的迷宫生成算法, 因此在本书中, 我们将探索十二种不同的算法. 你将学习如何根据项目的需求来选择它们, 比如速度, 内存效率, 或简单性(甚至是你的个人美学感!).

最重要的是, 大多数算法都有其特质, 导致它们生成的迷宫共享某些特征, 比如短而粗的通道, 或者通道都偏向某个方向. 我们也将深入探索.

在此过程中, 要把握节奏. 在本书结束时, 你将成为专家, 能够灵活地在这些不同的算法之间切换, 选择最合适的一个.

不过, 首先, 让我们在纸上进行.

#+BEGIN_QUOTE
Joe 提问: 什么是算法?

算法 (algorithm) 只是对一个过程的描述. 就像食谱书里的菜谱一样, 它告诉你为了完成某个任务需要采取哪些步骤. 任何任务都行. 算法无处不在.
如果你的目标是做千层面, 那么你做千层面的步骤就是你的算法. 想要铺床, 或者开车去上班? 两者都可以被描述为一系列步骤. 更多的算法! 算法发射火箭, 降落飞机, 驾驶汽车, 排序信息, 以及搜索网络.

算法解决迷宫. 如果你像我们一样要去制作一个迷宫, 你的算法就包含了你制作那个迷宫所采取的步骤.
#+END_QUOTE

** 准备网格 Preparing the Grid

我们将从绘制一个网格 (grid) 开始——就是常规的垂直线交叉图案. 这个脚手架将构成迷宫的骨架, 即赋予我们最终产品结构和稳定性的骨骼和肌腱.

拿出一张纸. 不必很精美——紧急情况下餐巾纸也行. 你还需要一支笔, 最好是可以擦除的.

在这张纸上, 画一个网格. 对于第一次实验, 四乘四的大小应该足够了, 不用担心线条画得不整齐. 像下图这样的就没问题.

#+CAPTION: 一个手绘的 4x4 网格.

这是我们的起点. 我们将把单个的方块称为单元格 (cells), 把它们周围的网格线称为墙 (walls). 从这个网格开始, 我们的任务是擦除恰当的墙——也就是开辟出恰当的通道 (passages)——以生成一个迷宫.

这恰好就是本书中的算法将为我们做的事情. 它们中的大多数会创建所谓的完美迷官 (perfect mazes), 其中每个单元格都可以通过且仅通过一条路径到达其他任何单元格.

这些迷宫没有回路 (loops), 或者说路径不会自我相交. 这很重要! 下图是这些完美迷宫中的一个例子.

#+CAPTION: 一个完美迷宫的例子.

不过, 不要把这个名字误认为是价值判断. "完美" 这个词仅仅指的是它的逻辑和数学上的纯粹性. 一个迷宫可能在数学上是完美的, 但同时又是有缺陷的 (例如, 在美学上).

完美迷宫的反面被称为辫状迷宫 (braid maze). 它们的特点是很少 (甚至没有) 死胡同, 并且通道形成回路. 这是辫状迷宫的一个例子.

#+CAPTION: 一个辫状迷宫的例子.

在这类迷宫中, 从一个点到另一个点可以通过多种不同的路径或解决方案来完成. 我们将在第 9 章, *编织和交织你的迷宫* (Braiding and Weaving Your Mazes), 第 129 页看到更多关于它们的内容, 但现在我们将专注于它们的对应物, 完美迷宫.

让我们来创造一些吧!

#+BEGIN_QUOTE
 * 迷宫 vs. 迷宫
Labyrinths versus Mazes

有些人更喜欢 "labyrinth". 有些人喜欢 "maze". 有些人甚至用 labyrinth 这个词来指代一种特定类型的迷宫, 即一条从不分支但在从起点到终点的过程中曲折蜿蜒的单一通道.

但最终, 它们叫什么并不重要. Labyrinth 或 maze, 它们 (大多) 意味着同样的事情. 在本书中, 我会优先使用 "maze" 这个词. 尽管那些非分支版本 (技术上称为单路径迷宫, unicursal mazes) 玩起来很有趣, 但遗憾的是它们超出了本书的范围. 我们将专注于多路径迷宫 (multicursal mazes)——那些有分支通道的迷宫——它们本身就足够丰富多彩了!
#+END_QUOTE

** 二叉树算法
The Binary Tree Algorithm

二叉树算法 (Binary Tree algorithm) 可能是生成迷宫的最简单的算法. 顾名思义, 它只需要你在每一步从两个可能的选项中做出选择. 对于网格中的每个单元格, 你决定是向北还是向东开辟一条通道. 当你为每个单元格都这样做之后, 你就有了一个迷宫!

查看单元格的这个过程称为访问 (visiting) 它们. 按某种顺序访问它们称为遍历网格 (walking the grid). 有些遍历可能是随机的, 每一步都任意选择方向, 就像我们将在第 4 章, *通过随机行走避免偏倚* (Avoiding Bias with Random Walks), 第 53 页看到的那样. 其他的则更具可预测性. 对于二叉树算法, 事实证明我们可以用任何一种方式. 该算法实际上不关心我们访问单元格的顺序.

让我们一起来走一遍, 看看二叉树算法在实践中是如何形成的. 在每一步, 我都会抛硬币来决定我们应该朝哪个方向开辟通道. 另外, 尽管二叉树算法本身不关心我们从网格的哪个位置开始遍历, 但为了这个例子, 我们就从西南角的单元格开始.

#+CAPTION: 一个 4x4 网格, 西南角的单元格被标记, 还有一个指示北/南/东/西的罗盘.

我们的选择是: 我们是擦除那个单元格的北墙, 还是它的东墙? 让我们看看硬币怎么说. 如果是正面, 我们就向北开辟. 如果是反面, 我们就向东开辟.

结果是...正面. 看来我们要擦除北墙了.

#+CAPTION: 网格, 西南角单元格的北墙已被擦除.

请注意, 尽管这两个单元格现在通过一条连接通道相连, 但我们还没有技术上访问第二个单元格. 我们可以选择接下来访问那个单元格 (因为二叉树算法真的不关心我们访问单元格的顺序), 但按顺序访问一行中的单元格更容易实现. 让我们等到这一行结束后再处理那个北边的单元格. 现在, 让我们跳到我们紧邻东边的那个单元格.

在这里抛硬币, 我们得到反面. 这意味着我们将擦除当前单元格的东墙.

#+CAPTION: 网格, 第一个单元格向东连接到第二个单元格.

再次为下一个单元格抛硬币, 我们又得到反面.

#+CAPTION: 网格, 前三个单元格现在都向东连接.

再次向东移动, 我们当前的单元格变成了东南角的那个. 我们当然也可以在这里抛硬币, 但考虑一下如果硬币是反面会发生什么. 我们将不得不在迷宫的外墙上开辟一条通道. 这通常不是一个好主意. 我们稍后会更多地讨论为你的迷宫添加入口和出口, 但现在我们想避免挖隧道出界. 由于这实际上禁止了向东走, 向北就成了我们唯一可行的选择. 不需要抛硬币了——让我们直接处理一下, 向北开辟通道.

#+CAPTION: 网格, 东南角的单元格被迫向北连接.

事实上, 这个约束存在于整个东部边界的每个单元格上. 它们都不能有朝东的通道. 我们不妨现在就把它们都处理掉, 方法是在每一个单元格上都向北开辟通道. 我们也将把它们都视为已访问过的.

#+CAPTION: 网格, 东部边界的所有单元格都已向北连接.

现在, 为了演示起见, 让我们一路跳到西北角, 看看接下来会发生什么. (是的, 这有点不合常规...但请记住, 二叉树算法只需要我们访问所有单元格——它不关心我们使用什么顺序.)

#+CAPTION: 网格, 西北角的单元格被标记.

再一次, 我们可以抛硬币, 但考虑一下如果硬币正面朝上会发生什么: 我们将不得不穿透那堵北墙. 我们不希望那样. 所以, 我们将放弃抛硬币, 直接向东开辟通道.

#+CAPTION: 网格, 西北角的单元格向东连接.

再次注意, 这个约束适用于整个北部边界的每个单元格. 你不能从它们中的任何一个向北开辟通道, 所以它们都默认改为向东走.

#+CAPTION: 网格, 北部边界的所有单元格都已向东连接.

还有一个特殊情况需要考虑. 让我们跳到东北角.
我们在这里既不能向北, 也不能向东开辟通道. 我们的手被束缚住了. 没有选择, 我们就什么都不选. 在我们网格的所有单元格中, 这是唯一一个我们无能为力的. 我们耸耸肩, 跳过它.

#+CAPTION: 网格, 东北角保持不变.

现在, 请拿起你自己的硬币, 完成那些尚未访问过的其余单元格. 一旦为每个单元格做出了决定, 你应该会得到一个看起来像图中那样的迷宫.

#+CAPTION: 一个完成的 4x4 二叉树迷宫.

真的就这么简单! 你刚刚学会了用于随机迷宫生成的二叉树算法. 轻松无痛!

** 入口和出口
Entrances and Exits

然而, 此时你可能会想, 如果没有进出这个盒子的方式, 它怎么能算是一个迷宫呢. 迷宫不都应该有起点和终点吗? 这是一个合理的问题! 老实说, 事情的真相是, 这完全取决于你.

之前我们稍微谈到了完美迷宫的概念. 这一切又回到了那个点上. 你刚才画的迷宫是一个完美迷宫, 而完美迷宫的一个属性是, 其中任意两个单元格之间都存在且仅存在一条路径. 任意两个! 你选定它们, 就保证它们之间有一条路径.

这意味着你可以在你的迷宫中选择任意两个单元格, 将其中一个设为起点, 另一个设为终点, 并且你可以确信你的迷宫有一个真正的解法. 就这么简单. 想要从一边进入, 另一边出去? 在你的迷宫边界上选择两个单元格, 擦除那些单元格的外墙, 就行了.

这取决于你想让你的迷宫做什么. 例如, 《吃豆人》(Pac-Man) 中的迷宫根本没有出口, 因为目标只是在被鬼魂抓住之前吃掉所有的豆子. 其他游戏, 比如《塞尔达传说》(Zelda), 允许你进入一个迷宫, 但目标是到达它内部的一个点, 这样你就可以击败某个 Boss 生物并获得宝藏.

所以, 当本书中的例子省略了“起点”和“终点”时, 不要感到惊讶. 那些将由你和你的想象力来决定!

#+BEGIN_QUOTE
Joe 提问:
为什么叫“二叉树”?
Why “Binary Tree”?

也许你听说过二叉树 (binary trees), 这是一种数据结构, 其中的值按层级排列, 每个值都有零个, 一个或两个自己的子值. 这个算法与该数据结构同名并非偶然, 因为它生成的迷宫就是二叉树.

这是真的. 还记得东北角的那个单元格吗, 就是我们无能为力的那个? 那就是树的根节点 (root). 它没有父节点, 但它至少有一个子节点, 也可能有 W个, 或者在西边, 或者在南边. 顺着这个方向, 从一个单元格到另一个单元格, 你会看到每个后续的单元格要么是一个死胡同 (即一个叶节点, a leaf node), 要么是最多另外两个子节点的父节点.

很巧妙吧!
#+END_QUOTE

** 理解纹理
Understanding Texture

看看你的迷宫, 你可能会注意到一些小小的奇特之处. 例如, 最北边的一行和最东边的一列都是未断开的走廊. 如果你仔细想想, 这完全是意料之中的. 还记得在那些边界单元格上发生了什么吗, 擦除一堵墙会让我们超出迷宫的边界? 我们总是选择有效的方向, 即北或东, 迫使那些边界合并成一条单一的通道.

这造成了我们所说的迷宫的纹理 (texture). 纹理是一个通用术语, 指的是迷宫通道的风格, 比如它们通常有多长, 以及它们倾向于走向哪个方向. 你对一个迷宫的第一印象通常会受到其纹理的强烈影响.

一些算法会倾向于产生具有相似纹理的迷宫. 例如, 二叉树 (Binary Tree) 算法总是会产生在北部和东部有那两条未断开走廊的迷宫. 不相信我? 试试看. 下图展示了几个使用二叉树算法随机生成的迷宫, 注意它们是如何都在北部和东部有同样的长走廊的.

#+CAPTION: 使用二叉树算法随机生成的六个迷宫示例.

我们可以说二叉树算法对具有那种特定纹理的迷宫有偏倚 (biased). 我们将在第 4 章, *通过随机行走避免偏倚* (Avoiding Bias with Random Walks), 第 53 页, 更深入地探讨偏倚及其对算法的意义, 但就目前而言, 当我们谈论偏倚时, 我们指的是算法产生特定纹理迷宫的倾向.

它还有另一个偏倚. 将你自己放在迷宫的西南角, 试着找到去东北角的路. 你会发现你的路径看起来像下图中的一条.

#+CAPTION: 一个图示, 展示了从二叉树迷宫的西南角到东北角的典型路径.

一点都不难, 对吧? 即使迷宫很小, 路径本身也很 trivial. 每个单元格都有一个向北或向东的出口, 所以你总是可以毫无阻碍地向东北移动. 没有死胡同, 没有回头路. 简单. 这种对角线纹理就是偏倚的证据.

现在, 我们不能因此太过苛责二叉树算法. 大多数随机迷宫算法都会有这样或那样的偏倚, 尽管很多都比这个更微妙. 这个如此 blatant 的事实只是我们为一个像二叉树算法这样快速, 高效且简单的算法所付出的代价.

** 从二叉柠檬中榨出柠檬水
Making Lemonade from Binary Lemons

是的, 这是真的. 即使有这些 glaring 的纹理, 也有好的一面. 二叉树算法快速, 高效且简单.

想想看. 你只需要访问每个单元格一次就能知道迷宫会变成什么样. 用计算机科学的术语来说, 这意味着它是 O(n), 当你必须访问一个集合中的每个项目时, 这几乎是最快的速度了.

它也很高效. 它只需要足够的内存来表示任何给定时间的一个单元格. 我们稍后会看到, 其他算法比这个要耗费内存得多, 其中一些需要与整个网格大小成比例的内存. 如果你想处理非常大的迷宫, 那将非常受限, 但对于二叉树算法来说, 这根本不是问题.

最后, 它很简单. 你只用纸, 铅笔和一枚硬币就能完成它. 这可不是我们后面要看的所有算法都能做到的. 有些用手算起来简直是痛苦不堪!

即使是算法的偏倚也并非一无是处. 那个对角线纹理? 当然, 从西南走到东北可能很简单, 但反过来呢? 如果你要从东北走到西南呢?

如果没有迷宫的全知视角, 你现在就不清楚哪个方向能带你到终点. 有时候, 一个看似毫无希望的简单迷宫, 只需要换个方向来看. 确实是因祸得福!

尽管如此, 偏倚 (bias) 就是偏倚, 消除一个算法的偏倚很少是简单, 甚至是可能的. 如果你不能利用一个给定算法产生的纹理, 通常最简单的方法就是看看别处.

所以让我们看看别处.

** Sidewinder 算法
The Sidewinder Algorithm

这是一个名为 Sidewinder 的算法, 尽管与二叉树 (Binary Tree) 算法密切相关, 它仍然设法将偏倚调低了一些. 回想一下, 二叉树算法在每个单元格处选择向北或向东; 另一方面, Sidewinder 则在从其中一个单元格向北开辟通道之前, 尝试将相邻的单元格组合在一起. 去拿另一张纸, 在上面画另一个网格, 我们马上开始.

现在, 与二叉树算法不同, Sidewinder 不会轻易让我们从任何我们喜欢的地方开始开辟. 它强烈偏好从西边的列开始, 所以我们就从那里开始. 事实上, 我们不妨就从我们之前开始的地方, 西南角开始. 我会像之前一样为我们俩抛硬币. 再一次, 反面将意味着“向东开辟”, 但我们会看到这次正面意味着一些稍微不同的东西.

开始了!

从西南角开始, 我们的第一次抛硬币得到反面, 告诉我们要擦除该单元格的东墙. 然后我们向那个方向移动到下一个单元格, 如图所示.

#+CAPTION: 一个 4x4 网格, 显示了 Sidewinder 算法的第一步: 从西南角向东开辟.

没问题. 到达这个新单元格后, 我们像之前一样抛硬币. 结果又是反面. 继续擦除那堵东墙, 并移动到下一个邻居, 像这样.

#+CAPTION: 网格, 游程继续向东延伸.

再一次, 我们抛硬币, 然后... 呀!
是正面.

当硬币正面朝上时, 我们回头看我们刚刚走过的路径, 也就是那组最近通过打通墙壁连接起来的单元格. 在这里, 是我们刚刚访问过的那连续三个单元格. 我们将这个集群称为一个游程 (run). 我们将从这个游程中随机选择一个单元格, 然后擦除它的北墙, 将它与其北边的邻居连接起来. 之后, 我们就处理完这三个单元格了, 不会再对它们做任何更改. 我们称之为结束这个游程 (closing out the run). 上图显示了这一点.

#+CAPTION: 一个包含三个单元格的游程被结束, 其中一个单元格向北开辟了通道.

请注意, 这里的游程只涉及那三个单元格, 而不包括我们连接到的北边的那个单元格! 这很重要. 那个北边的单元格尚未被访问过, 当算法移动到第二行时, 它将成为公平的游戏.

现在, 我们非常刻意地不移除东墙 (因为那会改变那些已结束的单元格), 而是直接移动到下一个单元格. 当我们都准备好了, 过程将从我们的新位置开始, 带着一个新的单元格游程重新开始.

#+CAPTION: 算法移动到该行的下一个未访问单元格.

不过, 在我们的例子中, 我们已经到达了网格的东部边界, 无论我们的硬币多么坚持我们应该继续向东走, 我们就是不能. 我们世界的边缘是相当不可改变的. 当你发现自己处于那种情况时, 就回退到我们用于二叉树的相同策略：不要费心去抛硬币。把东部边界当作瞬间的正面，然后结束这个运行。(这里很简单：我们的运行中只有一个单元格，所以我们选择它并擦除北墙。)

#+CAPTION: 到达东部边界, 算法被迫向北开辟通道.

在结束那一行之后，移动到下一行并再次运行整个过程。抛，抛，抛，一个接一个，要么添加到运行中，要么结束它，视情况而定。记住，到目前为止，下一行中的单元格还没有被访问过。有些已经被链接了，但没有被访问过，而 Sidewinder 必须准确地访问网格中的每个单元格一次。也就是说，Sidewinder 会查看每个单元格，即使它已经被链接到另一行的单元格。

请稍等一下，让我们跳到西北角。(又是不合常规，是的，但我们可以这样做，因为 Sidewinder 只需要我们从每一行的开头开始——我们实际上可以按任何顺序处理这些行。)为了演示起见，考虑一下如果这里的硬币正面朝上，我们不得不结束这个运行，会发生什么。

是的。就像我们在二叉树中看到的那样，我们在最北边的一行遇到了一个边缘情况。我们需要避免擦除那个北边界。解决方案是熟悉的：就像我们在东部边界做的那样，我们不允许那个让我们出界的方向。我们禁止正面，并强制那一行期间的所有抛硬币都为反面。这将产生一个贯穿顶部的未断开的走廊，就像在二叉树算法中一样。

现在请拿起你自己的硬币，完成其余部分，看看这个算法感觉如何。当你访问了网格中的所有单元格并结束了每一行后，你应该会得到像图中那样的东西。

#+CAPTION: 一个完成的 4x4 Sidewinder 迷宫。

比二叉树要复杂一点，但也不算太糟。不过...是的。我确定你也闻到了。

一个偏倚。

你几乎不可能错过顶部那条未断开的通道。每个由 Sidewinder 生成的迷宫都会有那条未断开的走廊。不如二叉树的两条未断开的走廊那么糟糕，但仍然远非理想。这是 Sidewinder 偏倚之一的证据。

另一个则更微妙一些. 将你自己置于南部边界的任何一个单元格中, 然后试着找到去往北部那行的路, 如图所示.

#+CAPTION: 一个图示, 展示了从 Sidewinder 迷宫的南部边界到北部边界的路径.

果然: 一个近乎 trivial 的解法. 它可能会左右蜿蜒一下 (算法的名字也由此而来), 但因为每个水平的单元格游程 (run) 都会恰好有一个向北的通道, 所以那个方向的解法并不难找.

不过, 就像二叉树算法一样, 逆着纹理 (从北到南) 移动会更具挑战性.

** 轮到你了
Your Turn

到此为止, 你应该已经对算法是什么有了不错的掌握, 并且对它们在生成随机迷宫中所扮演的角色有了一些概念. 你已经见识了二叉树 (Binary Tree) 和 Sidewinder 算法的实际工作方式. 你已经在纸上练习了几个迷宫, 并且对迷宫纹理以及它们与算法偏倚的关系有了一些了解.

不错!

然而, 正如任何一位好厨师会告诉你的那样, 一份食谱——在这里我们说, 一个算法——仅仅是一个起点. 现在轮到你了. 更深入地探索. 把玩一下你学到的东西. 如果你需要一些建议来启动你自己的创意引擎, 可以看看下面的实验.

*** 二叉树实验
Binary Tree experiments

你可能会期望一个限制你只能在两个选项之间选择的算法会给你很少的 flexibility. 在某种程度上, 这是对的, 但你可能会惊讶于仅仅通过稍微修改一下选项就能做到的事情. 打破那些假设, 看看会发生什么!

**** 重新定向通道
Reorient the Passages

如前所述, 二叉树算法会在北部和东部边界产生未断开的走廊. 你要如何改变算法来让它在南部和西部边界产生未断开的走廊呢? 北部和西部呢? 南部和东部呢? 对角线纹理会发生什么变化?

**** 改变偏倚
Changing the Bias

你要如何改变二叉树算法, 使其偏向于产生更长的水平游程? 也就是说, 你要如何让算法产生通道倾向于水平延伸的迷宫? 垂直方向呢?

*** Sidewinder 实验
Sidewinder Experiments

现在用 Sidewinder 试试. 同样的实验也适用, 但方法会有些许不同. 关键都在于打破假设.

**** 重新定向通道
Reorient the Passages

如前所述, Sidewinder 有很强的从南到北的纹理. 你要如何改变算法来让它偏好从东到西的路径? 未断开的北部走廊会发生什么变化?

**** 改变偏倚
Changing the Bias

你能做什么来让 Sidewinder 偏向于产生更长的水平游程? 垂直游程呢?

你应该对二叉树算法和 Sidewinder 都感到相当自信了. 太棒了! 在下一章中, 我们将看看如何将这些算法转换成代码, 这样计算机就可以为你完成所有的工作了.
* 第 2 章：自动化和展示你的迷宫
*Automating and Displaying Your Mazes*

在纸上涂鸦迷宫固然不错, 但如果我们只有这个, 我们将一事无成. 我们是计算机程序员. 让我们把这件事做对.

让计算机为我们代劳.

由于网格是后面大部分内容的基础, 我们将从那里开始, 探索贯穿全书使用的特定实现. 我们将通过在其上实现二叉树 (Binary Tree) 和 Sidewinder 算法来了解其实际工作方式, 我们还将研究两种不同的展示方式: 文本方式 (可以想象成 "ASCII art") 和图形方式.

** 介绍我们的基础网格
Introducing Our Basic Grid

本章及后续章节中的示例都将构建在一个特定的网格实现之上, 所以我们将在这里花几页篇幅来介绍它. 这将是我们用来构建迷宫的工具, 无论是直接使用这个 `Grid` 类, 还是通过子类化它并添加更具体的功能. 了解它的构建方式应该会让事情更清晰. 我们将从简单开始, 在接下来的几章中, 我们会根据需要对其进行添加和扩展.

我们想要的是能够实例化网格并操作其中包含的单元格. 用伪代码来说, 就像这样:

#+BEGIN_SRC
# instantiate a 10x10 grid
grid = Grid.new(10, 10)

# get the cell at row 1, column 2
cell = grid

# iterate over all the cells in the grid
grid.each_cell do |cell|
  # do something to the cell
end
#+END_SRC

我们很快就能看出, 网格需要是某种容器, 结构上——概念上——如下图所示.

#+CAPTION: 图 1—网格组织
#+NAME: fig:grid-organization

下面的实现忠于该架构, `Grid` 类本质上充当了单个单元格的容器. 它根据需要多次实例化 `Cell` 类来填充网格, 每个单元格都各自跟踪它们旁边的其他单元格, 以及通过通道与哪些单元格相连.

这个实现是用 Ruby 编写的,¹ 但这些概念绝对不是 Ruby 特有的. 这里的一切都可以适应你选择的语言. 后面的示例——同样是用 Ruby 编写的——将重用此代码, 将其引入并要么在其上绘制迷宫 (就像我们上一章用手做的那样), 要么扩展它以添加新功能.

*** 实现 Cell 类
Implementing the Cell Class

由于 `Cell` 类是这一切的核心, 我们将从那里开始. 将以下代码放入一个名为 `cell.rb` 的文件中. 这里没有什么特别棘手的, 但我们至少会逐步讲解并介绍这些方法.

#+BEGIN_SRC ruby
cell.rb
class Cell
  attr_reader :row, :column
  attr_accessor :north, :south, :east, :west
#+END_SRC

¹ http://www.ruby-lang.org

每个单元格都应该知道它在网格中的位置, 所以我们的类记录了这些坐标, 行和列. 它还跟踪单元格的直接邻居, 即北、南、东、西方向的单元格.

接下来是构造函数 `initialize`. 它接受两个参数: 单元格所在的网格中的行和列. 它还初始化一个名为 `@links` 的哈希表, 该哈希表将用于跟踪哪些相邻单元格与此单元格相连 (通过通道连接).

#+BEGIN_SRC ruby
  def initialize(row, column)
    @row, @column = row, column
    @links = {}
  end
#+END_SRC

接下来的两个方法用于操作 `@links` 变量. 第一个, `link(cell)`, 将当前单元格与 `cell` 参数连接起来. 第二个, `unlink(cell)`, 执行相反的操作, 断开两个单元格的连接. 不过, 在这两种情况下, 我们都希望确保操作是双向的 (bidirectionally), 以便在两个单元格上都记录连接. 一个可选的 `bidi` 参数有助于确保这一点.

#+BEGIN_SRC ruby
  def link(cell, bidi=true)
    @links[cell] = true
    cell.link(self, false) if bidi
    self
  end

  def unlink(cell, bidi=true)
    @links.delete(cell)
    cell.unlink(self, false) if bidi
    self
  end
#+END_SRC

之后, 我们还有两个处理单元格连接的方法. 第一个, `links`, 用于查询与此单元格连接的所有单元格的列表, 第二个, `linked?(cell)`, 用于查询当前单元格是否与另一个给定的单元格相连.

#+BEGIN_SRC ruby
  def links
    @links.keys
  end

  def linked?(cell)
    @links.key?(cell)
  end
#+END_SRC

最后一个方法, `neighbors`, 用于查询与此单元格相邻的单元格列表.

#+BEGIN_SRC ruby
  def neighbors
    list = []
    list << north if north
    list << south if south
    list << east if east
    list << west if west
    list
  end
end
#+END_SRC

随着我们的进展, 我们会向这个类添加更多方法, 但我们现在拥有的已经足够我们开始了. 它本身并不是特别有用——我们甚至很少需要直接引用它. 只有当这些单元格被捆绑到一个网格中时, 它们才真正开始大放异彩. 接下来让我们看看如何实现这一点.

*** 实现 Grid 类
Implementing the Grid Class

正如我们在图 1, *网格组织*, 第 18 页看到的那样, 网格类本质上只是一个二维单元格数组的包装器. 让我们将以下代码放入一个名为 `grid.rb` 的文件中, 确保它与我们之前创建的 `cell.rb` 文件在同一个目录中, 这样网格才能找到它需要的 `Cell` 类. 再次, 我们将逐一讲解.

首先, 我们需要我们刚刚编写的 `Cell` 类, 因为网格依赖于它. 另外, 注意网格跟踪了它包含的行数和列数.

#+BEGIN_SRC ruby
grid.rb
require 'cell'

class Grid
  attr_reader :rows, :columns
#+END_SRC

构造函数将我们期望的网格维度作为参数, 并将它们设置为属性. 它还通过调用 `prepare_grid` 和 `configure_cells` 来初始化网格, 我们将在接下来实现这两个方法.

#+BEGIN_SRC ruby
  def initialize(rows, columns)
    @rows = rows
    @columns = columns

    @grid = prepare_grid
    configure_cells
  end
#+END_SRC

我们可以将接下来的这两个方法内联到构造函数中, 但这样做可以让子类在以后我们开始玩不同类型的网格时覆盖这些方法.

#+BEGIN_SRC ruby
  def prepare_grid
    Array.new(rows) do |row|
      Array.new(columns) do |column|
        Cell.new(row, column)
      end
    end
  end

  def configure_cells
    each_cell do |cell|
      row, col = cell.row, cell.column

      cell.north = self[row - 1, col]
      cell.south = self[row + 1, col]
      cell.west  = self[row, col - 1]
      cell.east  = self[row, col + 1]
    end
  end
#+END_SRC

目前, `prepare_grid` 只是设置了一个简单的二维 `Cell` 实例数组, 而 `configure_cells` 则告诉每个单元格它在北、南、东、西方向的直接邻居是谁.

注意, 边界情况, 比如北部边界的单元格没有北邻居, 将由我们的自定义数组访问器 ( `[]` 方法) 巧妙地处理. 该数组访问器主要用于授予对网格中任意单元格的随机访问权限, 但它也会进行边界检查, 因此如果传递给它的坐标超出边界, 它将返回 `nil`. 让我们接下来定义它.

#+BEGIN_SRC ruby
  def [](row, column)
    return nil unless row.between?(0, @rows - 1)
    return nil unless column.between?(0, @grid[row].count - 1)
    @grid[row][column]
  end
#+END_SRC

子类可以 (并且将会) 覆盖这个方法来添加一些非常有趣的效果, 比如圆柱形或环形迷宫.

顺便, 让我们花点时间添加另一种访问单个单元格的方式: 随机. 我们还将创建一个方法来报告网格中的单元格数量.

#+BEGIN_SRC ruby
  def random_cell
    row = rand(@rows)
    column = rand(@grid[row].count)

    self[row, column]
  end

  def size
    @rows * @columns
  end
#+END_SRC

这两个方法现在可能看起来不是特别有用, 但我们很快就会看到一些算法会使用它们.

最后, 我们将实现一些迭代器方法来遍历网格的单元格. 一些算法, 比如 Sidewinder, 想要一次查看一行单元格, 所以我们将为此提供一个 `each_row` 方法. 其他算法, 比如 Binary Tree, 只是想一次看一个单元格. 我们将用 `each_cell` 来处理这种情况.

#+BEGIN_SRC ruby
  def each_row
    @grid.each do |row|
      yield row
    end
  end

  def each_cell
    each_row do |row|
      row.each do |cell|
        yield cell if cell
      end
    end
  end
end
#+END_SRC

真的就这么多了: 一个简单的网格实现, 非常适合演示迷宫算法. 再次强调, 这不是最终产品——我们将在后面的章节中对其进行补充——但它足以开始研究我们已经知道的两种算法. 让我们看看这个网格在实践中是如何工作的.

** 实现二叉树算法
Implementing the Binary Tree Algorithm

让我们从二叉树算法开始. 正如你从*二叉树算法*, 第 6 页所记得的, 它的工作原理很简单, 即访问网格中的每个单元格, 并选择向北或向东开辟一条通道.

下面的代码就是这样做的. 我们将把它放在它自己的类中, 这样我们就可以在任何需要的时候轻松地重用这段代码. 将它保存到一个名为 `binary_tree.rb` 的文件中, 并确保它与我们之前创建的 `cell.rb` 和 `grid.rb` 文件在同一个目录中.

#+BEGIN_SRC ruby
binary_tree.rb
class BinaryTree
  def self.on(grid)
    grid.each_cell do |cell|
      neighbors = []
      neighbors << cell.north if cell.north
      neighbors << cell.east if cell.east

      index = rand(neighbors.length)
      neighbor = neighbors[index]

      cell.link(neighbor) if neighbor
    end

    grid
  end
end
#+END_SRC

`on(grid)` 方法接受一个网格, 并通过迭代其每个单元格来对其应用二叉树算法. 对于每个单元格, 我们收集其北部和东部的相邻单元格, 将它们放入一个列表中. 然后, 我们从该列表中随机选择一个单元格, 并将其与当前单元格链接起来. 请记住, 网格东北角的单元格没有北部或东部的邻居, 所以我们需要确保 `neighbor` 是有效的, 然后再尝试链接它.

不错! 通过一些代码精简, 你或许可以进一步简化它 (如果愿意, 可以把它当作一个挑战), 但这已经说明了问题. 二叉树算法很简单.

#+BEGIN_QUOTE

 * 从数组中选择随机元素
Choosing Random Elements from Arrays

看看 `binary_tree.rb` 列表的第 9 行和第 10 行, 程序在那里随机选择一个邻居. 这没问题, 但 Ruby (至少) 有一种更简单的方法来做到这一点:
#+BEGIN_SRC ruby
neighbor = neighbors.sample
#+END_SRC
这一行将从 `neighbors` 数组中抽样 (sample)——或随机选择一个元素. 从现在开始, 我们将使用这个 `sample` 方法.
#+END_QUOTE

接下来让我们编写一个简单的程序, 用来把这些部分组合在一起. 请将以下内容放入一个名为 `binary_tree_demo.rb` 的新文件中.

#+BEGIN_SRC ruby
binary_tree_demo.rb
require 'grid'
require 'binary_tree'

grid = Grid.new(4, 4)
BinaryTree.on(grid)
#+END_SRC

这里没什么复杂的. 我们引入我们的 `Grid` 和 `BinaryTree` 类, 实例化一个 4×4 网格, 然后在其上运行二叉树算法. 简单.

遗憾的是, 运行这个小程序有点虎头蛇尾. 试试看. (确保传递 `-I.` 来告诉 Ruby 在当前目录中查找依赖项.)

#+BEGIN_SRC sh
$ ruby -I. binary_tree_demo.rb
$
#+END_SRC

它运行, 并完成, 但实际上并没有向我们展示任何东西. 我们只能凭信念相信我们的迷宫已经生成了.

我们可以在这一点上放弃一切, 拿出一个 canvas API, 或者一个图形库, 然后开始绘制墙壁和通道, 但现在真的没必要. 我们很快就会讲到那里. 让我们从更简单的开始, 用 ASCII art.

** 在终端上展示迷宫
Displaying a Maze on a Terminal

ASCII art 不一定是最花哨的方式, 也不是最漂亮的, 但它通常是展示我们迷宫最方便的方式. 我们几乎总是可以轻松访问终端, 而且我们不需要担心拿出任何大炮 (比如外部库或 API). 简而言之, 它非常适合我们现在的需要. 让我们逐步讲解一种可能的方法, 只使用四种不同的字符来绘制我们的迷宫: 空格 (“ ”) 用于单元格和通道, 竖线 (“|”) 用于垂直墙壁, 连字符 (“-”) 用于水平墙壁, 加号 (“+”) 用于绘制角落. 这是一个使用这些字符绘制的小迷宫的例子:

#+BEGIN_SRC text
+---+---+---+---+
|           |   |
+   +   +---+   +
|   |   |       |
+---+---+   +---+
|           |
+   +---+   +   +
|   |   |   |   |
+---+---+---+---+
#+END_SRC

#+BEGIN_QUOTE
小心不要把线条看作是这些图画中的通道! 线条是墙壁, 而空白代表走廊.
#+END_QUOTE

如图所示, 我们将让每个单元格与其邻居共享墙壁. 也就是说, 一个单元格的东墙将与其东边邻居的西墙相同. 这简化了实现, 因为当我们去绘制迷宫时, 我们只需要绘制每个单元格的东部和南部边界. 我们不需要担心一个单元格的北部或西部边界 (一般情况下), 因为当绘制北部或西部的相邻单元格时, 它会绘制自己的南部或东部边界——这对应于我们正在看的单元格的北部或西部边界.

迷宫本身的北部和西部边界仍然需要特别绘制, 因为边界之外没有单元格可以为我们绘制那些墙壁. 不过, 这只是一个小小的代价.

因为这是一个通常会有用的东西, 而且我们希望能够反复使用, 所以我们将让 `Grid` 类知道如何将自己渲染为文本. 我们将把我们的实现放在 `Grid` 的 `to_s` 方法中.

#+BEGIN_QUOTE
Joe 提问:
`to_s` 有什么特别之处?
What’s So Special About to_s?

在 Ruby 中, 当运行时需要将一个对象转换为字符串时, 就会调用 `to_s` 方法. (因此得名: `to_s`, 或 to string.) 通过实现一个自定义的 `to_s` 方法, 我们为对象 (比如我们的 `Grid`) 提供了一种以理智、人类可读的方式展示自己的方法.

其他面向对象的语言也有类似的设施. 例如, 在 JavaScript、Java 和 C# 中, 你可以覆盖 `toString()` 方法. 在 SmallTalk 中, 它是 `asString`. 在 Objective-C 中, 它是 `description`. 在 C++ 中, 你实际上是覆盖 `<<` 操作符!
#+END_QUOTE

那么, 请打开 `grid.rb`, 并在文件底部的 `end` 关键字之前添加以下方法.

#+BEGIN_SRC ruby
grid.rb
  def to_s
    output = "+" + "---+" * columns + "\n"

    each_row do |row|
      top = "|"
      bottom = "+"

      row.each do |cell|
        cell = Cell.new(-1, -1) unless cell

        body = "   " # <-- that's THREE (3) spaces!
        east_boundary = (cell.linked?(cell.east) ? " " : "|")
        top << body << east_boundary

        south_boundary = (cell.linked?(cell.south) ? " " : "---")
        corner = "+"
        bottom << south_boundary << corner
      end

      output << top << "\n"
      output << bottom << "\n"
    end

    output
  end
#+END_SRC

首先, 第 2 行将输出缓冲区初始化为网格的顶部边界. 这包括每个单元格角落的一个加号字符和该第一行中每个单元格的北墙的三个连字符.

然后, 从第 4 行开始, 我们开始遍历网格的每一行. 如前所述, 每个单元格将简单地使用其上方单元格的南墙作为自己的北墙, 所以我们只需要担心单元格的主体、其东部边界和其南部边界. 我们将把每一行单元格的主体和东墙累积到一个变量 (`top`) 中, 将南部边界累积到另一个变量 (`bottom`) 中. 在每一行的开始, 我们将通过将这些变量初始化为网格的西部边界来“启动泵”, 使用一个竖管作为西墙, 一个加号作为该行的西南角 (第 5 行和第 6 行).

一旦这些变量被初始化, 我们将遍历该行中的每个单元格 (从第 8 行开始), 一次构建一个单元格的输出, 然后在该行完成后将这两个变量连接在一起.

某些单元格可能 (最终) 是 `nil`, 所以第 9 行通过实例化一个虚拟的 `Cell` 对象来处理这种情况. 然后, 我们将当前单元格的主体和东墙连接到 `top` 变量, 将南墙和东南角连接到 `bottom` 变量. 每一行都通过将这两个变量的内容附加到输出中来完成, 带有换行符, 然后我们再来一遍, 直到每一行都处理完毕.

到那时, 我们就完成了, 第 25 行只是返回输出缓冲区的内容. 注意, 在 Ruby 中, `return` 关键字在方法的末尾是可选的——每个方法都会返回最后一个被评估的表达式的值.

一旦我们把那个新方法保存到 `grid.rb`, 我们就可以回到 `binary_tree_demo.rb` 文件, 并在最底部添加一行:

#+BEGIN_SRC ruby
binary_tree_demo.rb
puts grid
#+END_SRC

`puts` 方法会自动调用我们网格上的 `to_s` 方法, 将其转换为字符串, 然后打印出来. 再次运行我们的程序, 我们应该会看到一些更有趣的东西.

#+BEGIN_SRC sh
$ ruby -I. binary_tree_demo.rb
+---+---+---+---+
|       |       |
+---+   +---+   +
|       |   |   |
+---+---+   +   +
|   |       |   |
+   +---+---+   +
|               |
+---+---+---+---+
$
#+END_SRC

它不是蒙娜丽莎, 但在紧急情况下也凑合. 我们不需要为调试或原型设计这样的事情打磨, 甚至一些生产应用程序也发现这种输出足够了. (玩过 NetHack 吗?)

既然你有了看你正在构建什么的方法, 就多玩玩它吧. 改变网格的维度, 看看在你的终端窗口开始乱码之前你能把它做得多大. 你甚至可能想重温一下*二叉树实验*, 第 15 页的一些建议, 看看它们现在是如何结合在一起的.

无论何时你准备好了, Sidewinder 都在等着.

** 实现 Sidewinder 算法
Implementing the Sidewinder Algorithm

Sidewinder 算法 (来自*Sidewinder 算法*, 第 12 页) 在许多方面都与二叉树算法相似. 你会记得它有相似的偏倚, 甚至有一个 (概念上) 相似的方法, 在每一步随机选择要么从当前单元格向东开辟, 要么从当前单元格游程向北开辟. 不过, 在实践中, Sidewinder 感觉像是一个非常不同的野兽.

在代码中, 它看起来像这样. 将以下内容放入一个名为 `sidewinder.rb` 的文件中.

#+BEGIN_SRC ruby
sidewinder.rb
class Sidewinder
  def self.on(grid)
    grid.each_row do |row|
      run = []

      row.each do |cell|
        run << cell

        at_eastern_boundary = (cell.east == nil)
        at_northern_boundary = (cell.north == nil)

        should_close_out =
          at_eastern_boundary ||
          (!at_northern_boundary && rand(2) == 0)

        if should_close_out
          member = run.sample
          member.link(member.north) if member.north
          run.clear
        else
          cell.link(cell.east)
        end
      end
    end

    grid
  end
end
#+END_SRC

我们从第 4 行开始, 逐行遍历网格. 在每一行的开始, 我们为我们的游程集创建一个新数组, 然后遍历当前行中的每个单元格. 第 10 行和第 11 行检查我们是否在东部或北部边界 (如果是, 单元格在那个方向上将没有邻居), 第 13-15 行用它来判断是否是时候结束当前的游程. 回想一下, 我们总是在一行的末尾 (在东部边界) 结束游程, 但我们也会在一行内随机地这样做 (即 `rand(2) == 0`), 只要我们不在最北边的一行 (以避免穿透迷宫的外墙).

一旦我们输入了这些, 让我们尝试运行它. 创建另一个文件, `sidewinder_demo.rb`, 并将以下内容放入其中.

#+BEGIN_SRC ruby
sidewinder_demo.rb
require 'grid'
require 'sidewinder'

grid = Grid.new(4, 4)
Sidewinder.on(grid)
puts grid
#+END_SRC

运行它, 我们应该会看到类似这样的东西:

#+BEGIN_SRC sh
$ ruby -I. sidewinder_demo.rb
+---+---+---+---+
|               |
+   +---+   +   +
|   |   |   |   |
+---+   +   +   +
|       |   |   |
+   +---+   +---+
|       |       |
+---+---+---+---+
$
#+END_SRC

小菜一碟! (就像我爸爸常说的). 它可能比二叉树要复杂一点, 但也说不上多. 多玩玩它. 再看看*Sidewinder 实验*, 第 16 页中提到的一些想法, 看看它们在代码中是如何结合在一起的.

当你准备好了, 我们将以一种更专业的方式来渲染这些迷宫, 以结束本章.

** 将迷宫渲染为图像
Rendering a Maze as an Image

ASCII art 无疑是功能性的, 但不一定吸引人. 通常, 我们希望我们的产品能有更多的润色. 幸运的是, 大多数语言都有可用的 API, 可以直接绘制到视图上, 或者 (至少) 渲染到一个离屏画布上并将其保存为图像文件. 我们将用一个名为 ChunkyPNG² 的 Ruby 库来探索后一种技术, 它将让我们把我们的迷宫写成 PNG 图像. (这些概念应该可以轻松地转换到其他 UI 和图形 API.)

如果你正在用 Ruby 跟随, 你需要安装 ChunkyPNG 才能让接下来的代码工作. 幸运的是, 这不难:

#+BEGIN_SRC sh
$ gem install chunky_png
#+END_SRC

好了, 那么.

就像我们使用 `to_s` 方法来渲染迷宫的文本表示一样, 我们将在 `Grid` 上引入一个 `to_png` 方法来给我们图形表示. 它的前半部分只是设置, 计算我们图像的维度和实例化我们的画布. 第二半部分是重点; 它与我们写入迷宫到终端的方式没有太大不同.

请再次打开 `grid.rb` 文件. 在文件的最顶部, 添加以下行以确保 ChunkyPNG 库被加载.

#+BEGIN_SRC ruby
require 'chunky_png'
#+END_SRC

现在, 在最后的 `end` 关键字之前 (在我们之前添加的 `to_s` 方法之后) 添加以下方法.

² http://chunkypng.com/

#+BEGIN_SRC ruby
  def to_png(cell_size: 10)
    img_width = cell_size * columns
    img_height = cell_size * rows

    background = ChunkyPNG::Color::WHITE
    wall = ChunkyPNG::Color::BLACK

    img = ChunkyPNG::Image.new(img_width + 1, img_height + 1, background)

    each_cell do |cell|
      x1 = cell.column * cell_size
      y1 = cell.row * cell_size
      x2 = (cell.column + 1) * cell_size
      y2 = (cell.row + 1) * cell_size

      img.line(x1, y1, x2, y1, wall) unless cell.north
      img.line(x1, y1, x1, y2, wall) unless cell.west

      img.line(x2, y1, x2, y2, wall) unless cell.linked?(cell.east)
      img.line(x1, y2, x2, y2, wall) unless cell.linked?(cell.south)
    end

    img
  end
#+END_SRC

`to_png` 方法接受一个名为 `cell_size` 的命名参数, 我们将用它来指示单元格应该画多大 (默认为 10 像素见方). 我们将使用该值在第 2 行计算我们图像的维度. 然后我们决定我们的背景色 (白色) 和墙壁色 (黑色), 并实例化我们的画布 (第 8 行).

接下来, 我们开始迭代单元格, 依次绘制每一个. 第 11 到 14 行计算西北角 (x1,y1) 和东南角 (x2,y2) 的坐标, 这给了我们绘制当前单元格的四堵墙所需的全部信息.

这正是我们接下来要做的. 首先, 我们检查单元格是否有北边或西边的邻居, 如果没有, 我们就画那些墙 (第 16 和 17 行). 请注意, 如果单元格确实有北部或西部的邻居, 那个邻居将改为画那些墙, 因为每个单元格总是会根据需要画自己的南部和东部墙壁. 第 19 和 20 行处理这个问题.

然后, 当所有的单元格都被访问过后, 我们只需返回图像对象, 让调用者随心所欲地处理它. 例如, 将图像保存到磁盘是微不足道的; 只需将以下内容添加到 `sidewinder_demo.rb` 或 `binary_tree_demo.rb` 的末尾.

#+BEGIN_SRC ruby
img = grid.to_png
img.save "maze.png"
#+END_SRC

从那里, 只需要在你喜欢的图像查看器中打开 `maze.png`. Voilà!

#+CAPTION: 一个渲染为 PNG 图像的迷宫的例子.

能够将我们的迷宫渲染为图像开启了许多可能性. 我们将在本书中充分利用这一点, 特别是当我们探索不同形状 (第 6 章, *将迷宫拟合到形状*, 第 83 页和第 7 章, *兜圈子*, 第 97 页) 和形式 (第 14 章, *弯曲和折叠你的迷宫*, 第 223 页) 的迷宫时.

** 轮到你了
Your Turn

你现在差不多走上了统治世界的道路. 你不仅可以生成随机迷宫, 还可以展示它们! 你已经玩过了一些变体, 尝试了一些自己的技巧, 你对这一切都感到相当自信.

现在是有趣的部分. 这是你可以自己探索的地方, 看看你的想法会带你到哪里. 如果你仍然感到有点缺乏想法, 可以浏览下面的一些建议以获取灵感!

*** 网格
Grids

本章中的实现只是表示网格的许多可能方式之一. 这里还有两种思考这个问题的方式. 也许你还能想到更多!

**** 位域网格
Bitfield Grids

如果不用 `Cell` 对象数组, 而是直接使用整数数组呢? 单元格之间的连接将通过数组中每个元素上设置的位来表示. 这给你一个非常节省内存的网格, 但它能表示的东西往往相当有限.

**** 边和节点
Edges and Nodes

戴上你的计算机科学家帽子! 如果你对图论有所了解, 你无疑已经注意到了网格和图之间的联系. 我们上一章谈到的那些完美迷宫? 是的, 树. 单元格和通道只是节点和边的别名. 如果这种联系对你有用, 试试用那种方式实现网格. 每个节点有零个或多个边, 每个边恰好有两个节点. 这给你一个更耗内存的网格, 但它几乎可以表示任何类型的迷宫!

*** 终端显示
Terminal Display

我并不羞于承认本章中演示的终端显示确实有点“快而脏”. 这里有几种可能的方法来稍微清理一下它.

**** 更简洁的字符
Cleaner Characters

如果加号字符只用在三个或更多墙段的交界处, 文本迷宫会看起来更整洁. 你要如何改变显示例程来让它更智能地做到这一点?

**** Unicode 网格
Unicode Grids

如果不用标准的标点符号, 而是用 Unicode 的方框绘制字符来显示迷宫呢? (那是 U+2500 到 U+257F.) 或者你也可以使用任何其他终端字符集中的类似字符.

*** 图形显示
Graphical Display

ChunkyPNG 是一个很棒的库, 但它绝不是这类事情的唯一选择. 这里还有一些你可能考虑绘制迷宫的其他方式, 但看看你还能想到什么.

**** 其他图形平台
Other Graphics Platforms

试试其他一些图形平台. PDF 是另一个很棒的格式, 在许多语言中都有强大的支持. 也许你更愿意将你的迷宫渲染成 SVG, 或者甚至用 JavaScript 将它绘制到 HTML canvas 对象上! 尝试不同的 API, 看看哪个最适合你.

**** 更厚的墙壁
Thicker Walls

本章中展示的方法创建了纸一样薄的墙壁的迷宫, 这并不总是最实用的迷宫类型. 如果墙壁有实际的厚度, 你会如何渲染你的迷宫? (当我们到第 9 章, *编织和交织你的迷宫*, 第 129 页时, 这就成了一个有实际应用的问题.)

**** 使用瓦片
Using Tiles

与其按需绘制每个单元格, 你可以预先渲染每种类型的单元格, 然后像瓦片一样将它们铺开. 看看一个单元格可能存在的所有出口组合, 然后预先全部画出来. 对于一个简单的正交 (即矩形) 迷宫, 有 15 种不同的单元格类型 (如果包括空白单元格, 则是 16 种), 从四向交叉口, 到四种不同的三向交叉口, 依此类推, 一直到死胡同.

接下来, 我们将让你真正势不可挡. 我们将看看如何实际解决你一直在创造的这些迷宫

* 第 3 章：寻找解法
*Finding Solutions*

生成一个又一个迷宫固然有趣, 但最终总会有人问你如何真正*解决*这些谜题. 一两次还好, 但你最不想做的事就是不停地用纸笔, 手动为每一个迷宫逐一找出解法. 那样你就没时间制作更多迷宫了! 既然计算机生成了这些迷宫, 它当然也能解决它们, 对吧?

你猜对了.

事实证明, 我们可以从一大堆解决迷宫的算法中进行选择——多到如果我们试图全部涵盖, 这本书至少会变成两本书. 一些算法, 比如 Pledge 或 Trémaux 算法, 在你无法看到整个迷宫时很有用. 其他的, 比如死胡同填充法和最短路径算法, 则需要更全知的视角. 说真的, 这里要涵盖的太多了. 因此, 我们将专注于一种算法, 即寻路算法中的瑞士军刀: Dijkstra 算法.

#+BEGIN_QUOTE
Joe 提问:
谁是“Dijkstra”?
Who Is “Dijkstra?”

Edsger Dijkstra (1930–2002) 是一位荷兰计算机科学家. 除了发明他同名的算法外, 他还在计算机科学的许多不同领域非常活跃, 例如形式化验证和分布式计算. 他还写了许多论文和文章, 包括 1960 年代末一篇著名的信, 题为“Go To 语句被认为有害”.
#+END_QUOTE

就像任何瑞士军刀一样, 它并不总是最适合工作的工具. 其他算法可能会更快或更有效地解决某些迷宫, 但 Dijkstra 算法尽管如此仍有很多优点. 首先, 它不挑剔你给它的迷宫. 一些算法只适用于特定类型的迷宫, 但 Dijkstra 算法不是! 我们扔给它的任何东西它都能解决. 其次, Dijkstra 算法的副产品能让我们做一些有趣的事情, 比如增加我们迷宫的难度, 或者让我们洞察它们的纹理以及我们用来生成它们的算法的偏倚.

在本章中, 我们将看一个简化版的 Dijkstra 算法, 逐步讲解它, 然后看看它在代码中是如何实现的. 我们还将看到其中一些副产品在实践中的应用, 当我们试图在迷宫中寻找更长的路径, 或给它们上色以更好地可视化纹理时.

** Dijkstra 算法
Dijkstra’s Algorithm

Dijkstra 算法测量某个起点 (我们指定) 与迷宫中所有其他单元格之间的最短距离. 简而言之, 它的工作原理是从我们选择的点开始, 像洪水一样淹没迷宫. 洪水到达一个单元格所需的时间越长, 该单元格离我们的起点就越远.

接下来的算法版本是稍微简化了的. 完整的算法可以在任何单元格和通道的配置中找到最短路径, 无论这些单元格是如何连接的, 我们将在本书后面看到那个版本. 就目前而言, 简化版就足够我们用了.

算法始于给定一个起点. 这通常是我们想要寻找的路径的起点, 比如迷宫的入口. 算法用零标记它, 因为从那个单元格到它自身的路径长度正好是零个单元格. Dijkstra 算法还没有弄清楚这个单元格与网格中所有其他单元格之间的距离, 所以它将所有其他单元格的距离设置为空白或未定义. 下图使用西北角作为起点.

#+CAPTION: 迷宫, 西北角标记为 0.

接下来, 它查看与该单元格相连的所有未访问过 (白色, 未编号) 的邻居. 我们将这组单元格称为*前沿* (frontier). 算法将前沿中每个单元格的值赋为 1, 因为它们都恰好离起点一个单元格远. 这里我们看到第一个单元格只有一个可达的邻居, 所以新的前沿集只包含那一个单元格.

#+CAPTION: 迷宫, 起点的邻居被标记为 1.

算法对新的前沿集中的那个单元格, 也就是刚刚被标记为 1 的那个, 重复整个过程. 它访问该单元格的每个未访问过的、可达的邻居, 并将它们的距离设为 2, 因为它们每个都比我们的起点远一步. 那些单元格现在成为新的前沿集, 如图所示.

#+CAPTION: 迷宫, 距离为 1 的单元格的邻居被标记为 2.

这个过程重复进行, 直到迷宫中的每个单元格都被访问过 (即, 被赋予了一个距离). 下图让你了解我们最终得到的东西: 一个矩阵, 显示了迷宫中每个单元格相对于那个初始起点的距离.

#+CAPTION: 一个完整的距离矩阵.

有了这个矩阵, 我们可以做很多很酷的事情, 其中最重要的一点是找到从迷宫中任何单元格回到起点的路径. 为此, 我们将自己定位在路径的*终点*——我们称之为*目标* (goal)——然后查看相邻的单元格. 距离比当前单元格小一的那个单元格将是我们路径上的下一个踏脚石. 我们将那个单元格设为当前单元格, 重复这个过程, 直到我们到达初始单元格 (距离为零的那个), 我们就完成了! 下图显示了这样一条路径, 如果选择东南角作为目标的话.

#+CAPTION: 从目标 (8) 回溯到起点 (0) 的最短路径.

这总是保证是这两点之间的最短路径. 这是一个非常有用的保证! 接下来, 让我们看看实现这个的一种方法.

** 实现 Dijkstra 算法
Implementing Dijkstra’s

为了将这个简化版的 Dijkstra 算法整合起来, 我们将依赖一个名为 `Distances` 的新类, 它将跟踪每个单元格离参考单元格 (我们开始计数的单元格) 有多远. 一旦我们实现了那个类, 我们将把 Dijkstra 算法的实际实现添加到 `Cell` 类中, 这将让我们几乎可以在任何需要的地方应用它.

所以, 首先, 让我们添加那个 `Distances` 类. 目前, 它只是一个 `Hash` 实例的简单包装器, 但我们很快就会让它变得更有用. 创建一个名为 `distances.rb` 的新文件, 并向其中添加以下内容.

#+BEGIN_SRC ruby
distances.rb
class Distances
  def initialize(root)
    @root = root
    @cells = {}
    @cells[@root] = 0
  end

  def [](cell)
    @cells[cell]
  end

  def []=(cell, distance)
    @cells[cell] = distance
  end

  def cells
    @cells.keys
  end
end
#+END_SRC

我们将使用这个类来记录每个单元格离起点 `@root` 的距离, 所以 `initialize` 构造函数只是设置哈希表, 使根节点离自身的距离为 0.

我们还添加了一个数组访问器方法 `[](cell)`, 这样我们就可以查询给定单元格离根节点的距离, 以及一个相应的设置器 `[]=(cell, distance)`, 用于记录给定单元格的距离.

最后, 我们添加一个 `cells` 方法来获取存在的所有单元格的列表.

足够简单.

接下来, 让我们使用那个新类. 我们将向 `Cell` 添加一个 `distances` 方法, 它将实现 Dijkstra 算法并返回一个包含我们之前谈到的那个距离矩阵的 `Distances` 实例.

首先, 我们需要确保我们的新 `Distances` 类被加载. 将以下行添加到 `cell.rb` 的最顶部.

#+BEGIN_SRC ruby
require 'distances'
#+END_SRC

现在, 在该文件的末尾, 就在最后的 `end` 关键字之前, 添加以下方法.

#+BEGIN_SRC ruby
  def distances
    distances = Distances.new(self)
    frontier = [ self ]

    while frontier.any?
      new_frontier = []

      frontier.each do |cell|
        cell.links.each do |linked|
          next if distances[linked]
          distances[linked] = distances[cell] + 1
          new_frontier << linked
        end
      end

      frontier = new_frontier
    end

    distances
  end
#+END_SRC

在第 2 行, 我们实例化了我们的新 `Distances` 类, 我们将用它来存储我们即将计算的所有距离. 当前单元格是根节点, 因为所有的距离都将相对于它. 我们还将我们的前沿集初始化为一个只包含一个元素的数组: 这个单元格, 我们的起点.

第 5 行开始了驱动算法的循环. 我们将一直循环, 直到前沿集中不再有单元格, 这将意味着我们已经测量了每个单元格到我们根单元格的距离.

在每次循环中, 我们创建一个新的前沿集 (第 6 行), 它将保存所有与当前前沿集中的单元格相连的未访问过的单元格. 这些将在算法的下一次传递中被考虑. 当前的传递将通过迭代前沿单元格 (第 8 行) 并考虑与它们相连的每个邻居 (第 9 行) 来填充该集.

由于我们的映射最初在单元格未被访问过时返回 `nil`, 第 10 行可以用它来检测已经被访问过的单元格, 并跳过它们. 否则, 第 11 行计算被链接单元格的距离, 比前沿单元格的距离多一 (因为它远了一步), 然后将该单元格添加到我们的新前沿集中 (第 12 行).

在所有的前沿单元格都被考虑过之后, 我们将新的前沿集设为真正的前沿 (第 16 行), 然后再来一遍. 当算法完成时, 我们返回我们的距离映射, 正如所承诺的那样.

呼!

我们差不多准备好了, 但我们还没有办法看到 Dijkstra 算法返回的结果. 我们希望能够显示单元格本身的相应距离值, 但我们现有的 `Grid#to_s` 不太可扩展. 我们要么必须直接更改 `Grid` 类中的版本 (不太吸引人, 因为大多数网格不需要这个功能), 要么我们必须将它的大部分复制粘贴到另一个类中, 以便我们进行更改.

相反, 让我们花点时间退一步, 解决根本问题. 让我们让 `Grid#to_s` 更具可扩展性. 我们将添加一个名为 `contents_of(cell)` 的方法, 子类可以覆盖它, 它将描述可用于标记任何给定单元格的文本. 默认情况下, 它只会渲染一个空格, 这是我们现有实现的行为. 打开 `grid.rb` 并在 `to_s` 方法之前添加这个新方法.

#+BEGIN_SRC ruby
  def contents_of(cell)
    " "
  end
#+END_SRC

现在, `grid.rb` 仍然打开, 找到 `to_s` 方法. 我们要更改一行, 即描述单元格主体的那部分, 以便它调用我们的新 `contents_of(cell)` 方法. 相关行在以下片段中高亮显示.

#+BEGIN_SRC ruby
    row.each do |cell|
      cell = Cell.new(-1, -1) unless cell

      body = " #{contents_of(cell)} "
      east_boundary = (cell.linked?(cell.east) ? " " : "|")
      top << body << east_boundary

      south_boundary = (cell.linked?(cell.south) ? " " : "---")
      corner = "+"
      bottom << south_boundary << corner
    end
#+END_SRC

感谢那个快速的更改, 我们现在可以组合一个简单的 `Grid` 子类, 它将能够渲染自己并显示每个单元格的距离数字.

创建一个名为 `distance_grid.rb` 的新文件, 并将以下代码放入其中. 这将覆盖 `contents_of` 方法以返回每个单元格的距离信息. 请记住, `Grid#to_s` 方法调用 `contents_of` 来发现每个单元格应该如何渲染. 通过在这里返回距离信息, 我们可以将该信息直接插入到我们的文本格式迷宫中! 这应该能让我们对正在发生的事情有一定的可见性.

#+BEGIN_SRC ruby
distance_grid.rb
require 'grid'

class DistanceGrid < Grid
  attr_accessor :distances

  def contents_of(cell)
    if distances && distances[cell]
      distances[cell].to_s(36)
    else
      super
    end
  end
end
#+END_SRC

注意, 因为我们被限制在单元格主体的一个 ASCII 字符内, 我们将距离格式化为 36 进制整数. 也就是说, 数字 0 到 9 照常表示, 但当我们达到十进制数 10 时, 我们切换到字母. 数字 10 是 `a`, 11 是 `b`, 12 是 `c`, 依此类推, 一直到 `z` 代表 35. 然后, 数字 36 变成 `10`, 个位数重新开始. 这让我们能够用一个字符表示高达 35 的距离.

现在我们可以实例化这个 `DistanceGrid` 类, 看看它们是如何组合在一起的. 将以下代码放入一个名为 `dijkstra.rb` 的文件中.

#+BEGIN_SRC ruby
dijkstra.rb
require 'distance_grid'
require 'binary_tree'

grid = DistanceGrid.new(5, 5)
BinaryTree.on(grid)

start = grid
distances = start.distances

grid.distances = distances
puts grid
#+END_SRC

这里的二叉树算法没有什么特别的——随意用你喜欢的任何算法替换它, 特别是当我们开始研究更多算法时. 这件事的重点实际上从第 7 行开始, 我们在那里选择我们的起始单元格. 下一行调用我们新的 `Cell#distances` 方法来计算每个单元格相对于那个起始单元格的距离, 然后我们在第 10 行将它赋给网格的 `distances` 属性. 当我们最终显示网格时, 它将使用那个距离信息来装饰每个单元格.

运行它试试. 你应该会得到类似下面的东西.

#+BEGIN_SRC text
$ ruby -I. dijkstra.rb
+---+---+---+---+---+
| 0   1   2   3   4 |
+   +   +---+   +   +
| 1 | 2 | 5   4 | 5 |
+---+---+---+---+   +
| a   9   8   7   6 |
+   +---+---+   +   +
| b | a   9   8 | 7 |
+---+   +   +   +   +
| c   b | a | 9 | 8 |
+---+---+---+---+---+
#+END_SRC

Voilà! 这是我们的矩阵. 我们的起始位置——在西北角——距离为 0, 正如预期的那样. 其他单元格从 1 到 9 计算它们的距离, 在那一点上切换到字母 (感谢那些 36 进制数) 来表示 10, 11, 等等.

** 寻找最短路径
Finding the Shortest Path

这个练习的全部意义在于帮助我们找到迷宫的解法, 即任意两点之间的路径, 所以我们接下来就来解决这个问题. 我们将或多或少地实现前面描述的内容, 从我们的目标向后走, 寻找距离依次减小的相邻单元格.

我们首先决定我们希望路径在哪里结束 (让我们把它设为西南角), 然后从那里向后工作. 对于路径上的每个单元格, 距离最小的相邻单元格将是解法的下一步.

还记得我说过我们很快会让 `Distances` 类更有用吗? 就是现在. 我们将把下面的方法插入其中. 打开 `distances.rb` 并在 `Distances` 类的定义末尾, 就在该类的最后一个 `end` 关键字之前, 添加这个方法.

#+BEGIN_SRC ruby
  def path_to(goal)
    current = goal

    breadcrumbs = Distances.new(@root)
    breadcrumbs[current] = @cells[current]

    until current == @root
      current.links.each do |neighbor|
        if @cells[neighbor] < @cells[current]
          breadcrumbs[neighbor] = @cells[neighbor]
          current = neighbor
          break
        end
      end
    end

    breadcrumbs
  end
#+END_SRC

这个方法接受一个单元格, 并计算出从原始起点到那个单元格的路径. 第 2 行通过指示给定的 `goal` 是我们当前的单元格来开始, 我们将从那里向后工作. 然后, 第 4 行的 `breadcrumbs` 变量被初始化为一个新的 `Distances` 实例, 它最终将只包含位于路径上的那些单元格. 我们用参考单元格 `@root` 来启动它.

这个过程现在开始一个循环, 从第 7 行开始, 一直持续到我们到达 `@root` 单元格. 该循环的每次迭代都会检查当前单元格的所有链接邻居 (第 8 行), 寻找一个更接近根的邻居 (第 9 行). 当它找到一个时, 那个邻居被添加到 `breadcrumbs` 中 (第 10 行), 然后循环以那个邻居作为当前单元格重复.

注意它如何返回一个 `Distances` 实例 (`breadcrumbs` 对象). 这意味着它显示起来轻而易举, 因为我们所要做的就是把那个新的映射交给网格. 我们更新过的 `contents_of` 方法将显示路径上单元格的值 (因为它们存在于新的映射中), 并为所有其他单元格渲染空白 (因为它们不存在于那个映射中).

要运行这个, 我们只需要调用那个新的 `path_to` 方法. 将这个添加到 `dijkstra.rb` 的底部.

#+BEGIN_SRC ruby
dijkstra.rb
puts "path from northwest corner to southwest corner:"
grid.distances = distances.path_to(grid[grid.rows - 1, 0])
puts grid.to_s
#+END_SRC

结果如何? 现在运行它, 你应该会看到你的迷宫两次——一次是完整的距离值矩阵, 一次只显示西北角和西南角之间的路径, 类似下面的东西.

#+BEGIN_SRC sh
$ ruby -I. dijkstra.rb
+---+---+---+---+---+
| 0   1   2   3   4 |
+   +---+---+---+   +
| 1 |   8   7   6   5 |
+   +---+   +---+   +
| 2 |   9   8 | 7   6 |
+   +---+   +   +   +
| 3 |   a   9 | 8 | 7 |
+---+---+---+   +   +
| c   b   a   9 | 8 |
+---+---+---+---+---+

path from northwest corner to southwest corner:
+---+---+---+---+---+
| 0   1   2   3   4 |
+   +---+---+---+   +
|   |               5 |
+   +---+   +---+   +
|   |       |   7   6 |
+   +---+   +   +   +
|   |       |   8 |   |
+---+---+---+   +   +
| c   b   a   9 |   |
+---+---+---+---+---+
#+END_SRC

就这样! 你刚刚使用了 Dijkstra 算法来找到你迷宫中两点之间的最短路径. 这很棒. 现在当你的朋友向你要你迷宫的解法时, 你再也不用表现得那么尴尬了. 你只会知道.

但我们还没用完 Dijkstra 算法. 我称它为瑞士军刀时可没开玩笑. 哦, 不. 到目前为止我们所展示的只是它如何帮助*解决*一个迷宫. 它还可以用来让一个迷宫更具挑战性, 这是我们作为迷宫创造者应该了解的一个属性. 我们接下来就来看看这个.

** 制作更具挑战性的迷宫
Making Challenging Mazes

有很多方法可以让一个迷宫更具挑战性, 但其中许多都是高度主观且难以量化的. Think Labyrinth! 网站的作者 Walter D. Pullen 在他的迷宫心理学页面¹上列出了许多挑战性迷宫的考虑因素, 而且列表不短. 我们将在这里只关注其中一个——解法长度——我们将看到 Dijkstra 算法如何再次拯救世界.

一般来说, 路径越长, 迷宫越难. 理想情况下, 如果我们想要一个更具挑战性的迷宫, 我们想要识别出其中最长的路径. 然后我们将迷宫的入口放在路径的一端, 将目标放在另一端, 我们就提高了难度. 就这么简单.

一个通用的“最长路径”问题——一个适用于任何任意图或网格的解法——是数学家们所说的 NP-hard 问题. 幸运的是, 我们可以稍微缩小我们的要求. 如果我们只是想在*完美迷宫*中找到最长路径, 恰好有几种不同的方法可以解决它, Dijkstra 算法就是其中之一.

¹ http://www.astrolog.org/labyrnth/psych.htm

我们刚刚用来寻找*最短*路径的算法也可以用来寻找*最长*路径, 这可能看起来违反直觉, 但请记住: Dijkstra 算法已经方便地为每个单元格标记了一个距离值. 我们所要做的就是在迷宫中寻找最大的那个. 这将告诉我们从我们的起点到那个单元格的最长路径.

不过要小心! 这不一定是迷宫中*最长*的路径. 如果我们的起始单元格恰好在实际最长路径的中间某个位置, 那么从那个单元格出发的最长路径将比真正的路径短. 诀窍是*运行算法两次*. 第一次, 你从某个任意的起点找到最远的单元格. 第二次, 你反过来, 用那个最远的单元格作为起点, 让 Dijkstra 告诉你从*那里*出发最远的单元格. 我们基本上是在请求 Dijkstra 告诉我们相对于最远点的最远点.

为了实现这一点, 我们需要在我们的 `Distances` 类中引入一个新方法, 来告诉我们哪个单元格离根节点最远, 以及有多远. 再次打开 `distances.rb` 并在 `Distances` 类中, 就在 `path_to` 方法之后, 添加以下方法.

#+BEGIN_SRC ruby
  def max
    max_distance = 0
    max_cell = @root

    @cells.each do |cell, distance|
      if distance > max_distance
        max_cell = cell
        max_distance = distance
      end
    end

    [max_cell, max_distance]
  end
#+END_SRC

这只是遍历哈希中的每个单元格, 跟踪哪个单元格的距离最大. 完成后, 它返回一个包含它所找到的东西的数组.

现在, 将以下代码放入一个名为 `longest_path.rb` 的文件中. 注意, 它的工作方式与 `dijkstra.rb` 类似, 但不是简单地显示距离矩阵, 第 7-15 行实现了 Dijkstra 算法的两次传递, 正如刚才描述的, 以找到迷宫中的最长路径.

#+BEGIN_SRC ruby
longest_path.rb
require 'distance_grid'
require 'binary_tree'

grid = DistanceGrid.new(5, 5)
BinaryTree.on(grid)

start = grid

distances = start.distances
new_start, distance = distances.max

new_distances = new_start.distances
goal, distance = new_distances.max

grid.distances = new_distances.path_to(goal)
puts grid
#+END_SRC

第 7 行通过选择西北角作为我们的起始单元格来启动. 请记住, 我们可以选择任何我们想要的单元格——西北角只是简单方便.

接下来, 第 9 行和第 10 行从那个起点运行 Dijkstra 算法, 并发现相对于它的最远单元格, 称之为 `new_start`.

`Distances#max` 返回一个二维数组, 包含最远的单元格及其离根节点的距离. Ruby 支持并行赋值, 所以我们可以直接将该数组的元素赋给单独的变量, 尽管在这种情况下, 距离值实际上并未使用. 不过, 方法返回了它, 所以我们必须把它放在某个地方!

一旦我们有了那个最远的单元格, 我们在第 12 行和第 13 行再做一次, 从那个新的起点找到最远的单元格. 我们将那个新的远单元格赋给 `goal`.

最后, 使用从 `new_start` 开始的 `new_distances` 映射, 我们计算到那个 `goal` 单元格的路径 (第 15 行), 并将其赋给我们网格的 `distances` 属性.

现在运行这个程序应该会向你展示它发现的路径.

#+BEGIN_SRC sh
$ ruby -I. longest_path.rb
+---+---+---+---+---+
|           8   7   6 |
+   +---+   +---+   +
|   |   9 |       5 |
+   +---+   +---+   +
|   | b   a |       4 |
+---+   +   +---+   +
|   c |   |   2   3 |
+---+   +---+   +   +
| e   d |   0   1 |   |
+---+---+---+---+---+
#+END_SRC

#+BEGIN_QUOTE
 * 高效地寻找最长路径
Efficiently Finding the Longest Path

值得一提的是, Dijkstra 算法并不是寻找迷宫中最长路径的最有效方法. 毕竟, 你必须运行算法两次, 这意味着在找到那条路径之前, 每个单元格都会被访问两次.

不过, 如果你利用一点图论知识, 你可以更有效地计算最长路径. 一棵树 (正是我们的完美迷宫的样子) 中最长的路径被称为它的*直径* (diameter), 或*宽度* (width). 使用深度优先搜索 (depth-first search), 你可以遍历那棵树并计算直径. 该算法的细节遗憾地超出了这个小插曲的范围, 但如果你喜欢, 可以把它当作一个挑战!
#+END_QUOTE

在转向更多迷宫算法之前, 让我们看看 Dijkstra 算法可以帮助我们的最后一个技巧. 事实证明, 我们从 Dijkstra 算法得到的数字矩阵也可以被解释为另一种方式: 作为颜色. 我们接下来会看到这有什么用.

** 为你的迷宫着色
Coloring Your Mazes

事实证明, 以一种特殊的方式为迷宫着色就像一台 X 光机, 让我们能够窥探内部, 更清晰地看到迷宫的结构和生成它的算法. Dijkstra 算法是这个的理想选择, 因为它生成的那个数字矩阵. 每个具有相同距离值的单元格都有一个共同点: 它们都与起始单元格等距. 这简直就是在呼唤一个按数字填色的练习.

最简单的方法是将每个数字视为一个强度值, 相对于最长路径的长度. 如果我们反转逻辑, 效果甚至更好, 将距离值最大的单元格视为最暗, 而我们开始的那个单元格 (距离为零) 视为最亮.

为了实现这一点, 我们需要再次深入我们的 `Grid` 类, 调整那个 `to_png` 实现以支持为单元格着色. 我们将像对 `to_s` 那样做, 并将其稍微泛化. 我们将添加一个 `background_color_for(cell)` 方法, 它将返回一个颜色值, `to_png` 将为每个单元格调用它. 子类可以覆盖 `background_color_for` 来实现它们自己的着色规则.

再次打开 `grid.rb`, 我们将进行以下更改, 从添加我们新的 `background_color_for(cell)` 方法开始. 把它放在 `contents_of` 之后, 因为两者有相似的职责.

#+BEGIN_SRC ruby
  def background_color_for(cell)
    nil
  end
#+END_SRC

默认情况下, 它返回 `nil`, 意味着单元格不应该被着色, 但覆盖它的子类应该返回一个 `ChunkyPNG::Color` 实例. (我们很快就会看到它是如何工作的.)

对于 `to_png` 方法, 我们只打算更改该方法中的 `each_cell` 块, 将其替换为以下内容.

#+BEGIN_SRC ruby
    [:backgrounds, :walls].each do |mode|
      each_cell do |cell|
        x1 = cell.column * cell_size
        y1 = cell.row * cell_size
        x2 = (cell.column + 1) * cell_size
        y2 = (cell.row + 1) * cell_size

        if mode == :backgrounds
          color = background_color_for(cell)
          img.rect(x1, y1, x2, y2, color, color) if color
        else
          img.line(x1, y1, x2, y1, wall) unless cell.north
          img.line(x1, y1, x1, y2, wall) unless cell.west
          img.line(x2, y1, x2, y2, wall) unless cell.linked?(cell.east)
          img.line(x1, y2, x2, y2, wall) unless cell.linked?(cell.south)
        end
      end
    end
#+END_SRC

第 1 行将旧的 `each_cell` 块包装在另一个循环中, 该循环迭代两个符号常量: `:backgrounds` 和 `:walls`. 循环第一次通过时, 我们通过调用我们的 `background_color_for` 方法并绘制填充的矩形来为单元格着色 (第 8 行). 第二次, 我们像以前一样绘制墙壁 (第 12-15 行).

现在我们可以子类化 `Grid` 并创建一个 `ColoredGrid` 类, 它将实现我们基于 Dijkstra 的着色规则.

#+BEGIN_SRC ruby
colored_grid.rb
require 'grid'
require 'chunky_png'

class ColoredGrid < Grid
  def distances=(distances)
    @distances = distances
    farthest, @maximum = distances.max
  end

  def background_color_for(cell)
    distance = @distances[cell] or return nil
    intensity = (@maximum - distance).to_f / @maximum
    dark = (255 * intensity).round
    bright = 128 + (127 * intensity).round
    ChunkyPNG::Color.rgb(dark, bright, dark)
  end
end
#+END_SRC

我们的子类只实现了两个方法: 一个我们称之为 `distances=(distances)` 的写入器 (第 5 行) 和我们的 `background_color_for(cell)` 方法 (第 10 行).

`distances=` 方法只是存储距离映射, 并将映射的最大距离值缓存为 `@maximum` (第 7 行). 我们将用它来计算每个单元格的强度颜色, 在 `background_color_for` 的第 12-14 行, 通过测量每个单元格的距离值与那个最大距离的对比. 我们使用那个强度来计算一个暗值和一个亮值, 并组合它们以返回一个绿色的阴影 (第 15 行), 方法是将颜色的红色和蓝色分量设置为暗, 绿色设置为亮. (也随意尝试其他颜色! 例如, 将红色和绿色分量设置为亮, 蓝色保留为暗, 将会给你黄色的阴影. 看看你还能想出什么!)

最后, 为迷宫本身着色变得超级简单. 将以下代码放入一个名为 `coloring.rb` 的新文件中.

#+BEGIN_SRC ruby
coloring.rb
require 'colored_grid'
require 'binary_tree'

grid = ColoredGrid.new(25, 25)
BinaryTree.on(grid)

start = grid[grid.rows / 2, grid.columns / 2]

grid.distances = start.distances

filename = "colorized.png"
grid.to_png.save(filename)
puts "saved to #{filename}"
#+END_SRC

我们正在生成一个比以前更大的迷宫, 25×25, 这样着色会更明显. (它在更小的迷宫上也工作得很好; 只是不那么令人印象深刻!) 再次, 我们使用二叉树算法生成一个迷宫, 然后, 从第 7 行开始, 我们选择我们的起始单元格为网格正中心的那个.

运行它:

#+BEGIN_SRC sh
$ ruby -I. coloring.rb
saved to colorized.png
$
#+END_SRC

打开 `colorized.png`, 你应该会看到类似下图的东西.

#+CAPTION: 一个以绿色着色的二叉树迷宫.

它确实很漂亮, 但我们看的是什么呢? 回想一下, 我们是从网格中心开始运行 Dijkstra 算法的. 那个单元格——具有最小距离值的——将被着色为最亮. 随着单元格离那个单元格越来越远, 它们的颜色会越来越深, 直到最远的单元格最暗.

除了制作一些相当引人注目的抽象艺术外, 这也恰好向我们展示了一些非常有趣且可能非常有用的东西. 它让我们能够非常清楚地看到迷宫的结构. 我们正在用 Dijkstra 风味的 X 光照射它, 看看里面是什么. 事实证明, 这对于让我们能够直观地 (和主观地) 比较各种不同的迷宫算法非常有效.

例如, 下图显示了三种不同的迷宫, 都是用不同的算法生成的.

#+CAPTION: 三个用不同算法生成的着色迷宫: 二叉树, Sidewinder, 和递归回溯.

二叉树迷宫的对角线纹理, 和 Sidewinder 迷宫的垂直纹理, 都清晰可见. 第三种算法, 递归回溯 (Recursive Backtracker), 是我们尚未涵盖的 (我们将在第 5 章, *给随机行走添加约束*, 第 67 页讲到), 但它在这里被包含进来是为了表明, 即使当你不熟悉一个迷宫是如何生成的时候, 这种着色技术也能让你对该算法的预期有一个有用的洞察.

出于这个原因, 我们将在本书中一直使用这种技术. 这是一个很好的工具, 用来观察迷宫的结构和理解生成它的算法的行为.

** 轮到你了
Your Turn

那么, 这就是 Dijkstra 算法. 如前所述, 它不是唯一的——甚至不是最快的——解决迷宫的方法, 但它肯定是一种有用的方法. 我们已经看到了如何用它来找到两个单元格之间的路径. 我们也看到了如何用它来找到一个迷宫中更长 (并希望更具挑战性) 的路径. 最后, 我们用 Dijkstra 来为迷宫着色, 让我们能够窥探内部并看到它们的基本结构.

这里有很多探索的空间. 花些时间摆弄一下 Dijkstra 算法. 熟悉它. 它将是我们在本书中忠实的伴侣!

如果你需要一些想法来开始, 可以考虑其中一些.

*** 动画化 Dijkstra 算法.
Animate Dijkstra’s algorithm.

如果你在 Dijkstra 算法的每一步都绘制迷宫呢? 你应该能够很好地看到“洪水”是如何从起点扩散开来并填满迷宫的.

*** 自适应单元格宽度.
Adaptive cell widths.

你可能已经试过用一个大迷宫运行你的 `dijkstra.rb` 程序. 如果你还没有, 你应该试试. 把它设为 20×20. 它看起来很难看, 网格线都错位了, 因为路径比 35 个单元格长, 导致我们的 36 进制数溢出. 写入每个单元格的标签太长了! 试着根据需要加宽网格单元格, 以容纳某些单元格中更长的文本.

*** 图形化绘制解法路径.
Draw solution paths graphically.

我们用文本显示来绘制我们迷宫的解法, 但要让 `to_png` 绘制解法需要做什么呢? 考虑通过用不同的颜色绘制每个单元格的背景, 或者沿着路径绘制线条或面包屑来显示路径.

*** 其他配色方案.
Other color schemes.

上面介绍的配色方案是单色的, 只用一种颜色的深浅来表示距离. 你还能怎么做呢? 考虑以不同的方式循环 RGB 调色板来创造彩虹填充. 或者将不同的渐变混合在一起创造新的效果.

*** 改变起始单元格.
Change the starting cell.

如果在为迷宫着色之前, 你从迷宫内的不同位置开始 Dijkstra 算法呢? 试着从一个交叉口, 或一个死胡同开始, 看看它如何比较. 或者从每个角落, 或从侧面试试. 你甚至可以雄心勃勃地创建一个动画, 其中每一帧都显示从某条路径上不同单元格着色的迷宫!

现在我们装备了 Dijkstra 算法, 我们准备好 tackling 两种新的迷宫算法了. 在 Dijkstra 算法的帮助下, 我们将看到证据, 证明这些算法为何如此特别——它们没有偏倚. 继续读下去, 看看这意味着什么, 以及它付出了什么代价.

* 第 4 章：通过随机行走避免偏倚
*Avoiding Bias with Random Walks*

到目前为止, 我们已经研究了两种不同的迷宫算法, 尽管它们都易于理解和实现, 但它们也存在一些相当显著的偏倚 (biases). 当然, 这些偏倚可以被规避, 但也许有更好的方法. 在本章中, 我们将尝试通过探索两种新算法来平衡局面, 即 Aldous-Broder 算法和 Wilson 算法, 这两种算法都保证是*绝对无偏倚*的.

如果这听起来好得令人难以置信, 那是因为它确实如此! 天下没有免费的午餐, 所以我们也会看到这两种算法——尽管它们在数学上完美无瑕——最终还是有它们自己的缺点.

不过, 要达到那个目的, 我们需要更好地理解偏倚到底是什么, 以及一个算法存在偏倚意味着什么. 让我们先退一步, 从另一个角度审视偏倚, 这样我们就能更精确地看到它们不存在的真正含义.

** 理解偏倚
Understanding Biases

说“这个算法有偏倚”和“那个算法没有偏倚”很容易, 但到目前为止我们还没有非常具体地说明我们的意思. 这不仅仅是简单地识别出迷宫中的长通道或斜向趋势. 一个迷宫中可见的纹理或模式——在算法的输出中——只有在由该算法生成的大量迷宫都表现出相同纹理时, 才能作为算法偏倚的证据.

但即使是那个定义也不完全涵盖它. 与 Sidewinder 和二叉树不同, 偏倚可能不总是那么明显. 它们甚至可能根本不产生可见的痕迹. 为了理解这是怎么回事, 让我们来看一个例子.

#+BEGIN_QUOTE
Joe 提问:
迷宫本身难道不能有偏倚吗?
Can’t Mazes Have Biases, Too?

Walter Pullen 在他的“迷宫分类”页面上,ª 使用“偏倚 (bias)”这个术语来描述涉及通道方向的一类特定纹理. 例如, 具有水平偏倚的迷宫会有更长的东西向通道. 所以, 是的, 在某些上下文中, 偏倚这个词既可以应用于迷宫, 也可以应用于算法.

然而, 为了避免混淆, 在本书中“偏倚”将严格指代算法, 而更通用的术语*纹理* (texture) 将用于描述迷宫. 也就是说, 算法的*偏倚*可能会在迷宫中产生一种*纹理*.

a. http://www.astrolog.org/labyrnth/algrithm.htm
#+END_QUOTE

假设我们想生成一个完美的 2×2 迷宫. (回想一下, 这里的“完美”意味着没有回路.) 下图显示了所有四种可能可以容纳在 2×2 网格中的完美迷宫. 通过随机生成一个 2×2 迷宫, 我们实际上是在这四种可能性之间进行选择.

#+CAPTION: 所有四种可能的 2x2 完美迷宫, 分别标记为 A, B, C, D.

这意味着, 从概念上讲, 随机生成一个迷宫就等同于将所有可能的迷宫放进一个大袋子里, 好好摇一摇 (你知道的——确保它们被充分打乱), 然后伸手到那个袋子里盲目地拿出一个.

二叉树算法是做到这一点的一种方法. 它让我们能够有效地伸手到那个装满所有可能迷宫的大袋子里随机挑选一个, 但它这样做是*带有偏倚*的. 就我们的大袋子迷宫而言, 这意味着该算法实际上并不是在所有可能性中均匀选择的. 它作弊了.

再考虑一下前面图中的四个完美迷宫. 理想情况下, 我们希望二叉树算法能够生成所有这些迷宫, 但它不能. (或者说不愿意!) 回想一下我们所知道的它的偏倚, 即它总是在北部和东部留下未断开的通道. 我们马上就看到 C 是不可能的, 因为东部通道被一堵墙分成了两半. 二叉树算法永远不会给我们那个. D 同样是不可能的——北部的那条通道也被一堵墙分割了. 换句话说, 二叉树算法断然拒绝给我们除了 A 和 B 以外的任何东西, 即 50% 的可能的 2×2 迷宫. 它对那些其他可能性存在*偏倚*.

那 Sidewinder 呢? 当我们回想起 Sidewinder 总是生成带有未断开的北部通道的迷宫时, 我们立即看到 D 是不可能的, 因为北部有那堵墙. 这就给了我们 A, B, 和 C, 或者说 75% 的可能的 2×2 迷宫, 这更好. 但仍然——我们想要的是一个能从*所有*这些中选择的算法!

只要我们在提要求, 我们不妨补充说我们希望*均匀地* (uniformly) 挑选它们. 也就是说, 我们想确保袋子里的每个迷宫都有相同的被选中机会. 一些算法是*非均匀的* (nonuniform), 这意味着它们最终可能会给我们每个可能的迷宫, 但倾向于更频繁地产生某些类型 (例如, 偏好更长的通道). 这些可能是微妙的偏倚, 难以或不可能用肉眼发现, 但我们也不想要那种.

简单地说, 我们想看看当我们从所有可能的迷宫集合中*均匀且随机地*选择我们的迷宫时会发生什么. 好消息是, 有办法做到这一点, 而且它们非常直接, 但是, 像所有事情一样, 都有权衡.

一种方法叫做 Aldous-Broder 算法. 让我们从那里开始.

** Aldous-Broder 算法
The Aldous-Broder Algorithm

Aldous-Broder 算法由加州大学伯克利分校的教授 David Aldous 和目前在谷歌担任杰出科学家的 Andrei Broder 独立开发. 它几乎和二叉树算法一样容易实现. 想法就是这样: 从网格中任何你想要的地方开始, 然后选择一个随机的邻居. 移动到那个邻居, 如果它之前没有被访问过, 就把它和前一个单元格连接起来. 重复直到每个单元格都被访问过.

简单, 对吧? 正是那种随机行走 (random walk), 从一个单元格到另一个单元格漫无目的、毫无方向的 meandering, 是这个算法能够避免偏倚的根本原因. 遗憾的是, 正如我们将看到的, 这也意味着它可能需要很长时间才能运行.

让我们一起来走一遍, 看看它在实践中是如何运作的. 我们将从随机挑选一个单元格开始. 我们将用灰色表示未访问过的单元格, 而我们的老朋友笑脸将指示当前是哪个单元格.

#+CAPTION: 一个 4x4 网格, 中间有一个标记为当前单元格的单元格.

我们需要挑选一个随机的邻居, 所以让我们选择东边. 那个邻居还没有被访问过, 所以我们将这两个单元格连接在一起, 然后我们从那个新的单元格, 一个新的、未访问过的单元格, 重新开始这个过程. 下图连续展示了三步, 每一步都带我们到一个新的、未访问过的单元格.

#+CAPTION: Aldous-Broder 算法的前三步, 每次都移动到一个新的未访问过的单元格并开辟通道.

不过, 看看下一步. 我们选择一个随机的邻居, 这次是向北走, 但那个单元格已经被访问过了. 没关系! 算法就是这样工作的. 唯一的区别是, 这一次, 我们不链接这两个单元格. 我们只是让邻居成为当前单元格, 然后继续.

#+CAPTION: 算法移动到一个已经访问过的单元格, 不开辟通道.

这个过程一直持续到每个单元格都被访问过, 对于大的迷宫来说, 这可能需要一段时间. 请你自己完成这个迷宫. 假设你是随机挑选邻居的, 你会看到随机行走会倾向于 meandering, 多次访问和重访一些单元格. 当你只剩下一两个未访问的单元格时, 看着算法茫然地走过它们, 可能会让你非常恼火!

那么, 试试看. 当你完成时, 你应该会得到类似这样的东西.

#+CAPTION: 一个完成的 4x4 Aldous-Broder 迷宫.

不错! 要到达最后几个未访问的单元格确实需要一些时间, 但过程本身几乎不能再简单了.

接下来让我们看看如何用代码实现它.

** 实现 Aldous-Broder 算法
Implementing Aldous-Broder

正如所料, 随机行走构成了我们实现的核心, 重复访问相邻的单元格, 直到没有未访问的单元格剩下. 它像描述的那样组合在一起, 没有任何意外.

将以下代码放入一个名为 `aldous_broder.rb` 的文件中. 和以前一样, 我们将把算法放在它自己的类中, 这样我们就可以更容易地重用它.

#+BEGIN_SRC ruby
aldous_broder.rb
class AldousBroder
  def self.on(grid)
    cell = grid.random_cell
    unvisited = grid.size - 1

    while unvisited > 0
      neighbor = cell.neighbors.sample

      if neighbor.links.empty?
        cell.link(neighbor)
        unvisited -= 1
      end

      cell = neighbor
    end

    grid
  end
end
#+END_SRC

第 4 行通过随机选择一个单元格来开始一切. 随机行走将从那个单元格开始. 为了确保算法知道什么时候所有单元格都被访问过, 第 5 行计算了网格中未访问单元格的数量. (我们减去一, 因为我们把起始单元格当作已经被访问过了.) 每当访问一个新单元格时, 该值将递减 (第 12 行), 循环将继续直到该值为零 (第 7 行).

在每次循环中, 我们随机选择当前单元格的一个邻居 (第 8 行), 并使其成为新的当前单元格 (第 15 行). 如果那个单元格还没有链接到任何其他单元格 (这意味着它还没有被访问过), 我们在绕圈之前将它链接到当前单元格 (第 11 行).

一个简单的演示程序就足以测试这个. 将以下内容放入 `aldous_broder_demo.rb`.

#+BEGIN_SRC ruby
aldous_broder_demo.rb
require 'grid'
require 'aldous_broder'

grid = Grid.new(20, 20)
AldousBroder.on(grid)

filename = "aldous_broder.png"
grid.to_png.save(filename)
puts "saved to #{filename}"
#+END_SRC

如果你愿意, 也可以用终端显示迷宫; 这段代码只是将迷宫写入 PNG, 这样我们就可以把它做得更大, 以便更好地看到完成的迷宫的结构. 运行它会将迷宫保存到一个文件, 像这样:

#+BEGIN_SRC sh
$ ruby -I. aldous_broder_demo.rb
saved to aldous_broder.png
$
#+END_SRC

打开 `aldous_broder.png`, 我们应该会看到类似下图的东西.

#+CAPTION: 一个 20x20 的 Aldous-Broder 迷宫.

非常漂亮. 让我们再进一步, 看看这个算法是否会产生任何其迷宫都共有的纹理. 使用我们上一章的 `coloring.rb` 程序作为模板, 让我们修改 `aldous_broder.rb` 来输出一个着色版本的迷宫. 事实上, 让我们让它一次生成和着色几个迷宫, 这样我们就可以把它们都并排打开进行比较. 将以下代码放入 `aldous_broder_colored.rb`.

#+BEGIN_SRC ruby
aldous_broder_colored.rb
require 'colored_grid'
require 'aldous_broder'

6.times do |n|
  grid = ColoredGrid.new(20, 20)
  AldousBroder.on(grid)

  middle = grid[grid.rows / 2, grid.columns / 2]
  grid.distances = middle.distances

  filename = "aldous_broder_%02d.png" % n
  grid.to_png.save(filename)
  puts "saved to #{filename}"
end
#+END_SRC

当我们运行它时, 它将生成六个不同的图像.

#+BEGIN_SRC sh
$ ruby -I. aldous_broder_colored.rb
saved to aldous_broder_00.png
saved to aldous_broder_01.png
saved to aldous_broder_02.png
saved to aldous_broder_03.png
saved to aldous_broder_04.png
saved to aldous_broder_05.png
#+END_SRC

如果我们现在看那些图像, 我们应该会看到类似这样的东西.

#+CAPTION: 六个随机生成的、着色的 Aldous-Broder 迷宫.

请记住, 一般来说, 我们看到的任何纹理只有在由该算法生成的*每个*迷宫都具有该纹理时, 才能作为偏倚的证据. 看着这个分布, 你可能会看到一些看起来想要垂直延伸的, 还有几个似乎在中间有一座水平的桥梁, 但没有任何它们都似乎共享的特征. 这绝对支持了 Aldous-Broder 没有偏倚的说法!

尽管它如此引人注目, 但它并没有掩盖纯粹随机行走的最大缺点. Aldous-Broder 的世界并非一片光明. 算法的每一步可能执行得很快, 但算法本身可能会运行很长时间, 特别是在大的迷宫上. 在先前访问过的单元格上漫无目的地 meandering 感觉非常浪费, 但我们不能添加启发式方法 (heuristic), 或一种赋予过程一些智能的方式, 而不剥夺我们所说的我们想要的均匀性属性.

所以, 我们不能改变 Aldous-Broder 本身, 但也许我们可以尝试一个不同的算法. 让我们看看 Wilson 算法是否做得更好.

** Wilson 算法
Wilson’s Algorithm

Wilson 算法由微软的首席研究员、华盛顿大学的附属副教授 David Bruce Wilson 开发. 像 Aldous-Broder 算法一样, 这个算法也依赖于随机行走的概念, 但带有一点转折. 它执行的是所谓的 `loop-erased` 随机行走, 这意味着在它进行的过程中, 如果它正在形成的路径碰巧与自身相交并形成一个循环, 它会在继续之前*擦除*那个循环.

该算法首先在网格上选择一个点——任何点——并将其标记为已访问. 然后它在网格中选择任何一个未访问的单元格, 并进行这些 `loop-erased` 随机行走之一, 直到它遇到一个已访问的单元格. 在那一点上, 它将它所遵循的路径添加到迷宫中, 将该路径上的每个单元格都标记为已访问, 然后再来一次. 这个过程重复进行, 直到网格中的所有单元格都被访问过.

这真是一大堆话! 让我们一起来走一遍, 选择某个随机的单元格开始并将其标记为已访问. 在这里, 西北角已被标记.

#+CAPTION: 一个 4x4 网格, 西北角被标记为已访问.

接下来, 我们随机选择另一个单元格. 我们在这里的选择由笑脸表示. 我们将称之为当前单元格, 它将是我们开始 `loop-erased` 随机行走的地方. 注意, 我们*不*认为这个单元格被访问过!

#+CAPTION: 算法从另一个随机单元格开始随机行走.

从这里开始, 我们选择一个随机的邻居, 并使那个邻居成为当前单元格, 重复进行. 下图显示了我们经过四次这样的移动后的路径. 小心: 我们在这里实际上不是在*开辟通道*, 或者修改网格. 我们只是在记录我们正在走的路径.

#+CAPTION: 随机行走四步后的路径.

现在, 这就是“循环擦除 (loop-erased)”部分发挥作用的地方. 在下图中, 我们 (随机地) 决定向东移动, 这导致我们与我们当前的路径相交. 这创建了一个循环, 所以我们在继续移动之前擦除那个循环.

#+CAPTION: 当随机行走与自身相交时, 循环被擦除.

我们以这种方式继续, 直到我们偶然发现一个已经被访问过的单元格. 第一次通过时, 这意味着我们必须找到那个开始时被访问过的单元格, 我们在这堆单元格中的那根针. 这可能需要一段时间, 但最终它会找到它. 我们的路径可能看起来像这样.

#+CAPTION: 随机行走最终到达一个已访问的单元格.

一旦我们有了那条路径, 我们就通过链接那条路径上的所有单元格并标记它们为已访问, 将它开辟到迷宫中.

#+CAPTION: 路径被雕刻到迷宫中.

然后我们再做一遍: 从网格中挑选一个随机的、未访问的单元格, 执行一个 `loop-erased` 随机行走, 直到我们碰到一个已访问的单元格, 然后将得到的路径开辟到迷宫中, 像这样.

#+CAPTION: 算法重复: 另一次 loop-erased 随机行走被雕刻到迷宫中.

这个过程重复进行, 直到网格中不再有未访问的单元格. 请你自己完成这个迷宫. 当你完成时, 你应该会得到类似下面的东西.

#+CAPTION: 一个完成的 4x4 Wilson 算法迷宫.

又一次, 不错. 我们可以看到 Wilson 算法消除了过程结束时漫无目的的 wandering, 因为问题被颠倒了: 我们不是在寻找*未访问的*单元格 (开始时很多, 结束时很少), 我们在寻找*已访问的*单元格 (开始时很少, 结束时很普遍). 遗憾的是, 这也意味着它有与 Aldous-Broder 相反的问题. Aldous-Broder 开始得快, 但要到达最后几个单元格却越来越慢, 而 Wilson 开始得慢, 试图在最开始就在干草堆里找那根针. 尽管如此, 像 Aldous-Broder 一样, 这个算法没有偏倚, 也许这足以证明这个代价是值得的.

让我们接下来看看如何用代码实现它.

** 实现 Wilson 算法
Implementing Wilson’s Algorithm

以下代码使用一个数组来跟踪网格中所有未访问的单元格. 除了让我们查询一个单元格是否被访问过, 这还让我们能够快速地选择一个未访问的单元格来开始我们的 `loop-erased` 随机行走.

将以下代码放入一个名为 `wilsons.rb` 的文件中.

#+BEGIN_SRC ruby
wilsons.rb
class Wilsons
  def self.on(grid)
    unvisited = []
    grid.each_cell { |cell| unvisited << cell }

    first = unvisited.sample
    unvisited.delete(first)

    while unvisited.any?
      cell = unvisited.sample
      path = [cell]

      while unvisited.include?(cell)
        cell = cell.neighbors.sample
        position = path.index(cell)
        if position
          path = path[0..position]
        else
          path << cell
        end
      end

      0.upto(path.length-2) do |index|
        path[index].link(path[index + 1])
        unvisited.delete(path[index])
      end
    end

    grid
  end
end
#+END_SRC

这个实现实际上由三个不同的部分组成: 初始化 (第 4-8 行), `loop-erased` 随机行走 (第 11-22 行), 和开辟通道 (第 24-27 行).

在初始化阶段, 我们设置一个空数组 (第 4 行) 来存放所有未访问的单元格. (我们可以像对 Aldous-Broder 那样只保留一个计数器, 但像这样使用数组使得随机选择未访问的单元格更容易, 这是我们随机行走阶段所需要的.) 我们通过随机选择一个未访问的单元格 (第 7 行) 并通过从列表中移除它来标记它为已访问来完成初始化. 这将是我们的第一个目标单元格, 我们的随机行走将尝试找到它.

接下来的两个阶段, 即 `loop-erased` 随机行走和通道开辟, 只要我们的未访问列表包含任何单元格 (在第 10 行测试), 就会重复进行.

随机行走开始于随机选择一个未访问的单元格 (第 11 行) 并将其添加到我们预期的路径中. 这条路径最终将通向网格中已访问的单元格之一, 所以我们一直走, 直到这种情况发生 (第 14 行). 每次我们在这条路上走一步, 我们选择当前单元格的一个邻居 (第 15 行), 然后检查我们是否创建了一个循环 (第 16 行). 如果我们创建了一个循环, 那个单元格将已经存在于我们的路径中, 所有在它之后的单元格构成了循环, 所以我们通过在该单元格之后截断路径来移除循环 (第 18 行). 否则, 如果单元格没有形成循环, 我们将它附加到路径并继续 (第 20 行).

一旦随机行走找到一个已访问的单元格, 那个阶段就结束了, 我们移动到通道开辟阶段 (第 24 行). 我们迭代路径的每个单元格, 将它链接到它的邻居 (第 25 行), 然后通过从我们的未访问数组中移除它来标记它为已访问 (第 26 行).

通过创建一个新程序 `wilsons_demo.rb` 来测试这个.

#+BEGIN_SRC ruby
wilsons_demo.rb
require 'grid'
require 'wilsons'

grid = Grid.new(20, 20)
Wilsons.on(grid)

filename = "wilsons.png"
grid.to_png.save(filename)
puts "saved to #{filename}"
#+END_SRC

像往常一样运行它, 并打开生成的 `wilsons.png` 图像. 它应该看起来很像我们在 Aldous-Broder 图, 第 58 页看到的东西. 如果这两种算法真的没有偏倚, 我们会期望这样.

事实上, 你甚至可能想做像我们对 Aldous-Broder 算法做的那样, 使用我们的 `ColoredGrid` 类来为几个迷宫着色, 以进行比较. 你应该会发现与 Aldous-Broder 相同的多样性——证明 Wilson 算法确实是无偏倚的.

** 轮到你了
Your Turn

我们现在已经掌握了四种迷宫生成算法. 其中两种, 二叉树和 Sidewinder, 偏倚严重但实现简单, 运行速度非常快. 另外两种, Aldous-Broder 和 Wilson, 是完全无偏倚的, 但生成一个迷宫可能需要更长的时间. 甚至在 Aldous-Broder 和 Wilson 之间, 我们可以选择要么启动慢要么完成慢. 这么多选择!

所有这些选择意味着我们可以开始尝试一些新的想法. 我们有更多的选择来进行实验. 试试下面的建议, 或者用你自己的想法进行实验.

*** 二合一
Two-in-One

尝试用*两种*算法生成*一个*迷宫. 与其用单个单元格开始 Wilson 算法, 如果你用 Aldous-Broder 开始, 然后在它访问了网格的某个部分后切换到 Wilson 呢? 或者如果你用二叉树做网格的上半部分, 用 Aldous-Broder 做剩下的部分呢? 不过要小心; 不是所有的组合都能工作. 你能弄清楚为什么有些可以, 有些不可以吗?

*** 给无偏倚的算法加上偏倚
Biasing the Unbiased

我们通常选择 Aldous-Broder 或 Wilson 算法, 特别是因为它们是无偏倚的. 但如果你故意给它们加上偏倚会怎么样? 你要如何拿其中一个, 调整它的随机行走, 使它倾向于水平移动而不是垂直移动, 或者偏好右转而不是左转? 你还能想到什么其他方法来给那些算法引入偏倚?

*** 另一种行走方式
Another Way to Walk

对 Aldous-Broder 或 Wilson 行走路径方式的任何改变都会引入偏倚. 如果你让 Aldous-Broder 有避开先前访问过的单元格的倾向, 你会得到什么样的偏倚? 或者如果 Wilson 的 `loop-erased` 随机行走从一开始就拒绝形成循环呢?

特别是最后一个实验, 巧妙地引导我们进入下一章, 在那里我们将看到当我们给随机行走添加规则时会发生什么. 正如你所料, 它会导致偏倚, 但我们会看到并非所有的偏倚都是不可取的.

* 第 5 章：给随机行走添加约束
*Adding Constraints to Random Walks*

如果你绝对需要一个完全无偏倚的算法, 那么漫无目的的随机行走可能是一个好策略, 但在大多数情况下, 这有点小题大做. 一个带有恰当偏倚的算法通常能生成具有氛围、个性甚至挑战性的迷宫, 这是无偏倚算法无法做到的. 偏倚并不自动就是坏事!

在本章中, 我们将验证这一论点. 我们将研究两种相当相似的算法, 它们表面上看起来很像 Aldous-Broder 或 Wilson 算法, 但通过给它们的随机行走添加约束来引入偏倚. 这就是名字听起来不祥的 Hunt-and-Kill (猎杀) 算法和 Recursive Backtracker (递归回溯) 算法.

** Hunt-and-Kill 算法
The Hunt-and-Kill Algorithm

Hunt-and-Kill (猎杀) 算法起初看起来会与 Aldous-Broder 算法非常相似. 我们任意选择一个单元格开始, 然后从那里进行随机行走. 不同之处在于, Aldous-Broder 允许你踏上任何地方, 即使是你已经访问过的单元格, 而 Hunt-and-Kill 要求你只在未访问过的单元格上行走.

让我们来过一遍.

因为我们可以从任何地方开始, 我们就选择西南角.

#+CAPTION: 一个 4x4 网格, 西南角被标记为起点.

从那里, 我们进行一次随机行走, 避开任何我们已经访问过的单元格. 这是故意的! 记住, 算法本身不允许在随机行走期间重访单元格.

不过没关系. 这很顺利...直到我们把自己画进一个角落的那一刻, 如图所示. 我们最终到达了一个被已访问单元格包围的单元格, 因为我们不被允许走在那些上面, 所以我们被困住了.

#+CAPTION: 随机行走被困住, 因为所有相邻的单元格都已被访问过.

这就是我们进入猎杀模式 (hunt mode) 的地方. 从顶部开始, 我们从左到右扫描, 直到我们遇到一个未访问过的单元格, 它至少与一个已访问过的单元格相邻. 当我们找到它时, 将它设为我们的当前单元格, 并将其链接到它的任何一个已访问过的邻居单元格. 在图中, 我们选择了我们遇到的第一个符合条件的单元格. 由于它只有一个已访问的邻居 (紧邻南边的那个单元格), 我们只需将两者链接在一起; 如果有两个或更多, 我们会随机选择一个.

#+CAPTION: Hunt-and-Kill 算法进入“猎杀”模式, 找到一个新的起点并继续行走.

我们再次进行随机行走, 尽可能地走远.

#+CAPTION: 随机行走再次继续, 直到被困住.

然后, 再一次, 我们从西北角开始逐行扫描, 寻找另一个至少有一个已访问邻居的未访问单元格, 然后从那里开辟另一条随机行走路径.

#+CAPTION: 算法再次进入“猎杀”模式以寻找新的起点.

这个过程重复进行, 直到猎杀阶段再也找不到任何未访问的单元格, 那时我们就知道迷宫完成了.

#+CAPTION: 一个完成的 Hunt-and-Kill 迷宫.

小菜一碟. 现在让我们把它写成代码.

** 实现 Hunt-and-Kill 算法
Implementing Hunt-and-Kill

这里的实现真的没有什么意外. 如你所料, 我们从随机选择一个单元格开始, 然后进行我们的随机行走. 在那方面, 它看起来很像我们实现的 Aldous-Broder 算法. 然而, 当我们发现自己被困住, 没有更多未访问的邻居单元格时, 相似之处就结束了. 那会触发猎杀阶段, 我们将遍历网格, 寻找带有已访问邻居的未访问单元格.

将以下内容放入 `hunt_and_kill.rb`.

#+BEGIN_SRC ruby
hunt_and_kill.rb
class HuntAndKill
  def self.on(grid)
    current = grid.random_cell

    while current
      unvisited_neighbors = current.neighbors.select { |n| n.links.empty? }

      if unvisited_neighbors.any?
        neighbor = unvisited_neighbors.sample
        current.link(neighbor)
        current = neighbor
      else
        current = nil

        grid.each_cell do |cell|
          visited_neighbors = cell.neighbors.select { |n| n.links.any? }
          if cell.links.empty? && visited_neighbors.any?
            current = cell

            neighbor = visited_neighbors.sample
            current.link(neighbor)

            break
          end
        end
      end
    end

    grid
  end
end
#+END_SRC

代码有两部分, 对应于算法的两个阶段: 随机行走 (第 5-11 行) 和猎杀阶段 (第 12-25 行). 只要存在 `current` 单元格 (第 5 行), 这两个阶段就会交替进行, `current` 单元格在开始时通过从网格中随机选择一个来初始化 (第 3 行).

在每次通过算法时, 我们列出当前单元格的所有未访问过的邻居 (第 6 行). 如果有任何这样的邻居, 我们随机选择一个 (第 9 行), 将它链接到当前单元格 (第 10 行), 然后让它成为当前单元格 (第 11 行).

如果当前单元格没有未访问过的邻居, 我们就切换到猎杀阶段 (第 12 行). 因为在这个阶段没有当前单元格, 第 13 行在继续之前将 `current` 设置为 `nil`. 这有助于我们知道算法何时准备终止, 因为循环 (第 5 行) 依赖于那个变量.

`current` 被重置后, 我们现在开始查看网格中的每个单元格 (第 15 行), 寻找一个有希望的单元格来开始行走. 第 17 行规定了我们要求的标准: 一个未访问过的单元格 (`links.empty?`) 至少有一个已访问过的邻居. 一旦我们找到一个符合标准的, 它就成为当前单元格 (第 18 行), 我们将它随机链接到它的一个已访问过的邻居 (第 20 和 21 行), 然后我们跳出猎杀模式 (第 23 行), 准备开始另一次随机行走.

不错! 让我们用 `hunt_and_kill_demo.rb` 来测试一下.

#+BEGIN_SRC ruby
hunt_and_kill_demo.rb
require 'grid'
require 'hunt_and_kill'

grid = Grid.new(20, 20)
HuntAndKill.on(grid)

filename = "hunt_and_kill.png"
grid.to_png.save(filename)
puts "saved to #{filename}"
#+END_SRC

运行它会将我们的迷宫渲染到 `hunt_and_kill.png`. 打开它, 你应该会看到类似图中的东西.

#+CAPTION: 一个 20x20 的 Hunt-and-Kill 迷宫.

追踪任何一条通道, 我们很快就会发现路径倾向于相当曲折.

如果我们尝试给它上色, 使用我们之前章节中的 `ColoredGrid` 类, 我们可以更清楚地看到这一点. 去试试看. 你应该会看到类似下面的东西.

#+CAPTION: 一个着色的 Hunt-and-Kill 迷宫.

当然, 美感在观者眼中, 但这些通道蜿蜒的方式确实有种可爱之处! 正如你可能已经猜到的, 那种纹理是这个算法偏倚的证据之一 (而且, 取决于你对迷宫的品味, 可能会被当作并非所有偏倚都是坏事的证明). 这种风格的迷宫的另一个显著特征是, 它们比其他算法生成的迷宫相对有更少的死胡同.

** 计算死胡同
Counting Dead Ends

让我们展示一下不同算法之间死胡同的频率如何比较. 我们将向我们的 `Grid` 类添加一个方法, 它将收集整个网格中所有的死胡同单元格——那些只与一个其他单元格有链接的单元格——并以列表形式返回它们. 然后我们可以打印该列表的大小, 告诉我们有多少个死胡同. (我们以后也能用这个, 当我们开始谈论第 9 章, *编织和交织你的迷宫*, 第 129 页中的辫状迷宫时.)

打开 `grid.rb` 并在该文件中最后一个 `end` 关键字之前放入这个.

#+BEGIN_SRC ruby
grid.rb
def deadends
  list = []

  each_cell do |cell|
    list << cell if cell.links.count == 1
  end

  list
end
#+END_SRC

一旦你做了那个更改, 选择你之前的一个程序 (例如, `binary_tree_demo.rb` 或 `wilsons.rb`) 并在末尾添加一行类似下面的内容.

#+BEGIN_SRC ruby
deadends = grid.deadends
puts "#{deadends.count} dead-ends"
#+END_SRC

这应该每次生成迷宫时都打印出死胡同的数量. 我们可以对我们到目前为止编写的所有程序都这样做, 每个都运行几十次, 然后尝试对我们得到的数字进行一些分析, 但那会相当乏味. 让我们科学地处理这个问题.

这是一个程序, 它将运行我们到目前为止涵盖的每个算法, 累积每次运行的死胡同数量, 然后显示一个平均值的报告. 把它放在 `deadend_counts.rb` 中.

#+BEGIN_SRC ruby
deadend_counts.rb
require 'grid'
require 'binary_tree'
require 'sidewinder'
require 'aldous_broder'
require 'wilsons'
require 'hunt_and_kill'

algorithms = [BinaryTree, Sidewinder, AldousBroder, Wilsons, HuntAndKill]

tries = 100
size = 20

averages = {}
algorithms.each do |algorithm|
  puts "running #{algorithm}..."

  deadend_counts = []
  tries.times do
    grid = Grid.new(size, size)
    algorithm.on(grid)
    deadend_counts << grid.deadends.count
  end

  total_deadends = deadend_counts.inject(0) { |s,a| s + a }
  averages[algorithm] = total_deadends / deadend_counts.length
end

total_cells = size * size
puts
puts "Average dead-ends per #{size}x#{size} maze (#{total_cells} cells):"
puts

sorted_algorithms = algorithms.sort_by { |algorithm| -averages[algorithm] }

sorted_algorithms.each do |algorithm|
  percentage = averages[algorithm] * 100.0 / (size * size)
  puts "%14s : %3d/%d (%d%%)" %
    [algorithm, averages[algorithm], total_cells, percentage]
end
#+END_SRC

把我们的算法放在它们自己的类中在这里真的派上了用场! 我们只需加载那些类中的每一个, 并将它们放入一个数组中 (第 8 行). 第 10 行和第 11 行配置每个算法将被尝试的次数和每个迷宫的大小.

然后我们遍历每个算法, 每个重复 `tries` 次, 方法是实例化一个网格 (第 19 行), 对其应用算法 (第 20 行), 然后将死胡同的数量累积到一个列表中 (第 21 行). 一旦算法运行了 `tries` 次, 死胡同计数就被汇总和平均 (第 24-25 行).

程序的其余部分对结果进行排序和显示.

运行它应该会给我们一些相当有趣的统计数据:

#+BEGIN_SRC text
$ ruby -I. deadend_counts.rb
running BinaryTree...
running Sidewinder...
running AldousBroder...
running Wilsons...
running HuntAndKill...

Average dead-ends per 20x20 maze (400 cells):

  AldousBroder : 115/400 (28%)
       Wilsons : 115/400 (28%)
    Sidewinder : 109/400 (27%)
    BinaryTree : 101/400 (25%)
   HuntAndKill :  40/400 (10%)
#+END_SRC

Hunt-and-Kill 算法怎么样, 嗯? 平均而言, 它生成的迷宫中只有 10% 的单元格会是死胡同. 它本质上是用死胡同换取通道长度, 让迷宫产生更多蜿蜒、曲折的走廊. 这个特殊的属性有时被称为 *river*, 而 Hunt-and-Kill 生成的迷宫就有很多! 我个人相当喜欢那种美学. 如果它像我一样吸引你, 你可能也会喜欢 Recursive Backtracker 算法. 它的行为非常相似. 让我们接下来谈谈它.

** 递归回溯算法
The Recursive Backtracker Algorithm

递归回溯 (Recursive Backtracker) 算法的工作方式与 Hunt-and-Kill 非常相似, 依赖于受约束的随机行走来编织其河流般的方式穿过我们的网格. 不同之处在于它如何从死胡同中恢复; 它不是去寻找另一个可行的单元格, 而是*回溯* (backtracks), 追溯其步骤, 直到找到一个有未访问邻居的单元格.

让我们一起来走一遍, 看看它在实践中是如何工作的. 我们将使用一个栈 (stack) 来跟踪我们访问过的单元格. 栈只是一个项目列表, 但有严格的规则关于项目如何被添加或移除. 向栈顶添加东西称为*入栈* (pushing), 移除最顶层的项目称为*出栈* (popping). 栈只能通过这些入栈和出栈操作来操纵, 这意味着它非常擅长强制其内容被访问的顺序. 这恰好是某些算法所需要的, 比如 Recursive Backtracker. 在这里, 我们将在访问单元格时将它们推入栈中, 当我们发现它们是死胡同时将它们弹出.

我们可以像 Hunt-and-Kill 一样从任何地方开始, 所以让我们继续从西南角开始 (我们按其坐标称之为: A4). 我们将把那个单元格推入栈中. 栈顶的任何单元格都将始终被视为当前单元格.

#+CAPTION: 递归回溯算法从一个随机单元格 (A4) 开始, 并将其推入栈中.

看看我们当前单元格的未访问邻居, 我们随机选择一个 (我们选 A3) 并开辟一条通往它的路径, 同时将它推入我们的栈中. 记住, 这使得 A3 成为我们新的当前单元格.

#+CAPTION: 算法移动到一个未访问的邻居 (A3), 并将其推入栈中.

这个过程继续进行, 随机地在网格中行走, 如图所示. 栈将包含我们到目前为止访问过的每个单元格.

#+CAPTION: 随机行走继续, 栈中包含了路径上的所有单元格.

我们的下一个随机步骤将我们带到西边的 B4, 但 B4 没有未访问过的邻居. 我们被困住了!

#+CAPTION: 随机行走被困在 B4.

在这一点上, 我们从栈中弹出那个死胡同单元格, 这使得前一个单元格——C4——再次成为我们的当前单元格.

#+CAPTION: 算法从 B4 回溯到 C4.

这个单元格还有一个未访问过的邻居 (D4), 所以我们通过选择那个来继续我们的随机行走.

#+CAPTION: 随机行走从 C4 继续到 D4.

这个过程以这种方式继续, 在每个死胡同都进行回溯, 直到每个单元格都被访问过.

#+CAPTION: 算法继续, 直到所有单元格都被访问过.

要访问的最后一个单元格将总是一个死胡同, 所以我们再次回溯. 我们追溯我们的步骤, 从栈中弹出单元格, 寻找一个有未访问邻居的单元格. 不过, 在这种情况下, 已经没有更多未访问的单元格了——所有东西都已经被访问过了——所以我们从栈中弹出单元格, 直到我们回到我们开始的地方, A4.

#+CAPTION: 当所有单元格都被访问后, 算法回溯到起点.

因为那个单元格也没有任何未访问的邻居, 我们也把它从栈中弹出, 这使得栈变空了.

#+CAPTION: 最终, 栈变空, 算法终止.

而那, 温柔的读者, 就是你知道算法完成的方式: 栈是空的. 我们完成了, 剩下的是我们的迷宫.

就这样! 让我们接下来在代码中实现这个, 你会看到它和 Hunt-and-Kill 很像.

** 实现递归回溯
Implementing the Recursive Backtracker

我们将或多或少地实现前一节中描述的内容, 使用一个显式的栈来管理已经访问过的单元格. 我们将使用一个数组来表示栈 (这在 Ruby 中很容易, 因为 Ruby 的数组预装了标准的 `push` 和 `pop` 栈操作符). 将以下代码放入 `recursive_backtracker.rb`.

#+BEGIN_SRC ruby
recursive_backtracker.rb
class RecursiveBacktracker
  def self.on(grid, start_at: grid.random_cell)
    stack = []
    stack.push start_at

    while stack.any?
      current = stack.last
      neighbors = current.neighbors.select { |n| n.links.empty? }

      if neighbors.empty?
        stack.pop
      else
        neighbor = neighbors.sample
        current.link(neighbor)
        stack.push(neighbor)
      end
    end

    grid
  end
end
#+END_SRC

一切都从第 4 行和第 5 行开始, 我们在那里将我们的“栈”初始化为一个空数组, 然后将我们的起始位置推入其中. 默认情况下, 那个起始位置是从网格中随机选择的一个单元格, 尽管它可以通过 `start_at` 参数传递一个不同的单元格来配置. 只要栈中有任何项目 (第 7 行), 算法就会继续.

因为栈顶的单元格总是当前单元格, 我们在第 8 行明确了这一点. 然后, 第 9 行将当前单元格的所有未访问邻居收集到一个数组中. (记住: 如果一个单元格与任何其他单元格有任何链接, 我们就知道它已经被访问过了.)

如果该单元格没有未访问过的邻居, 我们就从栈中移除那个单元格 (第 12 行). 这实际上是在回溯, 因为它使栈中的前一个单元格成为当前节点.

另一方面, 如果该单元格*确实*有未访问过的邻居, 我们就随机选择一个 (第 14 行), 将它链接到当前单元格 (第 15 行), 然后将它推入栈中 (第 16 行), 隐式地使其成为新的当前单元格.

一旦你准备好了, 就为 Recursive Backtracker 创建一个测试程序:

#+BEGIN_SRC ruby
recursive_backtracker_demo.rb
require 'recursive_backtracker'
require 'grid'

grid = Grid.new(20, 20)
RecursiveBacktracker.on(grid)

filename = "recursive_backtracker.png"
grid.to_png.save(filename)
puts "saved to #{filename}"
#+END_SRC

运行它, 你应该会得到一个看起来非常像你的 Hunt-and-Kill 迷宫的东西, 充满了曲折、蜿蜒的走廊和很少的死胡同——事实上, 就像下面的这个.

#+CAPTION: 一个 20x20 的 Recursive Backtracker 迷宫.

考虑到这两种算法产生如此相似的结果, 可能很难在它们之间做出选择, 但你可以考虑两点来帮助你做出选择.

第一是*内存效率*. Recursive Backtracker 必须维护一个栈, 它可能 (最坏情况下) 包含网格中的每个单元格. 这表明 Recursive Backtracker 可能需要比 Hunt-and-Kill 多达两倍的内存, 因为 Hunt-and-Kill 只需要网格本身就足够了.

第二是*速度*. Hunt-and-Kill 将至少访问每个单元格两次——一次是在执行其随机行走时, 一次是在猎杀阶段. 最坏的情况甚至更糟, 因为如果猎杀阶段被执行多次, 一些单元格可能会被一次又一次地访问. 与之相比, Recursive Backtracker 保证每个单元格*恰好*被访问两次 (一次是在开辟时, 一次是在回溯时), 你可以看到 Recursive Backtracker 通常会更快.

内存或速度. 做出你的选择! 任何一个都会给你一个有很多*河流*——曲折、蜿蜒的通道——的迷宫, 这有一天可能正是你需要的纹理.

** 轮到你了
Your Turn

所以我们看到这是真的: 并非所有的偏倚都是坏的! 通过在随机行走期间约束单元格的选择——例如, 禁止那些已经被访问过的——我们可以产生一个偏向于更多河流的迷宫. 我们看到了 Hunt-and-Kill 和 Recursive Backtracker 都是如何利用这种技术来达到良好效果的.

又一次, 是时候玩玩你所获得的了. 你还能给随机行走添加什么其他约束? 如果你以某种方式改变现有的约束呢? 下面的想法可能会帮助你开始.

*** 猎杀策略
Hunting Strategies

我们研究了一种在 Hunt-and-Kill 算法的猎杀阶段寻找单元格的策略: 简单地按顺序查看单元格, 直到找到一个. 你还能想到什么其他方法来猎杀单元格? 它们各自会引入什么样的偏倚, 如果有的话?

*** 添加偏倚
Adding Biases

二叉树想要倾斜, Sidewinder 想要垂直到达. 你能调整 Hunt-and-Kill 或 Recursive Backtracker 来产生类似的偏倚吗? 你能用那些算法生成一个通道倾向于水平延伸的迷宫吗?

*** 分析死胡同
Analyzing Dead Ends

我们实现了 `deadends` 方法来帮助计算一个迷宫中死胡同的数量, 但还有其他方法可以将其可视化. 如果你根据每个单元格链接的单元格数量来为单元格着色呢? 也就是说, 一个只链接到一个其他单元格的单元格可能是深灰色, 而一个链接到所有四个邻居的单元格可能是红色. 你还能想到什么其他方法来可视化一个迷宫中的死胡同和连接?

*** 统计分析
Statistical Analysis

我们通过一个简短的程序计算了我们到目前为止所见过的每种算法的平均死胡同数量. 你还能用它挖掘出什么其他的统计数据? 你可能会在水平通道与垂直通道的比例中寻找模式, 或者比较四向交叉口的数量与死胡同的数量.

*** 使用递归回溯算法解决迷宫
Solving Mazes with the Recursive Backtracker

Recursive Backtracker 的另一个名字是*深度优先搜索* (depth-first search). 这是一种遍历图的策略 (这暗示了迷宫和图之间的联系, 不是吗?). 它实际上在寻找迷宫的解法方面和在生成迷宫方面一样有效. 试试看: 与其通过一个空网格随机开辟通道, 不如拿一个现有的迷宫并遵循它的通道. 将新访问的单元格推入栈中, 并在回溯时将它们弹出, 直到你到达目标.

*** 一个递归的递归回溯算法
A Recursive Recursive Backtracker

这里给出的 Recursive Backtracker 的实现使用了一个显式的栈, 但只要稍加思考, 就有可能 (相当简洁地!) 使用一个隐式的栈来重写它. 在大多数编程语言中, 当你调用一个方法或函数时, 当前作用域中的变量被推入一个栈中, 然后在函数返回时弹出以恢复那些变量. 尝试使用真正的*递归*来重新实现 Recursive Backtracker, 用一个每次选择新邻居时都调用自己的函数, 并在当前单元格没有更多未访问邻居时返回.

接下来, 我们将暂停学习新算法, 转而专注于我们可以用我们已有的算法做的事情. 具体来说, 我们将看看我们如何稍微修改我们的网格, 以便在它们的形状上发挥创意

* 第 6 章：将迷宫拟合到形状
*Fitting Mazes to Shapes*

让我们从新的迷宫算法中稍作休息, 尝试感受一下我们工具箱中已有的东西. 到目前为止, 我们对制作矩形迷宫已经相当自在了.

在本章中, 我们将把它提升到一个新的水平, 学习如何制作能适应任意形状的迷宫.

#+CAPTION: 一个矩形迷宫和一个字母形状的迷宫.

诀窍在于一种非常简单的小技巧, 称为掩码 (masking), 它可以约束迷宫以适应任意形状. 它有自己的一些小毛病, 但总的来说, 这是一个非常有用的工具.

我们将从使用掩码来禁止网格的某些区域开始, 导致迷宫算法跳过你定义的那些区域. 然后, 我们将看到如何用它来将迷宫拟合到不同的几何设计中, 并最终使用图像模板将你的迷宫塑造成字母和单词的形状!

但首先, 我们需要谈谈这些掩码到底是什么,以及它们是如何工作的.

** 介绍掩码
Introducing Masking

掩码背后的想法其实很简单. 基本的比喻是, 我们的网格本质上是一个非常低分辨率的图像, 其中每个单元格都像一个像素. 关闭这些像素中的任何一个都会将它们标记为禁区, 所以我们的迷宫算法 (无论我们使用哪一个) 都永远不会尝试走到那里.

在下图中, 东南角的单元格已被关闭. 那么, 生成的迷宫就会完全省略那个单元格.

#+CAPTION: 一个被掩码掉一个单元格的网格, 以及由此产生的迷宫.

从概念上讲, 这就是它的全部内容! 不过, 在实践中, 有一些事情需要考虑, 以及像这样瞎搞我们的网格几何形状会带来一些后果.

** 掩码的后果
Consequences of Masking

并非所有的迷宫算法都能处理掩码可能给网格带来的变化. 考虑下面这个例子, 其中第 3 行第 4 列的单元格已被关闭.

#+CAPTION: 一个被掩码掉一个单元格的网格.

我们可以通过尝试在这里生成一个迷宫来很容易地证明, 二叉树 (Binary Tree) 算法无法在这个网格上生成一个有效的迷宫. 假设我们再次从西南角开始. 记住, 二叉树算法的工作原理是在每个点选择向北或向东. 假设我们做出以下选择序列:

#+CAPTION: 二叉树算法在被掩码的网格上失败的步骤.

我们为第一个单元格选择向北, 为第二个选择向东, 再为第三个选择向北——这就把我们带到了东南角.

看看那个角落的单元格, 我们马上就看到算法不能向北走, 也不能向东走. 它无法将这个单元格连接到它唯一有效的西边邻居——我们实际上已经孤立了它.

你真的无法用二叉树算法在这个网格上制作一个有效的迷宫! 那个算法永远不会创建一个死胡同, 其中唯一的出口是向西或向南——这正是我们在那个东南角所遇到的情况. (如果你不相信我——试试看. 看看你是否能在底行找到一个不会孤立至少一个单元格的选择序列!)

Sidewinder 也有类似的问题. 因为它永远不会创建一个唯一的出口是向南的死胡同, 你可以很容易地通过关闭北行中间的一个单元格, 制造一个朝北的死胡同, 来使其失败.

不过, 好消息是, 我们到目前为止涵盖的任何其他算法 (以及我们将在后续章节中涵盖的许多算法) 都会很好用. 本章中的示例都将使用递归回溯 (Recursive Backtracker) 算法, 但请随意尝试其他的.

那么, 在排除了这些注意事项之后, 我们可以开始研究如何用掩码来操作我们的网格了. 我们将从最简单的方式开始: 通过禁用单元格.

** 禁用单元格
Killing Cells

我们可以用我们已经写好的工具, 尽管有些笨拙地, 来实现掩码. 单元格可以通过让它们的邻居认为该单元格不存在来“关闭”. 我们基本上是在禁用那些单元格.

下面的代码通过在相邻单元格上设置适当的属性为 `nil` 来对西北角和东南角进行此操作. 将它放入一个名为 `killing_cells.rb` 的文件中.

#+BEGIN_SRC ruby
killing_cells.rb
require 'grid'
require 'recursive_backtracker'

grid = Grid.new(5, 5)

# orphan the cell in the northwest corner...
grid.east.west = nil
grid.south.north = nil

# ...and the one in the southeast corner
grid.west.east = nil
grid.north.south = nil

RecursiveBacktracker.on(grid, start_at: grid)

puts grid
#+END_SRC

第 7 行和第 8 行通过隔离西北角的单元格, 将其从其邻居中移除, 来孤立它. 我们通过告诉该单元格东边的邻居它没有西边的邻居, 以及告诉南边的邻居它没有北边的邻居来做到这一点. 我们在第 11 行和第 12 行类似地隔离东南角的单元格.

然后我们在生成的网格上运行递归回溯算法, 从第 1 行第 1 列的单元格开始. (我们不能可靠地让网格在这里选择一个随机的起始单元格, 因为它*可能*会选择我们刚刚孤立的那两个单元格之一...那将无法生成迷宫.) 最后, 我们将生成的迷宫输出到终端. 运行它, 我们会得到类似这样的东西:

#+BEGIN_SRC sh
$ ruby -I. killing_cells.rb
+---+---+---+---+---+
|   |           |   |
+---+---+   +---+   +
|       |   |       |
+   +---+---+   +   +
|   |       |   |   |
+   +   +---+---+   +
|   |   |           |
+   +   +   +   +---+
|   |   |   |       |
+---+---+---+---+---+
#+END_SRC

它成功了! 注意西北角和东南角是如何完全被墙围起来, 与迷宫的其余部分断开连接, 然而迷宫本身却很好. 事实上, 在数学意义上是完美的.

然而, 手动断开每个单元格会很快变得乏味. 我们可以让这变得更容易.

** 实现掩码
Implementing a Mask

让我们创建一个 `Mask` 类, 它将封装我们网格中每个单元格的开/关状态. 也就是说, 对于网格中的每个单元格, 我们的掩码应该能够告诉我们它是否应该被包含在迷宫中. 下面的实现通过保留一个单独的布尔值二维数组来做到这一点, 其中 `false` 意味着相应的单元格“脱离网格”.

创建一个名为 `mask.rb` 的新文件, 并以以下属性和构造函数开始.

#+BEGIN_SRC ruby
mask.rb
class Mask
  attr_reader :rows, :columns

  def initialize(rows, columns)
    @rows, @columns = rows, columns
    @bits = Array.new(@rows) { Array.new(@columns, true) }
  end
#+END_SRC

`initialize` 构造函数非常直接, 只是记录了掩码的维度并创建了一个二维布尔值数组, 指示哪些单元格是开启 (启用) 或关闭 (禁用) 的.

接下来的两个方法查询和修改那个布尔数组.

#+BEGIN_SRC ruby
  def [](row, column)
    if row.between?(0, @rows - 1) && column.between?(0, @columns - 1)
      @bits[row][column]
    else
      false
    end
  end

  def []=(row, column, is_on)
    @bits[row][column] = is_on
  end
#+END_SRC

数组访问器 `[]` 接受一个 (行, 列) 对, 并说明该位置在网格中是否启用. 相应的赋值方法 `[]=` 用于通过将 `is_on` 参数的值记录到该位置的数组中来指示给定位置是启用还是禁用.

下一个方法 `count` 将告诉我们掩码中有多少个位置是启用的. 这对于像 Aldous-Broder 这样的算法很有用, 我们需要知道网格中有多少个单元格.

#+BEGIN_SRC ruby
  def count
    count = 0

    @rows.times do |row|
      @columns.times do |col|
        count += 1 if @bits[row][col]
      end
    end

    count
  end
#+END_SRC

最后一个方法 `random_location` 只是报告一个对应于网格中随机启用位置的 (行, 列) 对. 我们将把它用于像 Hunt-and-Kill 或 Recursive Backtracker 这样的算法, 它们希望从一个随机位置开始.

#+BEGIN_SRC ruby
  def random_location
    loop do
      row = rand(@rows)
      col = rand(@columns)

      return [row, col] if @bits[row][col]
    end
  end
end
#+END_SRC

这就是我们的 `Mask` 类! 不过, 这只是解决方案的一半. 记住, 我们正在努力做到我们不必告诉单个单元格它们的邻居是谁和不是谁. 我们宁愿简单地把一个掩码交给网格, 让它自动设置正确的连接.

为了实现这一点, 我们将子类化我们的 `Grid` 并提供一个新的构造函数, 它接受一个 `Mask` 实例. 新的网格子类然后将使用那个掩码来确定哪些单元格被实例化, 哪些被设置为 `nil`. 事实上, 我们不妨也用掩码来告知网格的大小, 这样我们只需要指定一次维度.

将以下内容放入 `masked_grid.rb`.

#+BEGIN_SRC ruby
masked_grid.rb
require 'grid'

class MaskedGrid < Grid
  attr_reader :mask

  def initialize(mask)
    @mask = mask
    super(@mask.rows, @mask.columns)
  end

  def prepare_grid
    Array.new(rows) do |row|
      Array.new(columns) do |column|
        Cell.new(row, column) if @mask[row, column]
      end
    end
  end

  def random_cell
    row, col = @mask.random_location
    self[row, col]
  end

  def size
    @mask.count
  end
end
#+END_SRC

注意构造函数 `initialize` 不再接受维度. 相反, 第 8 行将掩码的维度传递给超类, 以便我们的网格大小将始终与用于初始化它的掩码相匹配.

这个类改变了另外三个行为: 网格如何准备, 如何找到随机单元格, 以及如何计算网格的大小.

`prepare_grid` 方法与父 `Grid` 类中的版本几乎相同, 但第 14 行现在依赖于掩码来决定是否实例化一个单元格. 如果掩码报告给定位置已启用, 将为其实例化一个单元格. 否则, 该位置将是 `nil`, 超类将简单地绕过它.

最后两个方法很直接, 只是委托给掩码进行必要的计算.

有了这两个类, 我们现在可以简化我们的 `killing_cells.rb` 程序了. 将以下内容放入 `simple_mask.rb`.

#+BEGIN_SRC ruby
simple_mask.rb
require 'mask'
require 'masked_grid'
require 'recursive_backtracker'

mask = Mask.new(5, 5)

mask = false
mask = false
mask = false

grid = MaskedGrid.new(mask)
RecursiveBacktracker.on(grid)

puts grid
#+END_SRC

好了! 好多了. 我们现在可以实例化一个新的掩码 (第 5 行), 关闭我们想要的任何单元格 (第 7-9 行), 然后使用那个掩码实例化我们的新 `MaskedGrid` (第 11 行). 最后, 我们在其上运行递归回溯算法. (这次我们不需要指定起始单元格, 因为我们为 `MaskedGrid` 实现了一个更智能的 `random_cell` 方法.)

当我们运行这个时, 我们应该会得到一个省略了那三个被掩码的单元格的新迷宫.

#+BEGIN_SRC sh
$ ruby -I. simple_mask.rb
+---+---+---+---+---+
|   |           |   |
+---+   +---+---+   +
|       |           |
+   +---+---+---+   +
|   |   |   |   |   |
+   +---+---+   +   +
|       |   |       |
+   +   +   +   +---+
|   |   |   |       |
+---+---+---+---+---+
#+END_SRC

更好! 但在掩码中手动关闭单元格仍然有点乏味. 让我们看看如何让它更直观一些.

** ASCII 掩码
ASCII Masks

想象一下, 如果我们能在一个单独的文件中“画”出我们的掩码, 并将该文件提供给我们的程序. 我们可以玩各种各样的设计, 而不必更改我们的程序! 让我们用简单的文本文件作为输入来实现这一点.

文本文件将按类似下面的方式格式化, 这显示了一个 10×10 网格的一个可能定义.

#+BEGIN_SRC text
mask.txt
X........X
....XX....
...XXXX...
....XX....
X........X
X........X
....XX....
...XXXX...
....XX....
X........X
#+END_SRC

每个 “X” 表示一个 “关闭” 的单元格, 其他任何东西 (在这种情况下, “.” 字符) 将是一个 “开启” 的单元格.

我们将通过在我们的 `Mask` 类上引入一个辅助方法来实现这一点. 打开 `mask.rb` 并在该类的开头, 在 `initialize` 方法之前, 添加以下内容.

#+BEGIN_SRC ruby
  def self.from_txt(file)
    lines = File.readlines(file).map { |line| line.strip }
    lines.pop while lines.last.length < 1

    rows = lines.length
    columns = lines.first.length
    mask = Mask.new(rows, columns)

    mask.rows.times do |row|
      mask.columns.times do |col|
        if lines[row][col] == "X"
          mask[row, col] = false
        else
          mask[row, col] = true
        end
      end
    end

    mask
  end
#+END_SRC

这个新的 `from_txt` 方法期望你传递一个文件名. 第 2 行然后逐行读取该文件的内容, 依次剥离每行的空白, 然后第 3 行从文件末尾移除任何空行.

现在, 我们将假设文件中的文本行数对应于我们掩码中的行数, 第一行中的文本列数对应于我们掩码中的列数. 第 5 行和第 6 行使该假设成为现实, 然后我们实例化我们的掩码.

最后, 第 9 行开始遍历文件的每一行的每个字符, 如果字符是 X 则将掩码中的相应位置设置为 `false`, 如果是其他任何东西则设置为 `true`. 当一切都完成后, 该方法返回新的 `Mask` 实例.

我们的程序现在变成如下. 将此代码放入 `ascii_mask.rb`.

#+BEGIN_SRC ruby
ascii_mask.rb
require 'mask'
require 'masked_grid'
require 'recursive_backtracker'

abort "Please specify a text file to use as a template" if ARGV.empty?
mask = Mask.from_txt(ARGV.first)
grid = MaskedGrid.new(mask)
RecursiveBacktracker.on(grid)

filename = "masked.png"
grid.to_png.save(filename)
puts "saved image to #{filename}"
#+END_SRC

注意, 我们将生成的迷宫保存为图像, 因为我们的掩码可能是任何大小. 如果我们试图在终端上显示大的迷宫, 事情会变得一团糟. 我们将通过在命令行上传递一个文件名作为参数来运行它. 如果我们使用本节开头的 `mask.txt`, 那么我们可以像这样运行我们的程序:

#+BEGIN_SRC sh
$ ruby -I. ascii_mask.rb mask.txt
saved image to masked.png
#+END_SRC

打开 `masked.png`, 我们应该会看到类似下图的东西.

#+CAPTION: 一个从 ASCII 掩码文件生成的迷宫.

玩玩不同的模板, 看看你得到了什么! 你甚至可以尝试画出你的名字, 并生成一个围绕字母或在字母内部的迷宫 (取决于你如何设置你的模板). 不过, 如果你决定在单词的字母内部生成迷宫, 请确保以某种方式将字母链接在一起. 否则, 网格的不同部分将不会连接, 迷宫算法将无法连接所有这些部分.

不过, 一旦你尝试了其中一些, 你可能会意识到, 纯粹用文本来设计更大的模板是相当乏味的. 让我们看看一种 (可能) 更方便的方式来定义这些模板.

** 图像掩码
Image Masks

之前将这些掩码比作图像, 其中每个单元格就像一个你打开或关闭的像素. 那么, 使用实际的图像作为模板可能是有意义的, 其中特定颜色 (比如说, 黑色) 的像素被认为是关闭的, 其他一切都被认为是开启的. 这将让我们使用图像编辑器来设计我们的模板, 这应该会让制作更大的掩码容易得多.

让我们来实现这个. 我们将创建一个接受 PNG 格式图像的方法, 所以我们首先需要做的是确保 ChunkyPNG 库被加载. 再次打开 `mask.rb` 并在文件的最顶部添加以下行:

#+BEGIN_SRC ruby
require 'chunky_png'
#+END_SRC

一旦我们有了那个, 我们可以添加我们的新方法, 就像我们为从文本文件定义掩码所做的那样. 让我们称之为 `from_png(file)`, 并在 `from_txt` 方法之后添加它.

#+BEGIN_SRC ruby
  def self.from_png(file)
    image = ChunkyPNG::Image.from_file(file)
    mask = Mask.new(image.height, image.width)

    mask.rows.times do |row|
      mask.columns.times do |col|
        if image[col, row] == ChunkyPNG::Color::BLACK
          mask[row, col] = false
        else
          mask[row, col] = true
        end
      end
    end

    mask
  end
#+END_SRC

第 2 行从磁盘加载指定的图像, 第 3 行使用与图像相同的维度实例化一个新的掩码. 第 5 行然后开始遍历图像的每个像素, 如果像素是黑色则将掩码中的相应位置设置为 `false`, 如果是任何其他颜色则设置为 `true`.

有了那个新方法, 我们可以重做我们的 `ascii_mask.rb` 文件, 以读取和使用 PNG 文件作为我们的迷宫模板. 将 `ascii_mask.rb` 复制到 `image_mask.rb`, 并进行以下更改.

#+BEGIN_SRC ruby
image_mask.rb
require 'mask'
require 'masked_grid'
require 'recursive_backtracker'

abort "Please specify a PNG image to use as a template" if ARGV.empty?
mask = Mask.from_png(ARGV.first)
grid = MaskedGrid.new(mask)
RecursiveBacktracker.on(grid)

filename = "masked.png"
grid.to_png(cell_size: 5).save(filename)
puts "saved image to #{filename}"
#+END_SRC

注意, 在最后, 当我们将网格保存为 PNG 图像时, 我们将单元格大小设置为 5 像素而不是默认的 10, 以便更容易地容纳更大的迷宫.

现在剩下的就是想出一个用作模板的图像了! 如果你不确定用什么来制作你自己的图像模板, 我推荐 GIMP,¹ 一个优秀的、免费的图像处理程序, 可用于 Windows、Linux 和 Mac OS X. (不过请注意, 你需要给自己一些时间来适应学习曲线!) 记住: 黑色用于单元格不应该被创建的区域, 所以如果你从黑色背景开始, 你可以在你的画布上用任何其他颜色绘制来定义你的迷宫应该存在的区域.

另一方面, 如果图像处理不是你的菜, 本书使用的源代码中提供了在线示例图像.

让我们来看看这个的实际效果. 我们将创建以下图像, 称之为 `maze_text.png`.

#+CAPTION: 一个包含单词 "MAZES" 的图像掩码.

然后, 我们像以前一样启动我们的新脚本.

#+BEGIN_SRC sh
$ ruby -I. image_mask.rb maze_text.png
saved image to masked.png
#+END_SRC

结果呢? 这个!

#+CAPTION: 从 `maze_text.png` 掩码生成的迷宫.

简直是魔法!

** 轮到你了
Your Turn

掩码是一种强大的技术, 它开启了许多可能性. 我们在本章中只触及了皮毛. 花些时间进行实验, 看看你还能想出什么. 这里有一些想法可以让你开始.

*** 几何设计
Geometric Designs

到目前为止, 我们的迷宫都被限制在由矩形界定的网格中. 尝试使用掩码将迷宫硬塞进一个三角形或一个圆形.

*** 多状态掩码
Multi-State Masks

在我们的 `Mask` 类中, 我们使用了一个布尔值数组来指示单元格可以存在和不能存在的位置. 如果我们用整数代替布尔值, 我们就有了多状态掩码的可能性, 允许我们在网格内描述多个不同的区域. 这的一种用途是将网格分成多个部分, 在每个部分上运行不同的迷宫算法, 然后通过通道将每个部分连接在一起, 以创建一个具有多种风格的单一迷宫. 一个例子: 一个围绕庭院的树篱迷宫, 庭院中心有另一个迷宫.

*** 带房间的迷宫
Mazes with Rooms

掩码的另一个用途是在你的迷宫中声明房间. 掩码说明了迷宫走廊应该在哪里绘制, 当一切都完成后, 你添加连接禁区的走廊到迷宫本身. 这些禁区就成了房间.

遗憾的是, 尽管这些掩码很有用, 但它们确实倾向于创建具有非常锯齿状、像素化外观的轮廓, 特别是如果你试图创建的形状包含任何曲线或对角线. 特别是圆形, 受此影响. 我们接下来将看看一种完全不同的技术, 用于在圆形内生成迷宫.

* 第 7 章：兜圈子
*Going in Circles*

在这一点上, 如果有人向我们要一个“圆形迷宫”, 我们可以通过制作一个圆形的模板图像, 然后使用掩码来生成相应的迷宫来满足他们. 我们会得到类似下面的东西:

#+CAPTION: 使用圆形掩码和矩形网格生成的迷宫.

不过, 如果我们对自己完全诚实, 我们必须承认, 尽管这行得通, 但它并不怎么吸引人. 掩码的锯齿状、像素化的边缘仅仅是在近似我们想要的圆形, 并且被一对一地转换到我们网格的僵硬、矩形的单元格上. 这种由垂直的行和列组成的排列被称为*常规*或*正交网格* (regular or orthogonal grid), 尽管它有很多优点——易于理解, 易于实现——但在你试图表示像对角线或曲线这样的非正交线条时, 它就有点力不从心了.

恰好有一类网格非常适合圆形. 它被称为*极坐标网格* (polar grid), 我们用它构建的迷宫被称为 *theta* 或圆形迷宫. 在本章中, 你将看到如何使用这些网格来制作看起来很像下面这个的圆形迷宫:

#+CAPTION: 使用极坐标网格生成的圆形迷宫.

为了达到这个目的, 我们将从讨论极坐标网格以及它们与我们目前所做的有何不同开始. 然后我们将引入一个新的 `Grid` 子类, 我们将在其中重写我们的 `to_png` 方法以支持这种新的网格思维方式, 最后我们将看看如何使网格的单元格尽可能均匀大小.

** 理解极坐标网格
Understanding Polar Grids

我们习惯的正交网格由行和列的单元格组成, 而极坐标网格则由同心圆环组成, 每个圆环都被分割成单元格, 就像马车轮的辐条一样.

#+CAPTION: 一个极坐标网格的图示.

我们可以用很多方式在代码中表示其中之一, 但事实证明, 我们可以用我们现有的网格类, 只需做一些小的改动. 我们将分阶段进行, 从绘制一个极坐标网格需要什么开始. 如果我们能画出一个, 我们就已经解决了一半以上的问题!

在开始时, 我们从一些给定的值开始. 这些包括每个环的高度 (我们称之为 `ring_height`), 以及环中有多少个单元格 (或 `cell_count`). 有了这些, 我们就可以定义一个给定单元格的几何形状, 像这样:

#+BEGIN_SRC ruby
theta        = 2 * Math::PI / cell_count
inner_radius = cell.row * ring_height
outer_radius = (cell.row + 1) * ring_height
theta_ccw    = cell.col * theta
theta_cw     = (cell.col + 1) * theta
#+END_SRC

`theta` 变量描述了环中每个单元格的*角大小*. 如果一个完整的圆描述了 \(2 \cdot \pi\) 弧度的角度, 那么我们只需将其除以环中的单元格数, 就可以看到一个单元格覆盖了多少弧度.

`inner_radius` 和 `outer_radius` 变量告诉我们单元格离原点有多远, 其中内值描述了*内壁*的距离, 外值描述了*外壁*的距离.

最后两个变量用于描述单元格的*逆时针*和*顺时针*墙壁的位置, 以弧度为单位. 逆时针墙壁由 `theta_ccw` 描述, 这就是绕圆到那堵墙的角度. 同样, `theta_cw` 描述了到顺时针墙壁的角度.

让我们把这些放在一个图上, 看看它们是否更有意义. 下图放大了我们的极坐标网格, 查看一个任意单元格, 其角点为 A、B、C 和 D.

#+CAPTION: 图 2—用极坐标描述一个单元格

我们可以看到, \(\theta\) (theta) 是单元格的角大小, 内外半径是单元格墙壁到原点的距离. 此外, AB 墙是逆时针的, CD 是顺时针的, 两者都是围绕圆的 \(\theta\) 弧度的某个倍数.

对吗?
呼!

下一步, 因为大多数图像库不理解极坐标, 是将它们转换为*笛卡尔坐标* (Cartesian coordinates)——通常用于在图像中寻址位置的 x,y 对. 我们将借助三角形来帮助转换, 测量点离网格原点的 x 和 y 距离. 我们需要借助一点三角学知识, 但别担心, 如果你有一段时间没有锻炼那些肌肉了. 我们会一起走过.

这是一个图表, 以防你需要复习一下直角三角形的边与斜边的关系. 斜边标记为 r:

#+CAPTION: 一个直角三角形, 边为 x, y, 斜边为 r, 夹角为 θ.
\[
\begin{aligned}
x &= r \cdot \cos\theta \\
y &= r \cdot \sin\theta
\end{aligned}
\]

记住正弦和余弦按字母顺序对应于 x 和 y, 这总能帮助我. 正如余弦在字典中先于正弦, x 也先于 y, 这表明我们将用余弦来计算 x, 用正弦来计算 y. 将斜边乘以角度 \(\theta\) 的余弦或正弦, 将分别给我们离原点的 x 或 y 距离.

回到图 2, *用极坐标描述一个单元格*, 第 99 页, 不难想象一个叠加的三角形, A (或 B) 在右上角, 网格原点在左下角. 如果内外半径是斜边, 我们可以用那些三角公式来得到我们需要的笛卡尔坐标.

多亏了三角学, 那么, 我们现在知道了描述图 2, *用极坐标描述一个单元格*, 第 99 页中标记为 A, B, C, D 的单元格四个角所需的一切. 假设 `center_x` 和 `center_y` 是我们圆心的坐标, 我们单元格的坐标就变成了:

#+BEGIN_SRC ruby
ax = center_x + inner_radius * Math.cos(theta_ccw)
ay = center_y + inner_radius * Math.sin(theta_ccw)
bx = center_x + outer_radius * Math.cos(theta_ccw)
by = center_y + outer_radius * Math.sin(theta_ccw)
cx = center_x + inner_radius * Math.cos(theta_cw)
cy = center_y + inner_radius * Math.sin(theta_cw)
dx = center_x + outer_radius * Math.cos(theta_cw)
dy = center_y + outer_radius * Math.sin(theta_cw)
#+END_SRC

那么, 剩下的就是画出它了.

** 绘制极坐标网格
Drawing Polar Grids

我们到目前为止使用的 `to_png` 方法对极坐标网格没有太大帮助, 所以我们只需子类化 `Grid` 并重写 `to_png` 以满足我们的需要.

创建一个名为 `polar_grid.rb` 的新文件. 我们将从以下 `Grid` 子类和 `to_png` 实现开始.

#+BEGIN_SRC ruby
polar_grid.rb
require 'grid'

class PolarGrid < Grid
  def to_png(cell_size: 10)
    img_size = 2 * @rows * cell_size

    background = ChunkyPNG::Color::WHITE
    wall = ChunkyPNG::Color::BLACK

    img = ChunkyPNG::Image.new(img_size + 1, img_size + 1, background)
    center = img_size / 2

    each_cell do |cell|
      theta      = 2 * Math::PI / @grid[cell.row].length
      inner_radius = cell.row * cell_size
      outer_radius = (cell.row + 1) * cell_size
      theta_ccw  = cell.column * theta
      theta_cw   = (cell.column + 1) * theta

      ax = center + (inner_radius * Math.cos(theta_ccw)).to_i
      ay = center + (inner_radius * Math.sin(theta_ccw)).to_i
      bx = center + (outer_radius * Math.cos(theta_ccw)).to_i
      by = center + (outer_radius * Math.sin(theta_ccw)).to_i
      cx = center + (inner_radius * Math.cos(theta_cw)).to_i
      cy = center + (inner_radius * Math.sin(theta_cw)).to_i
      dx = center + (outer_radius * Math.cos(theta_cw)).to_i
      dy = center + (outer_radius * Math.sin(theta_cw)).to_i

      img.line(ax, ay, cx, cy, wall) unless cell.linked?(cell.north)
      img.line(cx, cy, dx, dy, wall) unless cell.linked?(cell.east)
    end

    img.circle(center, center, @rows * cell_size, wall)
    img
  end
end
#+END_SRC

这个新的 `to_png` 方法开始时很像旧版本, 计算我们画布的大小. 不过, 在这种情况下, 画布的宽度和高度将是我们圆的直径, 或者是半径的两倍, 即行数乘以每行的高度 (第 5 行). 那么, 网格的中心将是我们圆的中心, 计算为直径的一半 (第 11 行).

现在, 对于网格中的每个单元格, 第 14-18 行测量内外半径和相关角度, 然后在第 20-27 行用于计算单元格每个角的坐标. (那部分应该看起来很熟悉, 来自前一节.) 注意, 我们将每个坐标转换为整数, 因为 ChunkyPNG 对非整数参数处理得不好.

一旦我们有了那些坐标, 第 29 行和第 30 行就用它们来绘制单元格的内壁和顺时针墙壁. (现在, 我们将这些方向分别称为北和东, 因为它们与底层的正交网格很好地对应. 我们很快就会变得花哨, 创建一个自定义的 `Cell` 子类.)

最后, 我们将整个网格的外墙画成一个圆 (第 33 行), 然后返回我们的图像.

#+BEGIN_QUOTE
Joe 提问:
我们为什么画线而不是弧线?
Why Are We Drawing Lines Instead of Arcs?

好眼力! 理想情况下, 我们会在第 29 行用一个弧线来绘制内壁, 以遵循圆的曲线, 但在撰写本文时, ChunkyPNG 没有提供用于绘制弧线的 API. 事实证明, 直线 (大多) 效果还不错, 但如果你在自己的代码中使用不同的图像库, 也许可以检查一下它是否支持弧线绘制.
#+END_QUOTE

让我们现在检查一下这是否有效. 将以下内容放入一个名为 `polar_grid_test.rb` 的文件中.

#+BEGIN_SRC ruby
polar_grid_test.rb
require 'polar_grid'

grid = PolarGrid.new(8, 8)

filename = "polar.png"
grid.to_png.save(filename)
puts "saved to #{filename}"
#+END_SRC

我们创建一个有八行 (或环) 和八列 (轮辐) 的新极坐标网格, 然后简单地显示结果. 因为我们不打算在上面生成迷宫, 它应该只是保存网格本身. 果然, 我们得到以下结果:

#+CAPTION: 一个渲染的 8x8 极坐标网格.

它不是很好 (直线给了它一个明显的蜘蛛网般的外观), 但它足以表明我们在正确的轨道上. 这是一个可识别的极坐标网格.

在这一点上, 我们甚至可以运行我们的一个迷宫算法, 但我无论如何不推荐——还不行. 例如, 这是应用了递归回溯算法的同一个网格:

#+CAPTION: 一个应用了递归回溯算法的 8x8 极坐标迷宫.

这是一个有趣的图案, 但并不是我们真正想要的. 最外层的单元格与最内层的单元格相比太宽了, 造成了非常不均匀的外观, 尽管它在技术上是一个迷宫, 但它缺乏迷宫预期的美感. 我们需要一种方法来使单元格尽可能均匀大小, 即使网格的同心圆越来越大.

要解决这个问题, 我们需要看一种当单元格变得太大时进行分割的技术, 称为*自适应细分* (adaptive subdivision).

** 自适应地细分网格
Adaptively Subdividing the Grid

为了使用自适应细分来使我们的单元格大小更均匀, 我们需要知道它们应该有多大. 正方形在正交网格中看起来不错, 但极坐标网格不能给我们真正的正方形. 极坐标网格中没有平行线! 但尽管我们不能有正方形, 我们可以近似它们. 我们就说我们希望内壁的长度与单元格的高度 (内外壁之间的距离) 大致相同.

#+CAPTION: 一列极坐标单元格的图示.

记住这个规则, 看看图, 它显示了我们极坐标网格的一“列”, 并采取步骤使其更均匀一些.

首先, 我们看最里面的两个单元格, 发现它们都符合要求. 它们的内壁不比单元格高. 但下一个单元格...哎呀. 它宽得多. 为了解决这个问题, 我们将单元格——以及所有后续单元格——分成两半, 像这样:

#+CAPTION: 单元格在变得太宽时被细分.

第三行现在看起来不错, 第四行也一样 (尽管它确实变得有点宽了). 然而, 第五行敲响了一些警钟. 太宽了. 答案? 再次细分.

#+CAPTION: 单元格根据需要再次细分.

在这一点上, 我们的原始列已经分支出多个列. 单元格现在看起来更规则了, 但这是有代价的: 我们通过分割单元格增加了一些复杂性, 以至于一些单元格现在在向外方向有两个邻居, 而不是只有一个.

幸运的是, 这并不难控制, 正如我们将在下一节中看到的那样, 当我们把所有东西都整合到代码中时.

** 实现极坐标网格
Implementing a Polar Grid

为了实现这个改进的极坐标网格, 我们将引入一个新的 `Cell` 子类, 然后逐步讲解这些新单元格将如何布局和细分. 我们将用最后一个主要是装饰性的调整来完成这一切, 使我们的最终迷宫尽可能整洁.

*** PolarCell 类
The PolarCell Class

首先, 新的 `Cell` 子类. 到目前-为止, 我们一直使用现有的 `Cell` 类, 但在它们与极坐标网格的映射不那么直观时, 继续引用罗盘方向变得有点笨拙. 此外, 随着自适应细分, 一些单元格现在可能在向外方向有两个邻居, 而我们现有的 `Cell` 类不支持这一点.

所以, 将以下内容放入 `polar_cell.rb`.

#+BEGIN_SRC ruby
polar_cell.rb
require 'cell'

class PolarCell < Cell
  attr_accessor :cw, :ccw, :inward
  attr_reader :outward

  def initialize(row, column)
    super
    @outward = []
  end

  def neighbors
    list = []
    list << cw if cw
    list << ccw if ccw
    list << inward if inward
    list += outward
    list
  end
end
#+END_SRC

第 4 行和第 5 行通过定义极坐标方向的属性来开始: 顺时针 (`cw`), 逆时针 (`ccw`), 向内 (朝向原点), 和向外 (朝向边缘).

#+BEGIN_QUOTE
 * 重构 Cell 类
Refactoring the Cell Class

在这一点上, 你可能想花些时间对 `Cell` 进行适当的重构, 以便子类不会继承不必要的包袱 (比如 `north`, `south` 等). 像我们这样的有机增长的项目, 随着代码的增长和成熟, 经常会经历重构迭代来“整理”. 遗憾的是, 在这里这样做超出了本书的范围, 但不要让那阻止你!
#+END_QUOTE

注意第 5 行只授予 `outward` 一个读取器, 而不是写入器, 因为我们不会直接给它赋值. 相反, 在第 9 行的构造函数中, 我们将 `outward` 初始化为一个空数组, 我们将根据需要向其追加单元格.

好了. 有了我们新的单元格类, 我们可以回到 `PolarGrid` 并开始充实它.

*** 重访 PolarGrid
Revisiting PolarGrid

我们更新的极坐标网格实现将覆盖基类的几个方法, 包括构造函数, `prepare_grid`, `configure`, 等等. 我们将再次打开 `polar_grid.rb` 并在那里进行所有以下更改.

首先, 让我们在我们的新 `PolarCell` 类上添加一个依赖项.

#+BEGIN_SRC ruby
require 'grid'
require 'polar_cell'
#+END_SRC

接下来, 我们将为 `PolarGrid` 创建一个新的构造函数. 到目前为止, 我们一直在告诉每个网格它有多少行和列, 但自适应细分允许我们计算每行的列数. 我们真正需要告诉我们网格的只是行数——我们可以从那里得到其他一切. 把这个放在 `PolarGrid` 类的顶部, 在 `to_png` 方法之前.

#+BEGIN_SRC ruby
def initialize(rows)
  super(rows, 1)
end
#+END_SRC

`super` 调用中的第二个参数是必需的, 因为超类需要知道网格有多少列 (这可以说是一个设计缺陷, 但我们将就此将就).

下一个方法是重点. 我们将覆盖 `prepare_grid` 并对其进行更改, 以便它不是像以前那样构建一个常规网格, 而是准备我们的自适应细分的极坐标网格. 在 `initialize` 方法之后添加以下方法.

#+BEGIN_SRC ruby
  def prepare_grid
    rows = Array.new(@rows)

    row_height = 1.0 / @rows
    rows = [ PolarCell.new(0, 0) ]

    (1...@rows).each do |row|
      radius = row.to_f / @rows
      circumference = 2 * Math::PI * radius

      previous_count = rows[row - 1].length
      estimated_cell_width = circumference / previous_count
      ratio = (estimated_cell_width / row_height).round

      cells = previous_count * ratio
      rows[row] = Array.new(cells) { |col| PolarCell.new(row, col) }
    end

    rows
  end
#+END_SRC

尽管它是一个极坐标网格, 我们仍然将使用数组来表示每一行. 第 2 行为此设置.

第 4 行然后计算每个单独行的高度. 在这一点上, 我们不知道渲染时圆会有多大, 但没关系. 我们可以假设我们正在处理一个单位圆——也就是说, 一个半径为 1 的圆——几何定律向我们保证, 我们可以稍后轻松地调整它的大小. 这让我们简化了许多计算.

接下来, 第 5 行将我们圆的起点——第 0 行——视为一个特殊情况. 因为所有的半径都在原点相遇, 将那一行分割成多个单元格意味着单元格会迅速变小. 相反, 我们将强制最内层的一行为一个单独的单元格, 坐标为 0, 0.

现在, 对于剩下的每一行, 我们将进行一些计算来弄清楚如何细分. 第 8 行计算该行的*内半径*——从原点到该行内壁的距离——然后用它来计算那堵墙的周长 (第 9 行). 记住, 我们在这里处理的是一个单位圆, 所以给定行的半径就是该行的索引与行数的比率. (是不是很方便?) 然后, 第 12 行将该周长除以前一行中的单元格数, 这告诉我们如果我们*不*细分, 这一行中的每个单元格会有多宽. 那是理想情况——我们不想细分, 除非我们必须这么做!

回想一下, 我们理想的单元格宽度与行的高度相同. 第 13 行用那个理想值来看我们的 `estimated_cell_width` 中可以容纳多少个理想大小的单元格. 这个 `ratio` 变量本质上告诉我们这一行中的多少个单元格对应于前一行中的每个单元格. 如果 `ratio` 是 1, 那么当前行将与前一行有相同数量的单元格. 如果是 2 (或更多), 那么我们就在细分. 除了索引为 1 的行, `ratio` 将总是 1 或 2. 那里的 `ratio` 可能会更大, 因为前一行 (在索引 0) 总是只包含一个单元格.

最后, 我们取 `ratio` 并将其乘以先前行中的单元格数 (第 15 行). 这告诉我们当前行应该有多少个单元格, 所以我们通过实例化一个具有相应数量的 `PolarCell` 实例的新数组来完成循环 (第 16 行).

呼!

那么, 在这一点上, 我们已经有了我们的网格, 但我们还没有为单个单元格设置邻接信息. 那些可怜的小家伙不知道他们的邻居是谁. 为此, 我们需要覆盖 `configure_cells` 方法.

#+BEGIN_SRC ruby
  def configure_cells
    each_cell do |cell|
      row, col = cell.row, cell.column

      if row > 0
        cell.cw = self[row, col + 1]
        cell.ccw = self[row, col - 1]

        ratio = @grid[row].length / @grid[row - 1].length
        parent = @grid[row - 1][col / ratio]
        parent.outward << cell
        cell.inward = parent
      end
    end
  end
#+END_SRC

在这里, 我们将查看网格中的每个单元格, 只忽略原点的单元格 (第 5 行), 因为它是我们的特殊情况, 没有向内或顺时针的邻居.

对于其他单元格, 我们设置它们的顺时针 (第 6 行) 和逆时针 (第 7 行) 邻居, 计算这一行与前一行单元格的比率 (第 9 行), 然后用它来决定前一行中的哪个单元格是“父”——那个可能或可能没有被细分以产生当前单元格的单元格 (第 10 行). 然后将当前单元格添加为该父单元格的向外邻居之一 (第 11 行), 并将父单元格设置为当前单元格的向内邻居 (第 12 行).

我们只需要再添加一个新方法, 来帮助我们从网格中选择一个随机的单元格. 这个很简单, 在前两个之后简直是一股清新的空气.

#+BEGIN_SRC ruby
  def random_cell
    row = rand(@rows)
    col = rand(@grid[row].length)
    @grid[row][col]
  end
#+END_SRC

最后, 我们需要对 `to_png` 做一些更改, 以适应我们新的邻居名称 (cw, ccw, 等) 以及围绕原点单元格的特殊情况. 更改 (或根据需要添加) 你的 `to_png` 副本, 使其与以下代码中的高亮行匹配.

#+BEGIN_SRC ruby
    each_cell do |cell|
      next if cell.row == 0
      # ...
      img.line(ax, ay, cx, cy, wall) unless cell.linked?(cell.inward)
      img.line(cx, cy, dx, dy, wall) unless cell.linked?(cell.cw)
    end
#+END_SRC

足够简单! 我们差不多完成了.

** 测试和调整
Testing and Tweaking

我们正在最后冲刺. 剩下的就是测试我们所拥有的, 然后调整最后一件事, 使成品看起来尽可能好.

我们现有的 `polar_grid_test.rb` 现在无法工作, 因为我们用太多的参数实例化了 `PolarGrid`. 请打开那个文件并更改它, 使我们只向构造函数传递一个参数——行数——然后再次尝试.

#+BEGIN_SRC ruby
grid = PolarGrid.new(8)
#+END_SRC

这一次, 我们应该会得到一些远不那么像蜘蛛网, 更有趣的东西.

#+CAPTION: 一个渲染的 8x8 自适应极坐标网格.

不错! 如果我们然后在这个网格上生成一个迷宫, 我们应该会看到一件美物. 将以下内容放入 `circle_maze.rb` 并试一试. 它使用递归回溯算法, 但如果你想实验其他算法, Aldous-Broder 或 Wilson 也应该同样有效.

#+BEGIN_SRC ruby
circle_maze.rb
require 'polar_grid'
require 'recursive_backtracker'

grid = PolarGrid.new(8)
RecursiveBacktracker.on(grid)

filename = "circle_maze.png"
grid.to_png.save(filename)
puts "saved to #{filename}"
#+END_SRC

结果呢? 看!

#+CAPTION: 一个 8 环的圆形迷宫.

嗯...但是, 等等. 它*几乎*是一件美物. 有一个小瑕疵让它离幸福的、圆形的完美还有一步之遥. 你看到了吗?

#+CAPTION: 迷宫, 注意穿过它的垂直线.

就是那条径向线, 标记了我们网格的顺时针和逆时针边缘之间的边界. 这可能看起来是件小事, 但试着生成一些这样的迷宫. 把它们做得更大, 有 25 行或更多. 那条小小的径向线会很快变得令人讨厌!

要修复它, 我们只需要告诉网格, 顺时针边界上的单元格与逆时针边界上的单元格是相邻的. 我们可以通过进一步修改 `configure_cells` 方法来做到这一点, 但如果我们走那条路, 我们最终将不得不执行相同的检查两次——一次是为顺时针邻居, 一次是为逆时针邻居. 我们可以通过将该检查移动到数组访问器方法本身来避免重复, 如下面的代码所示. 请将它添加到 `PolarGrid` 类中, 就在 `random_cell` 方法之前.

#+BEGIN_SRC ruby
  def [](row, column)
    return nil unless row.between?(0, @rows - 1)
    @grid[row][column % @grid[row].count]
  end
#+END_SRC

高亮的一行是魔法发生的地方. 注意, 我们不再检查 `column` 参数的边界. 相反, 我们使用模运算来确保列总是被包装以适应那些边界. 通过这种方式, 顺时针边界和逆时针边界有效地变得相邻.

去保存那个, 再试着生成一个迷宫.

#+CAPTION: 一个最终的、无缝的圆形迷宫.

最后, 一件值得骄傲的作品!

** 轮到你了
Your Turn

这一章内容很多! 我们看了一种新型的网格——极坐标网格——并讨论了如何表示和显示它. 我们讨论了如何使用自适应细分来使我们新网格的单元格大小均匀, 最后展示了如何使用模运算来通过使相对的边界相邻来移除接缝.

即便如此, 我们也几乎只触及了皮毛. 这里有一些你可能想自己尝试的事情.

*** 触动细分触发器
Tickling the Subdivision Trigger

在早期的实现中, 当一个单元格的宽度至少是行高的 1.5 倍时, 它会被细分. (这就是在 `PolarGrid#prepare_grid` 的第 13 行使用 `round` 方法的目的.) 试着在调用 `round` 之前, 在括号内加上或减去一些东西, 比如 0.25, 看看当你用不同的阈值触发时会发生什么.

*** 圆形迷宫上的掩码
Masks on a Circle Maze

你可能会尝试将前一章的内容应用到这里, 将掩码应用于圆形迷宫. 你需要找到一种方法将你的掩码映射到一个圆上, 你还需要对 `to_png` 做一些更改, 因为这里给出的实现假设一个单元格的每个邻居都存在. 与其让每个单元格只在内侧和顺时针边缘绘制墙壁, 你需要检查其他方向是否存在邻居, 如果不存在, 也在那里绘制墙壁.

*** 生长一个圆形的二叉树
Growing a Circular Binary Tree

是的, 二叉树 (和 Sidewinder 也一样) 可以在一个圆形迷宫上工作! 实际上, 你会得到一种相当迷人的风车效果. 你只需要确保你的网格有一个明确定义的顺时针/逆时针边界, 否则那些算法将不保证能产生一个有效的迷宫. 移除我们自定义的数组访问器方法, 试一试!

*** 为圆形迷宫着色
Coloring a Circle Maze

还记得几章前, 当我们玩 Dijkstra 算法时吗? 我们实现了一个名为 `background_color_for` 的方法来支持用不同颜色绘制单元格. 为了清晰起见, 我在这里的极坐标网格实现中牺牲了那个方法, 但把它加回去并不难. 试一试! 彩色的圆形迷宫很可爱.

#+CAPTION: 一个着色的圆形迷宫.

一旦你对极坐标网格感到自在了, 坚持住, 因为我们接下来将直接跳到一些其他类型的网格! 我们将探索如何用三角形和六边形制作网格, 然后向你指出一些其他有趣的形状组合.
* 第 8 章：探索其他网格
*Exploring Other Grids*

当你把一个表面分割成不同的形状, 它们之间没有间隙也没有重叠时, 你就得到了所谓的表面的*镶嵌* (tessellation). 我们的标准网格就是这样一种镶嵌, 我们把一个平面区域, 或*平面* (plane), 分割成更小的正方形. 另一种说法是, 我们用正方形*平铺* (tiled) 了平面.

事实证明, 正方形并不是唯一能为我们做到这一点的形状. 在本章中, 我们将研究另外两种由其他几何形状平铺而成的网格. 我们将看到六边形如何组合成蜂窝状图案, 三角形如何形成桁架式格子. 在本章的过程中, 我们将使用这些新网格来制作如下的迷宫:

#+CAPTION: 一个六边形迷宫和一个三角形迷宫.

让我们从左边的那个开始: 一个六边形网格上的迷宫.

** 实现六边形网格
Implementing a Hex Grid

到目前为止, 我们已经制作了常规网格和圆形网格. 我们的下一个目标是创建一个六边形网格, 简称*六边形网格* (hex grid). 我们将首先考虑单个单元格, 着眼于理解它如何与它的邻居在空间上相关联. 从那里, 我们将获取那些信息并实现网格本身.

单元格的实现并不难. 最棘手的部分只是理解它们是如何组合在一起的. 让我们在这里看一个简单的六边形网格:

#+CAPTION: 一个六边形网格的图示.

由此, 我们可以看到每个六边形最多与六个其他六边形相邻, 分别对应北、南、西北、东北、西南和东南. 很明显, 我们现有的 `Cell` 无法胜任; 它没有包含足够的邻居! 让我们现在通过引入一个新的 `Cell` 子类来解决这个问题.

将以下内容放入 `hex_cell.rb`.

#+BEGIN_SRC ruby
hex_cell.rb
require 'cell'

class HexCell < Cell
  attr_accessor :northeast, :northwest
  attr_accessor :southeast, :southwest

  def neighbors
    list = []
    list << northwest if northwest
    list << north if north
    list << northeast if northeast
    list << southwest if southwest
    list << south if south
    list << southeast if southeast
    list
  end
end
#+END_SRC

这只是扩展了 `Cell` 类, 为西北、东北、西南和东南添加了新的访问器, 然后更新了 `neighbors` 方法以返回那些新方向. 注意, 从 `Cell` 类继承的 `west` 和 `east` 访问器是未使用的. 在我们的网格中, 六边形以它们的方式定向 (平顶), 它们永远不会有向东或向西的邻居.

下一步是弄清楚这些单元格是如何在网格中排列的. 尽管它们不一定以清晰的行排列, 但不难找到一个行之有效的排列方式.

再次看前面的图表, 我们可以看到, 尽管垂直的列在网格中清晰可见, 但水平的行就不那么明显了. 可能毫不奇怪, 有很多不同的方法来在程序中表示六边形, 也不应该奇怪每种方法都有不同的优缺点. 我们将选择一种与我们底层的二维数组映射最紧密的方式, 仅仅因为它需要我们在我们这边做的改动最少.

下图显示了它将如何工作, 将每一行视为从网格一侧到另一侧的之字形路径, 而列则只是垂直地穿过网格.

#+CAPTION: 一个图示, 展示了如何将六边形网格映射到二维数组.

这个选择对我们如何设置网格有影响. 最直接的是, 这意味着当我们为某些列中的单元格设置邻接信息时 (例如, 前一个图示中的 B 和 D), 西北和东北对角线指向单元格的*同一行*, 而西南和东南则指向下一行. 相反, 对于其他列 (例如, A 和 C), 西北和东北是指向不同行的那些.

棘手, 但并非不可克服!

让我们制作一个新的 `Grid` 子类. 我们将覆盖 `prepare_grid` 方法, 以便它为单元格实例化我们的新 `HexCell` 类, 我们将覆盖 `configure_cells` 来为每个单元格设置正确的邻接信息.

将以下内容放入 `hex_grid.rb`.

#+BEGIN_SRC ruby
hex_grid.rb
require 'grid'
require 'hex_cell'

class HexGrid < Grid
  def prepare_grid
    Array.new(rows) do |row|
      Array.new(columns) do |column|
        HexCell.new(row, column)
      end
    end
  end

  def configure_cells
    each_cell do |cell|
      row, col = cell.row, cell.column

      if col.even?
        north_diagonal = row - 1
        south_diagonal = row
      else
        north_diagonal = row
        south_diagonal = row + 1
      end

      cell.northwest = self[north_diagonal, col - 1]
      cell.north     = self[row - 1, col]
      cell.northeast = self[north_diagonal, col + 1]
      cell.southwest = self[south_diagonal, col - 1]
      cell.south     = self[row + 1, col]
      cell.southeast = self[south_diagonal, col + 1]
    end
  end
end
#+END_SRC

第 17-23 行设置了一些变量来帮助我们处理那些之字形的行. 当列是偶数 (`col.even?`) 时, 我们让北对角线指向前一行, 而南对角线指向当前行. 当列是奇数时, 我们交换它, 以便北对角线指向当前行, 而南对角线指向下一行.

有了那些变量, 第 25-30 行计算了与当前单元格相邻的单元格.

这就足以设置我们的网格, 所有单元格都与它们的邻居适当地安顿在一起. 我们现在所缺的只是一个显示它的方法, 因为 `Grid` 本身的 `to_png` 方法只能处理正方形.

** 显示六边形网格
Displaying a Hex Grid

要显示一个六边形网格, 我们需要能够计算其每个角或*顶点* (vertices) 的坐标. 我们将看到如何计算那些相对于每个六边形中心的坐标, 以及如何计算一个六边形网格的整体尺寸, 然后我们将把所有这些都插入到一个新的 `to_png` 实现中.

我们将假设我们的网格是由*正六边形* (regular hexagons)——边长都相等的六边形——组成的. 有了这个假设, 有一个涉及*等边三角形* (equilateral triangles) (边都相等的三角形) 的可爱的小推导, 可以让我们得到我们需要的测量值. 为了简洁起见, 我们将在这里跳过推导本身, 但如果你对几何学感兴趣, 它会非常直接.

本质上, 我们想要的是下图中 \(a_1\), \(a_2\), 和 \(b\) 的长度:

#+CAPTION: 图 3—一个被解剖的六边形

如果 c 是我们六边形的中心, s 是一条边的长度, 那么结果是 \(a_1\) 和 \(a_2\) 是相同的. (我们就简单点, 把它们都叫做 a.) 我们还发现 a 是 s 的一半, 而 b 的长度是 \(s\sqrt{3}/2\). 由此得出, 我们六边形的宽度 (从西点到东点) 正好是 2s, 高度是 2b. 在代码中:

#+BEGIN_SRC ruby
a_size = s / 2.0
b_size = s * Math.sqrt(3) / 2.0
width = s * 2.0
height = b_size * 2.0
#+END_SRC

有了这些数字, 我们可以计算六边形所有六个顶点的 x 和 y 坐标. 如果 cx 和 cy 代表某个单元格的中心点坐标, 我们把那些离中心更远的顶点称为“远 (far)”, 离得更近的称为“近 (near)”, 我们得到:

#+BEGIN_SRC ruby
x_far_west = cx - s
x_near_west = cx - a_size
x_near_east = cx + a_size
x_far_east = cx + s

y_north = cy - b_size
y_mid = cy
y_south = cy + b_size
#+END_SRC

现在我们有了那些命名的坐标, 我们可以说 (例如) 3 点钟位置的顶点在 `(x_far_east,y_mid)`.

在实现我们的新绘图代码之前, 我们需要的最后一点是计算我们画布尺寸的方法. 这不像常规网格那么直接, 因为相邻的单元格是相互偏移的. 在这种情况下, 将我们的网格拿出来, 在上面覆盖一个常规网格会很有帮助, 就像下图所示.

#+CAPTION: 图 4—测量一个六边形网格

我们知道如何计算一个常规网格的尺寸, 所以如果我们能弄清楚覆盖的每个单元格有多宽, 我们就能确定我们原始网格的大小.

在这种情况下, 我们有一个 4×4 的六边形网格. 如果你回想一下图 3, *一个被解剖的六边形*, 第 117 页, 你可以看到这里的每个矩形都是三个 a 长度宽, 从一个六边形的西点到下一个邻居的西点测量. 那么, 数一下方块, 这个 4×4 的画布作为一个整体, 就和四个那些方块一样宽, 再加上一个 a 长度. 在代码中, 它可能像这样组合在一起:

#+BEGIN_SRC ruby
canvas_width = 3 * columns * a_size + a_size
#+END_SRC

高度要直接得多. 我们可以很容易地看到每个方块和一个六边形一样高, 而画布作为一个整体则和四个那些六边形一样高, 再加上另一个半六边形 (一个 b 长度). 换句话说:

#+BEGIN_SRC ruby
canvas_height = rows * height + b_size
#+END_SRC

把所有这些放在一起, 我们终于可以编写我们新的 `to_png` 方法了! 将以下内容放入 `hex_grid.rb`, 在 `HexGrid` 类中的某个地方.

#+BEGIN_SRC ruby
hex_grid.rb
  def to_png(size: 10)
    a_size = size / 2.0
    b_size = size * Math.sqrt(3) / 2.0
    width = size * 2
    height = b_size * 2

    img_width = (3 * a_size * columns + a_size + 0.5).to_i
    img_height = (height * rows + b_size + 0.5).to_i

    background = ChunkyPNG::Color::WHITE
    wall = ChunkyPNG::Color::BLACK

    img = ChunkyPNG::Image.new(img_width + 1, img_height + 1, background)

    [:backgrounds, :walls].each do |mode|
      each_cell do |cell|
        cx = size + 3 * cell.column * a_size
        cy = b_size + cell.row * height
        cy += b_size if cell.column.odd?

        # f/n = far/near
        # n/s/e/w = north/south/east/west
        x_fw = (cx - size).to_i
        x_nw = (cx - a_size).to_i
        x_ne = (cx + a_size).to_i
        x_fe = (cx + size).to_i

        # m = middle
        y_n = (cy - b_size).to_i
        y_m = cy.to_i
        y_s = (cy + b_size).to_i

        if mode == :backgrounds
          color = background_color_for(cell)
          if color
            points = [[x_fw, y_m], [x_nw, y_n], [x_ne, y_n],
                      [x_fe, y_m], [x_ne, y_s], [x_nw, y_s]]
            img.polygon(points, color, color)
          end
        else
          img.line(x_fw, y_m, x_nw, y_s, wall) unless cell.southwest
          img.line(x_fw, y_m, x_nw, y_n, wall) unless cell.northwest
          img.line(x_nw, y_n, x_ne, y_n, wall) unless cell.north
          img.line(x_ne, y_n, x_fe, y_m, wall) unless cell.linked?(cell.northeast)
          img.line(x_fe, y_m, x_ne, y_s, wall) unless cell.linked?(cell.southeast)
          img.line(x_ne, y_s, x_nw, y_s, wall) unless cell.linked?(cell.south)
        end
      end
    end

    img
  end
#+END_SRC

第 1 行的命名 `size` 参数是我们之前称之为 s 的——六边形单边的尺寸. 随后的计算 (第 2-5 行) 使用该值来确定我们六边形的尺寸, 如前所述.

接下来的两行 (7 和 8) 计算我们画布的总宽度. 额外的 0.5 确保我们总是四舍五入到最接近的整数.

从 17 开始的三行计算当前单元格的中心点, 因为我们随后的计算都将相对于它. 这一切都回到了图 4, *测量一个六边形网格*, 第 118 页, 只是我们在这里测量的是当前单元格离其相应行和列中第一个单元格中心的距离.

一旦我们知道了中心点, 我们就可以计算当前单元格角的坐标, 正如我们之前谈到的. 第 23-31 行负责处理.

剩下的行与我们原始的 `to_png` 方法工作方式相同, 根据哪些邻居存在并且已经与当前单元格链接来为每个单元格绘制适当的墙壁.

就是这样! 有了我们新的 `to_png`, 我们应该能够绘制六边形网格, 并通过扩展——迷宫. 让我们接下来就这么做!

** 制作六边形 (Sigma) 迷宫
Making Hexagon (Sigma) Mazes

在六边形网格上制作的迷宫, 出于某种奇怪的原因, 被恰当地称为 *sigma* 迷宫. 幸运的是, 无论你怎么称呼它, 它的工作方式都一样: 只需选择一个迷宫算法, 让它运行. 让我们使用递归回溯算法来测试我们新的 `to_png` 实现.

将以下内容放入一个名为 `hex_maze.rb` 的文件中.

#+BEGIN_SRC ruby
hex_maze.rb
require 'recursive_backtracker'
require 'hex_grid'

grid = HexGrid.new(10, 10)
RecursiveBacktracker.on(grid)

grid.to_png.save('hex.png')
#+END_SRC

运行它, 你应该会得到类似下图的东西. 非常漂亮! 它确实如我们所愿地工作.

#+CAPTION: 一个 10x10 的六边形迷宫.

稍微实验一下其他迷宫算法, 看看你得到了什么, 但要小心二叉树和 Sidewinder! 这两个需要一点照看.

要理解为什么, 回忆一下*二叉树算法*, 第 6 页. 对于每个单元格, 我们在北和东之间选择来决定链接哪个邻居, 但在六边形网格的情况下, 单元格*没有*东邻居. 我们最好的是东北和东南. 同样, Sidewinder 想要选择一个东邻居, 但也会被我们新的几何形状所挫败. 那么我们该怎么办呢?

嗯, 那些算法实际上都不想要“东”. 它们真正想要的是“同一行中, 下一列的单元格”. 在常规网格上, 那恰好是*东*. 对于一个六边形网格, 那将是东北或东南, 取决于当前列, 但我们甚至不需要担心那个. 当我们设置网格时, 我们已经处理了行/列的分配. 要获取下一列的邻居, 我们可以只使用我们的数组访问器, 像这样:

#+BEGIN_SRC ruby
east = grid[cell.row, cell.column+1]
#+END_SRC

试试看! 在六边形网格上实现二叉树和 Sidewinder 算法, 看看你得到了什么. 当你准备好了, 我们将转向另一种网格风格: 三角形!

** 实现三角形网格
Implementing a Triangle Grid

三角形网格具有非常像格子的外观.

#+CAPTION: 一个三角形网格的图示.

和六边形一样, 将会有很多方法来实现这样的网格, 每种方法都有不同的优缺点. 为简单起见, 我们将看一种最接近常规网格的, 带有水平行和垂直列. 我们将使用*等边三角形* (equilateral triangles) (主要是因为它使数学更容易), 我们将从检查单元格以及它们如何组合在一起开始. 我们将看到单元格在网格上的方向背后有一个模式, 然后我们将在代码中实现它.

看前面的网格, 你可以看到一些三角形是*直立的* (upright) (点朝北), 一些是*倒置的* (upside-down) (点朝南). 事实上, 当你水平地穿过一行时, 这个模式每隔一个三角形就会重复. 此外, 每一行都以交替方向的三角形开始.

换句话说, 一个三角形将是直立的, 如果它的 (从 0 开始的) 行和列之和是偶数:

#+BEGIN_SRC ruby
upright = (row + column).even?
#+END_SRC

这个属性很重要, 因为一个直立的三角形没有北邻居, 一个倒置的三角形没有南邻居. 如果我们能指示我们网格中哪些三角形是直立的, 我们就可以在设置邻接信息时使用那个信息.

我们的 `TriangleCell` 结果非常直接:

#+BEGIN_SRC ruby
triangle_cell.rb
require 'cell'

class TriangleCell < Cell
  def upright?
    (row + column).even?
  end

  def neighbors
    list = []
    list << west if west
    list << east if east
    list << north if !upright? && north
    list << south if upright? && south
    list
  end
end
#+END_SRC

我们有一个 `upright?` 方法, 它只是根据行和列告诉我们给定的单元格应该是直立的还是倒置的. `neighbors` 方法然后给我们我们通常的东和西邻居, 并使用 `upright?` 来决定单元格是否有北或南邻居.

让我们看看这如何插入到一个网格中. 下面的实现最终看起来很像我们的六边形网格的实现, 带有被覆盖的 `prepare_grid` 和 `configure_cells` 方法.

将以下内容放入 `triangle_grid.rb`.

#+BEGIN_SRC ruby
triangle_grid.rb
require 'grid'
require 'triangle_cell'

class TriangleGrid < Grid
  def prepare_grid
    Array.new(rows) do |row|
      Array.new(columns) do |column|
        TriangleCell.new(row, column)
      end
    end
  end

  def configure_cells
    each_cell do |cell|
      row, col = cell.row, cell.column

      cell.west = self[row, col - 1]
      cell.east = self[row, col + 1]

      if cell.upright?
        cell.south = self[row + 1, col]
      else
        cell.north = self[row - 1, col]
      end
    end
  end
end
#+END_SRC

这里真正值得指出的唯一部分是在第 20-24 行配置北或南邻居的地方. 正如我们之前所说, 如果单元格是直立的, 那么它有一个南邻居, 否则是一个北邻居.

足够简单. 我们剩下要做的就是实现一个新的 `to_png` 方法, 这样我们就可以展示我们时髦的三角形了.

** 显示三角形网格
Displaying a Triangle Grid

显示一个等边三角形网格结果非常直接. 如果你之前已经通过了六边形测量值的推导, 那么你已经通过了我们对三角形所需的大部分内容. 再次, 我们不会在这里详细介绍推导本身, 但我们会逐步讲解最终的测量值, 然后我们将把所有这些都实现在代码中.

因为我们正在处理等边三角形, 我们知道它们的每条边都有相同的长度 (s). 此外, 几何学告诉我们等边三角形的高度是 \(s\sqrt{3}/2\). 那么, 我们三角形的尺寸是:

#+BEGIN_SRC ruby
width = s
half_width = width / 2.0

height = s * Math.sqrt(3) / 2.0
half_height = height / 2.0
#+END_SRC

我们将让我们的中心点位于顶点和底边之间的中点, 以及东西顶点之间的中点. 如果我们以该点为基础来确定我们的坐标, 那么我们的顶点可以用计算出的宽度和高度值来相对定义:

#+BEGIN_SRC ruby
west_x = cx - half_width
mid_x = cx
east_x = cx + half_width

if upright?
  base_y = cy + half_height
  apex_y = cy - half_height
else
  base_y = cy - half_height
  apex_y = cy + half_height
end
#+END_SRC

换句话说, x 坐标是相同的, 无论三角形是否直立. 唯一根据我们三角形的方向变化的是 y 坐标. 如果三角形是直立的, 我们的底边在中心点之下; 否则, 它在上面.

让我们把它写成代码! 将以下内容与 `triangle_grid.rb` 中的其他方法一起放入.

#+BEGIN_SRC ruby
  def to_png(size: 16)
    half_width = size / 2.0
    height = size * Math.sqrt(3) / 2.0
    half_height = height / 2.0

    img_width = (size * (columns + 1) / 2.0).to_i
    img_height = (height * rows).to_i

    background = ChunkyPNG::Color::WHITE
    wall = ChunkyPNG::Color::BLACK

    img = ChunkyPNG::Image.new(img_width + 1, img_height + 1, background)

    [:backgrounds, :walls].each do |mode|
      each_cell do |cell|
        cx = half_width + cell.column * half_width
        cy = half_height + cell.row * height

        west_x = (cx - half_width).to_i
        mid_x = cx.to_i
        east_x = (cx + half_width).to_i

        if cell.upright?
          apex_y = (cy - half_height).to_i
          base_y = (cy + half_height).to_i
        else
          apex_y = (cy + half_height).to_i
          base_y = (cy - half_height).to_i
        end

        if mode == :backgrounds
          color = background_color_for(cell)
          if color
            points = [[west_x, base_y], [mid_x, apex_y], [east_x, base_y]]
            img.polygon(points, color, color)
          end
        else
          unless cell.west
            img.line(west_x, base_y, mid_x, apex_y, wall)
          end

          unless cell.linked?(cell.east)
            img.line(east_x, base_y, mid_x, apex_y, wall)
          end

          no_south = cell.upright? && cell.south.nil?
          not_linked = !cell.upright? && !cell.linked?(cell.north)

          if no_south || not_linked
            img.line(east_x, base_y, west_x, base_y, wall)
          end
        end
      end
    end

    img
  end
#+END_SRC

我们再次使用 `size` 参数来描述三角形单边的长度 (第 1 行). 第 2-4 行然后取那个 `size` 值并用它来计算我们三角形的尺寸.

知道每个三角形的大小让我们能够测量我们画布的大小 (第 6 和 7 行).

第 16-29 行应该看起来很熟悉——它们使用我们之前描述的公式计算当前三角形的坐标.

接下来, 让我们看看这一切是否如我们所愿.

** 制作三角形 (Delta) 迷宫
Making Triangle (Delta) Mazes

就像六边形网格产生 sigma 迷宫一样, 三角形网格产生 *delta* 迷宫. (这个至少有点道理, 因为希腊字母 delta, Δ, 形状像一个三角形.) 不过, 再次强调, 你怎么称呼它没什么区别, 因为它最终只是制作迷宫的另一个脚手架!

让我们将我们的 `hex_maze.rb` 文件复制到 `delta_maze.rb` 并更改它以引用我们的新三角形网格:

#+BEGIN_SRC ruby
delta_maze.rb
require 'recursive_backtracker'
require 'triangle_grid'

grid = TriangleGrid.new(10, 17)
RecursiveBacktracker.on(grid)

grid.to_png.save('delta.png')
#+END_SRC

网格的尺寸是凭经验选择的, 以产生一个大致方形的画布. 除此之外, 这只是老一套——实例化一个网格, 在上面运行一个递归回溯算法, 并显示结果:

#+CAPTION: 一个 10x17 的三角形迷宫.

非常漂亮! 不过, 再一次, 你需要当心二叉树和 Sidewinder. 事实上, 二叉树尤其与这些三角形网格有真正的问题, 因为它想要在两个垂直方向之间选择...但我们的三角形网格只有 50% 的时间可以向北走. 如果你不是很小心, 你最终会得到网格中无法到达的区域. 如果你愿意, 可以用它实验一下, 看看会发生什么.

** 轮到你了
Your Turn

我们已经远远超出了我们早期制作纯矩形网格的迷宫制作时代. 在本章中, 我们看到了六边形和三角形如何被平铺以创建适合迷宫的设置, 我们瞥见了绘制这些更高级网格背后的一些数学知识.

这只是冰山一角, 不过! 有很多方法可以使用和变化这里介绍的内容. 下面只是几个想法, 可以帮助你瞥见在处理非矩形网格时的可能性.

*** 为非矩形迷宫着色
Coloring Non-Rectangular Mazes

为迷宫着色似乎总能给它们增添很多个性, 那些在非矩形网格上制作的也不例外. 本章中给出的 `to_png` 方法包含了为单个单元格着色所需的代码. 看看你是否能连接 `background_color_for` 方法来指定适当的颜色.

#+CAPTION: 一个着色的六边形迷宫.

*** 掩码
Masking

重温第 6 章, *将迷宫拟合到形状*, 第 83 页的技术, 看看要给这些不同的网格添加掩码需要什么. 你如何定义一个六边形掩码? 或者一个三角形掩码?

*** 塑造网格
Shaping Grids

要让你的三角形网格实际上是三角形形状需要什么? 一个六边形形状的六边形网格呢?

#+CAPTION: 一个三角形形状的三角形迷宫.

*** 不规则三角形
Irregular Triangles

为简单起见, 我们在本章中为我们的三角形网格使用了等边三角形. 如果你改变那个假设, 你会得到什么样的效果? 这需要一点数学来推导测量值, 但如果你准备好挑战, 看看你能用其他类型的三角形做什么.

*** 组合网格系统
Combining Grid Systems

绝对没有任何法律规定网格必须是同质的. 想象一个星形的网格, 由一个方形的常规网格在中心, 每个边缘都有三角形网格组成. 尝试将不同的形状组合在一起, 看看会发生什么.

*** 均匀平铺及其他
Uniform Tilings and Beyond

正方形、三角形和六边形都能很好地平铺, 但它们绝不是唯一能做到这一点的形状. 尝试研究*均匀平铺* (uniform tilings), 或 Wythoff 构造, 甚至 Voronoi 图, 你会看到还有一整个世界的其他可能的网格可以玩. 你会发现像*截断四边形* (truncated quadrille) 和*菱形三六边形* (rhombitrihexagonal) 这样的词, 这可能几乎足以让你去尝试一下.

*** Upsilon 迷宫
Upsilon Mazes

说到截断四边形, 这种特殊的平铺可以用来创建所谓的 *upsilon* 迷宫. 你创建一个由正八边形和正方形组成的平铺, 然后用你选择的算法在上面生成一个迷宫. 你最终会得到类似下面的东西:

#+CAPTION: 一个 upsilon 网格及其迷宫.

你将如何着手实现和显示这样的网格?

接下来, 我们将看看当我们 (终于!) 移除我们的迷宫必须是“完美的”, 或没有回路的约束时会发生什么. 我们还将开始触及多维迷宫的想法, 用一种伪 3D 效果, 结果非常直接.

* 第 9 章：编织和交织你的迷宫
*Braiding and Weaving Your Mazes*

到目前为止, 我们都假设我们所有的迷宫都是*完美*的——也就是说, 它们没有回路. 我们说过, 从迷宫中的一个点到任何其他点, 必须只有一条绝不允许自我相交的单一路径.

可悲的事实是, 大多数真实环境实际上都不是完美的迷宫. 无论你是在图书馆的书架间穿梭, 还是在城镇的街道上行走, 你通常都可以通过多种可能的路线从一个地方到达另一个地方. 这在视频游戏中得到了体现: 例如, 在《吃豆人》(Pac-Man) 中, 你可以从一条路进入一个区域, 然后从另一条路返回, 巧妙地躲避你尾随的鬼魂. 地下城探索游戏 (如《NetHack》) 和“开放世界”游戏 (如《塞尔达传说》, 《最终幻想》) 让你在使用各种路径在区域之间移动时有相当大的自由度. 像《毁灭战士》(Doom), 《雷神之锤》(Quake) 和《天旋地转》(Descent) 这样的第一人称射击游戏使用带有回路的迷宫来支持各种出色的战术场景. 从游戏设计的角度来看, 允许路径自我相交可以为游戏的玩法开辟令人兴奋的新方式.

所以是时候稍微改变一下了. 我们将研究两种不同的方法来放宽那条“无自我相交”的规则: 通过移除死胡同从而在我们的迷宫中添加回路的*编织* (braiding), 以及允许通道通过相互上下移动来相交的*交织* (weaving).

让我们从编织开始.

** 编织迷宫
Braiding Mazes

没有死胡同的迷宫被称为*辫状迷宫* (braid maze).

不过, 这没有必要非得是全有或全无. 迷宫可以是重度编织的 (所有或大部分死胡同被移除), 轻度编织的 (只有少数死胡同被移除), 或者介于两者之间的任何状态. 我们在这里将要考虑的过程, 称为*死胡同剔除* (dead-end culling), 将让我们能够制作出任何我们想要的编织程度的迷宫.

回想一下, 在*计算死胡同*, 第 71 页中, 我们向 `Grid` 添加了一个方法, 恰如其分地命名为 `deadends`. 我们让它返回网格中所有死胡同单元格的列表, 并用它来根据生成的死胡同数量来比较迷宫算法.

事实证明, 我们在这里可以使用同样的方法. 一旦它告诉我们死胡同在哪里, 剔除或移除它们的过程就很直接了: 我们只需要将每个死胡同单元格链接到一个额外的邻居. 这实际上擦除了它的一堵墙, 并在迷宫中增加了一个回路. 遵循这个逻辑, 这也意味着辫状迷宫不是一个完美的迷宫——它将总有至少一个回路.

让我们来实现这个. 感谢我们的 `deadends` 方法, 我们已经完成了一半. 剩下要做的就是遍历它返回的单元格, 并将每一个链接到一个随机的邻居. 我们将把这个责任交给 `Grid` 上的一个新方法, 所以请打开 `grid.rb` 并在那个类中添加以下方法.

#+BEGIN_SRC ruby
  def braid(p=1.0)
    deadends.shuffle.each do |cell|
      next if cell.links.count != 1 || rand > p

      neighbors = cell.neighbors.reject { |n| cell.linked?(n) }
      best = neighbors.select { |n| n.links.count == 1 }
      best = neighbors if best.empty?

      neighbor = best.sample
      cell.link(neighbor)
    end
  end
#+END_SRC

在上一章的所有数学之后, 这令人耳目一新! 第 2 行通过获取死胡同列表, 对其进行良好的洗牌, 然后遍历结果来开始. 对于每个单元格, 我们首先测试 (在第 3 行) 它是否仍然是一个死胡同 (因为循环的早期迭代可能已经将其链接到一个相邻的死胡同). 我们还允许部分辫状迷宫, 方法是生成一个介于 0 和 1 之间的随机数 (使用标准的 `rand` 方法) 并将其与 `p` 参数进行比较. 默认情况下, `p` 是 1.0, 确保所有的死胡同都将被剔除, 但通过使数字变小 (比如, 0.5), 被移除的就会更少.

假设单元格被认为是可接受的, 第 5 行会找到所有它尚未链接的邻居. 这些构成了我们将要链接的潜在单元格集合.

下一行, 第 6 行, 是一种优化. 我们可以一石二鸟, 通过优先将两个死胡同单元格链接在一起来稍微改善迷宫的美感. 这一行检查潜在邻居单元格的集合, 并选出那些本身就是死胡同的. 如果可能, 我们将从这个集合中选择, 但如果该集合是空的, 我们就退回到所有邻居的集合 (第 7 行).

一旦我们最终确定了我们可能的邻居集合, 剩下要做的就是选择一个 (第 9 行) 并将其链接到当前单元格.

现在测试起来很容易. 选择我们到目前为止编写的任何一个迷宫程序, 并在运行迷宫算法之后 (以及显示迷宫之前) 添加以下行:

#+BEGIN_SRC ruby
grid.braid(0.5)
#+END_SRC

这将在显示迷宫之前剔除大约一半的死胡同. 假设我们将此添加到我们为递归回溯算法编写的程序中 (在 `recursive_backtracker_demo.rb` 中), 我们应该会得到类似下图的东西.

#+CAPTION: 一个被编织以移除大约一半死胡同的迷宫.

就这样. 编织好了! 更重要的是, 我们现有的 Dijkstra 算法实现 (来自第 3 章, *寻找解法*, 第 35 页) 仍然有效.

让我们试一试. 如果我们打开 `dijkstra.rb` 或 `longest_path.rb` (来自*寻找解法*) 并在那里, 就在迷宫生成之后, 添加 `grid.braid`, 我们应该会发现距离仍然都计算正确. 例如, `dijkstra.rb` 程序将仍然向我们显示完整的距离矩阵, 正如预期的那样.

#+BEGIN_SRC sh
$ ruby -I. dijkstra.rb
+---+---+---+---+---+
| 0   1 | a   b   a |
+   +   +   +---+   +
| 1 | 2 | 9   8   9 |
+   +   +---+   +   +
| 2 | 3   4 | 7 | a |
+   +---+   +   +   +
| 3   4   5   6 | 9 |
+   +---+---+   +   +
| 4   5   6   7   8 |
+---+---+---+---+---+
#+END_SRC

它就是能行! 你可以看到 Dijkstra 算法是如何挑选出到每个单元格的所有可能路径中最短的一条, 就像水流绕过障碍物一样. 我们在 `Distances` 上的 `path_to` 方法 (同样来自*寻找解法*) 也“就是能行”, 使用 Dijkstra 算法的距离矩阵来找到到给定单元格的最短路径, 甚至在多个最短路径之间成功地做出选择! 无论是否编织, 我们仍然可以告诉我们的朋友这些迷宫的答案.

不过, 辫状迷宫允许一种特殊可能性, 这遗憾地也对我们简化的 Dijkstra 算法造成了破坏. 当你开始询问一条路径相对于另一条路径的*相对成本*, 而不仅仅是距离时, 事情就变得有点复杂了. 让我们接下来看看那个.

** 成本 vs. 距离
Cost versus Distance

想象一下穿越一个迷宫, 你来到了通道的一个分叉处. 两条路都绕了一圈后在不远处又汇合了, 但左边的通道被一池熔岩堵住了. 右边的通道没有熔岩, 但比另一条长得多. 哪条路能让你更快地到达出口?

#+CAPTION: 一个带有昂贵捷径的迷宫.

嗯, 这当然要看情况. 但对于没有特殊熔岩抗性的普通人来说, 走没有熔岩的路可能是最佳选择, 即使它更长. 有熔岩的路, 虽然更短, 但*更昂贵*.

像这样的成本被称为*权重* (weights). 距离本身就是一种权重, 因为如果其他所有条件都相同, 一条更长的路径将比一条更短的路径更昂贵. 我们目前实现的 Dijkstra 算法假设所有单元格的权重都相等, 这意味着唯一被测量的成本是距离. 如果我们能给我们的辫状迷宫添加熔岩障碍就好了, 所以让我们看看我们能做些什么来解决这个问题.

仔细看看我们实现的 Dijkstra 算法, 当引入权重时它就出问题了, 因为距离不再是成本的可靠指标. 再考虑一下我们的熔岩例子. 我们简化的 Dijkstra 实现会愉快地沿着两条路径一步一步地跳跃, 沿途累加成本. 问题是算法会先通过更短 (但更昂贵) 的通道到达出口, 并相应地标记其成本.

我们需要从一个完全不同的方向来处理这个问题. 与其使用一个*前沿* (frontier) 集, 模拟一个波浪在网格中移动的前沿, 算法的每次迭代都需要选择尚未处理的成本最低的单元格. 让我们用我们的熔岩例子来直观地考虑这个问题. 当我们刚开始时, 我们将我们的起始单元格标记为成本 0, 并将它添加到一个队列中. 其他一切都是未定义的.

#+CAPTION: Dijkstra 算法从成本为 0 的单元格开始.

因此, 当算法开始其主循环时, 它只有一个单元格可以选择. 它从那个队列中取出它, 计算它唯一邻居的成本, 并将那个邻居添加到队列中.

#+CAPTION: 算法移动到下一个单元格, 成本为 1.

下一次, 我们的队列中仍然只有一个单元格——我们刚刚添加的那个. 算法将其取出并计算其每个邻居的成本. 两个邻居都进入队列, 准备好进行下一次迭代.

#+CAPTION: 算法到达一个分叉口, 两个邻居都被添加到队列中.

这一次, 算法必须在两个标记为 2 的单元格之间做出选择. 任何一个都可以, 但让我们说它选择了与熔岩相邻的单元格. 好的: 那个单元格被从队列中取出, 它的邻居的成本被计算出来, 并且邻居被添加到队列中. 但热熔岩是热的, 穿过那个鸿沟将是昂贵的. 让我们说它给那条路径的成本增加了五十.

#+CAPTION: 一条路径的成本很高 (52), 而另一条路径的成本很低 (2).

下一次, 队列中包含一个标记为 2 的单元格, 和一个标记为 52 的单元格. 哪个单元格的成本最低是显而易见的! 算法拿起标记为 2 的那个, 将其从队列中移除, 计算其邻居的成本 (现在是 3), 并将那个邻居添加到队列中.

#+CAPTION: 算法继续沿着成本最低的路径前进.

熔岩单元格不会很快被算法选中——那么高的成本足以吓跑即使是最勇敢的冒险家. 最终, 算法会发现最便宜的路线确实是完全绕过熔岩, 即使那条路长得多.

#+CAPTION: 最便宜的路径绕过了昂贵的障碍物.

到最后, 队列中剩下的唯一一个单元格将是那个熔岩单元格, 算法最终会选择它. 不过, 到那时, 熔岩的所有邻居单元格都已经处理完毕, 并且所有单元格的成本都会比熔岩产生的成本低, 所以该单元格在未使用的情况下被丢弃. 之后, 队列为空, 算法终止.

让我们在代码中看看它, 并用一些我们自己的熔岩坑来挑逗几个迷宫.

** 实现一个有成本意识的 Dijkstra 算法
Implementing a Cost-Aware Dijkstra’s Algorithm

为了让这个在代码中工作, 我们需要两样东西: 一个可以被赋予权重的单元格, 和一个由这些加权单元格组成的网格.

单元格很简单. 我们将子类化 `Cell` 并向其添加权重信息. 此外, 由于我们的 Dijkstra 算法是在 `Cell` 上实现的, 我们通过覆盖原始的 `distances` 方法, 将我们更新的实现也放在子类中.

将以下内容放入 `weighted_cell.rb`.

#+BEGIN_SRC ruby
weighted_cell.rb
require 'cell'

class WeightedCell < Cell
  attr_accessor :weight

  def initialize(row, column)
    super(row, column)
    @weight = 1
  end

  def distances
    weights = Distances.new(self)
    pending = [ self ]

    while pending.any?
      cell = pending.sort_by { |c| weights[c] }.first
      pending.delete(cell)

      cell.links.each do |neighbor|
        total_weight = weights[cell] + neighbor.weight
        if !weights[neighbor] || total_weight < weights[neighbor]
          pending << neighbor
          weights[neighbor] = total_weight
        end
      end
    end

    weights
  end
end
#+END_SRC

我们的构造函数只是通过将默认单元格权重设置为 1 来扩展前一个. 不过, 新的 `distances` 方法才是这里特别有趣的地方.

和以前一样, 我们使用我们的 `Distances` 类来跟踪每个单元格的成本, 但现在我们有一个 `pending` 集, 而不是一个 `frontier` 集, 它跟踪哪些单元格尚未被处理. 我们在第 13 行将其初始化为一个只包含 `self`——我们请求计算距离的单元格——的数组. 然后我们重复以下步骤, 直到该数组为空 (第 15 行).

循环的每次传递都会搜索那个 `pending` 集, 寻找成本最低的单元格 (第 16 行), 然后移除它找到的那个单元格. 这个单元格是我们的*当前单元格*.

#+BEGIN_QUOTE
 * 优先队列
Priority Queues

为简单起见, 我们在这里使用一个数组, 但这不是一个非常有效的方法. 我们必须在每次迭代中搜索那个数组, 这可能会变得昂贵. 一种更好的方法是使用一个*优先队列* (priority queue), 它为你提供了一种非常有效的方式来按权重查找和存储项目. 它是一个可爱的数据结构, 但遗憾地超出了本书的范围.
#+END_QUOTE

下一个循环 (第 19 行) 查看链接到当前单元格的每个单元格. 对于每一个, 我们计算从起始单元格开始的路径的累积权重 (第 20 行), 然后检查这是否比之前为该邻居记录的任何权重都好 (第 21 行). 如果是, 我们将该邻居添加到待处理列表, 并更新其累积权重.

我们将把这个新单元格插入到一个新的 `Grid` 子类中, 我们将用一种实际显示这些权重的方式来装饰它, 以及显示我们正在计算的距离. 为此, 我们将转向我们的 `background_color_for(cell)` 方法.

将以下内容放入 `weighted_grid.rb`. 它将从我们第 3 章, *寻找解法*, 第 35 页的 `colored_grid.rb` 实现中借用一些部分, 所以如果其中一些已经有点熟悉了, 不要感到惊讶.

#+BEGIN_SRC ruby
weighted_grid.rb
require 'chunky_png'
require 'grid'
require 'weighted_cell'

class WeightedGrid < Grid
  attr_reader :distances

  def distances=(distances)
    @distances = distances
    farthest, @maximum = distances.max
  end

  def prepare_grid
    Array.new(rows) do |row|
      Array.new(columns) do |column|
        WeightedCell.new(row, column)
      end
    end
  end

  def background_color_for(cell)
    if cell.weight > 1
      ChunkyPNG::Color.rgb(255, 0, 0)
    elsif @distances
      distance = @distances[cell] or return nil
      intensity = 64 + 191 * (@maximum - distance) / @maximum
      ChunkyPNG::Color.rgb(intensity, intensity, 0)
    end
  end
end
#+END_SRC

`distances=` 方法用于告诉网格关于活动的距离矩阵, 以便在着色网格时使用, 而 `prepare_grid` 几乎与 `Grid` 中的原始版本相同, 只是为每个单元格实例化我们的 `WeightedCell` 类 (第 16 行).

`background_color_for(cell)` 方法承担了比我们过去给它的更多的责任. 我们将让它将任何权重大于一的单元格涂成红色 (第 23 行). 这将让我们能够直观地看到那些加权单元格在哪里. 对于任何没有被特别加权的单元格, 如果设置了距离图, 我们将让它退回到根据距离图选择颜色. 我们将把那些距离涂成黄色的阴影 (第 27 行).

就是这样! 现在我们可以组合一个简单的程序来测试我们所拥有的. 让我们让它在这些加权网格之一上生成一个迷宫, 并显示从西北角到东南角的最便宜路径. 然后, 我们将在那条路径的某个地方添加一个熔岩坑 (即一个权重很重的单元格).

#+BEGIN_SRC ruby
weighted_maze.rb
require 'weighted_grid'
require 'recursive_backtracker'

grid = WeightedGrid.new(10, 10)
RecursiveBacktracker.on(grid)

grid.braid 0.5
start, finish = grid, grid

grid.distances = start.distances.path_to(finish)
filename = "original.png"
grid.to_png.save(filename)
puts "saved to #{filename}"

lava = grid.distances.cells.sample
lava.weight = 50

grid.distances = start.distances.path_to(finish)
filename = "rerouted.png"
grid.to_png.save(filename)
puts "saved to #{filename}"
#+END_SRC

程序的前半部分只是实例化我们的 `WeightedGrid` 并在其上执行一个递归回溯算法. 第 7 行移除了半数的死胡同, 然后第 10-13 行计算并显示我们起点和终点单元格之间的最短路径, 将生成的迷宫绘制到 `original.png`.

然后我们变得邪恶起来, 在上面扔了一些熔岩. `grid.distances` 属性在那个点已经包含了最短 (最便宜) 路径中所有单元格的映射, 所以第 15-16 行选择那些单元格中的一个并将其权重设置为 50. (记住, 熔岩是热的. 它至少值那么多.)

我们通过重新计算最短路径并写入生成的迷宫到 `rerouted.png` (第 18-21 行) 来完成程序.

运行它应该会生成那两个图像, `original.png` 和 `rerouted.png`, 然后我们可以打开并比较它们. 不过请注意, 因为程序是盲目地选择路径中的任何单元格, 它可能偶尔会选择一个 Dijkstra 算法无法绕过的单元格 (比如起点, 或目标). 如果发生这种情况, 只需再次运行它, 直到它实际上选择一个有趣的单元格来放置熔岩, 类似这样:

#+CAPTION: 一个有熔岩坑之前和之后的迷宫, 显示了重新路由的路径.

这些加权网格有潜力. 除了沸腾的熔岩坑, 你还可以使用门 (锁着的和其他的)、落石、食人鱼出没的水域, 以及任何其他数量的东西来改变个别路径的成本. 讨论如何最好地随机放置它们超出了本书的范围, 遗憾的是, 但这是一个令人兴奋的实验!

不过, 时间不等人. 我们已经看了辫状迷宫, 改变了我们关于完美迷宫没有回路的假设. 接下来, 我们将看另一种改变那些假设的方法, 允许通道通过相互上下移动来相交.

** 介绍交织和内衬
Introducing Weaves and Insets

一个*交织迷宫* (weave maze) 是一个通道相互上下交织的迷宫, 就像一碗意大利面里的面条一样.

#+CAPTION: 图 5—一个交织迷宫

我们无法用我们现有的 `to_png` 方法真正地画出这些, 因为我们现有的方法不在相邻走廊之间画任何空间. 没有那个空间, 就有太多的模糊性——我们无法判断一个通道是死胡同, 还是走到了另一个通道下面. 下图显示了与前一个图相同的迷宫, 但走廊之间没有任何间隙.

#+CAPTION: 一个没有间隙的交织迷宫, 难以辨认.

乱七八糟! 更糟的是, 它不是很准确. 我们现有的 `to_png` 实现只为每个单元格画东墙和南墙, 轻率地假设邻居会在其他墙上弥补不足. 这对于这些上下交织的迷宫是行不通的. 有些东西得改.

那么, 我们的首要任务是升级我们的 `to_png` 方法以支持走廊之间的间隙. 幸运的是, 这并不难——它只需要一点额外的测量. 我们需要弄清楚每堵墙离单元格的原始边缘*内衬* (inset) 多远. 一旦我们有了这种新的绘制迷宫的方式, 我们就可以看看让通道上下交织需要什么.

让我们看看我们网格上的一个单元格, 用这些内衬绘制. 从这个图中, 我们将能够推断出我们需要绘制我们的迷宫这种方式所需的测量值.

#+CAPTION: 一个带有内衬的单元格.

在这里, 单元格与其北部和东部的邻居相连, 在那些方向上有相应的通道. 内衬用黄色高亮显示, 虚线将单元格分成九个不同的区域. 我们不打算担心角落的四个区域——当我们用这种方式渲染单元格时, 那些将总是死空间. 为讨论起见, 让我们像这样标记剩余的区域:

#+CAPTION: 一个单元格被分为 N, S, W, E 和 C (中心) 区域.

我们想要绘制的每一堵墙都将在那些虚线上 (\(x_1\)–\(x_4\) 和 \(y_1\)–\(y_4\)), 所以要画它们, 我们需要这些线的坐标. 如果单元格是一边 `size` 个单位, 西北角在 (x,y), 我们用 `inset` 来描述我们间隙的大小, 那么我们想要的坐标是

#+BEGIN_SRC text
x1 = x
x4 = x + size
x2 = x1 + inset
x3 = x4 - inset

y1 = y
y4 = y + size
y2 = y1 + inset
y3 = y4 - inset
#+END_SRC

参考前一个图, 我们现在可以说 (例如) C 的西南角在 (\(x_2,y_3\)).

让我们接下来在代码中实现这个. 我们将保留尽可能多的现有 `to_png` 实现, 但我们会将其核心部分分解成一个单独的方法, 一个在没有指定 (或为零) 内衬时专门使用的方法. 然后我们将添加另一个方法来计算内衬坐标, 以及第三个方法, `to_png` 将在*有*指定内衬时委托给它.

打开 `grid.rb`, 并将 `to_png` 更改为如下所示. 高亮的行是我们特别要更改的.

#+BEGIN_SRC ruby
  def to_png(cell_size: 10, inset: 0)
    img_width = cell_size * columns
    img_height = cell_size * rows
    inset = (cell_size * inset).to_i

    background = ChunkyPNG::Color::WHITE
    wall = ChunkyPNG::Color::BLACK

    img = ChunkyPNG::Image.new(img_width + 1, img_height + 1, background)

    [:backgrounds, :walls].each do |mode|
      each_cell do |cell|
        x = cell.column * cell_size
        y = cell.row * cell_size

        if inset > 0
          to_png_with_inset(img, cell, mode, cell_size, wall, x, y, inset)
        else
          to_png_without_inset(img, cell, mode, cell_size, wall, x, y)
        end
      end
    end

    img
  end
#+END_SRC

在第一个高亮的行上, 我们根据传入的选项计算内衬的大小. 如果没有指定内衬, 它默认为零, 否则它被解释为应该给予每个内衬的单元格总大小的分数. 例如, 如果给出一个 0.25 的内衬, 那将导致每个内衬占据单元格边距的四分之一, 为单元格本身留下一半的单元格宽度和高度.

另一个主要的变化与如何处理每个单元格有关. 在第二个高亮的区域, 我们检查计算出的内衬是否大于零, 如果是, 我们就委托给一个新的 `to_png_with_inset` 方法 (稍后会定义). 否则, 流程会落到下一行, 调用 `to_png_without_inset`. 让我们接下来看看那个; 它也应该被添加到 `Grid`, 在我们新的 `to_png` 方法下面.

#+BEGIN_SRC ruby
  def to_png_without_inset(img, cell, mode, cell_size, wall, x, y)
    x1, y1 = x, y
    x2 = x1 + cell_size
    y2 = y1 + cell_size

    if mode == :backgrounds
      color = background_color_for(cell)
      img.rect(x, y, x2, y2, color, color) if color
    else
      img.line(x1, y1, x2, y1, wall) unless cell.north
      img.line(x1, y1, x1, y2, wall) unless cell.west
      img.line(x2, y1, x2, y2, wall) unless cell.linked?(cell.east)
      img.line(x1, y2, x2, y2, wall) unless cell.linked?(cell.south)
    end
  end
#+END_SRC

这应该很熟悉——它几乎是我们旧 `to_png` 方法中 `each_cell` 块内的内容的逐字记录. 它只是计算单元格的西北角和东南角, 并绘制相应的墙壁.

接下来, 我们将实现我们前一节的公式来找到那些虚线水平和垂直线的 x 和 y 坐标.

#+BEGIN_SRC ruby
  def cell_coordinates_with_inset(x, y, cell_size, inset)
    x1, x4 = x, x + cell_size
    x2 = x1 + inset
    x3 = x4 - inset

    y1, y4 = y, y + cell_size
    y2 = y1 + inset
    y3 = y4 - inset

    [x1, x2, x3, x4,
     y1, y2, y3, y4]
  end
#+END_SRC

我们当然可以在下面的方法 (`to_png_with_inset`) 中内联这段代码, 但将它作为一个单独的方法在我们需要在章节后面绘制交织迷宫时会很有用.

我们最后一个方法是消耗那些内衬坐标并绘制墙壁的部分.

#+BEGIN_SRC ruby
  def to_png_with_inset(img, cell, mode, cell_size, wall, x, y, inset)
    x1, x2, x3, x4, y1, y2, y3, y4 =
      cell_coordinates_with_inset(x, y, cell_size, inset)

    if mode == :backgrounds
      # ...
    else
      if cell.linked?(cell.north)
        img.line(x2, y1, x2, y2, wall)
        img.line(x3, y1, x3, y2, wall)
      else
        img.line(x2, y2, x3, y2, wall)
      end

      if cell.linked?(cell.south)
        img.line(x2, y3, x2, y4, wall)
        img.line(x3, y3, x3, y4, wall)
      else
        img.line(x2, y3, x3, y3, wall)
      end

      if cell.linked?(cell.west)
        img.line(x1, y2, x2, y2, wall)
        img.line(x1, y3, x2, y3, wall)
      else
        img.line(x2, y2, x2, y3, wall)
      end

      if cell.linked?(cell.east)
        img.line(x3, y2, x4, y2, wall)
        img.line(x3, y3, x4, y3, wall)
      else
        img.line(x3, y2, x3, y3, wall)
      end
    end
  end
#+END_SRC

第 3 行调用我们的 `cell_coords_with_inset` 方法来获取那八个坐标. 有了这些, 我们就可以开始绘制当前单元格的适当墙壁了.

#+BEGIN_QUOTE
 * 实现背景模式
Implementing Background Mode

为简洁起见, 我没有包括 `to_png_with_inset` 的背景模式的实现. 不过, 这并不难: 本质上, 它要求你为那些先前图中的每个标记区域 (N, S, E, W, 和 C) 填充一个矩形, 取决于哪些需要被绘制. 如果你愿意, 可以把它当作一个机会!
#+END_QUOTE

墙壁的绘制发生在第 8-34 行. 对于每个潜在的邻居, 我们检查邻居是否已被链接, 如果是, 就在那个方向上绘制一个走廊. 否则, 我们画一堵墙.

有了那些更改, 我们应该能够绘制一个墙壁之间有间隙的迷宫. 选择我们到目前为止编写的任何一个程序 (比如 `recursive_backtracker_demo.rb` 或 `aldous_broder_demo.rb`), 并更改 `to_png` 方法的调用以包括内衬规范, 类似这样:

#+BEGIN_SRC ruby
grid.to_png(inset: 0.1).save("filename.png")
#+END_SRC

这将导致每个间隙占据每个单元格宽度和高度的十分之一. 假设我们像那样更改 `recursive_backtracker_demo.rb` 程序, 输出应该看起来像这样:

#+CAPTION: 一个带有内衬的迷宫.

我们在正确的轨道上! 这足够好了——现在让我们回到讨论交织迷宫.

** 生成交织迷宫
Generating Weave Mazes

事实证明, 生成交织迷宫与生成普通迷宫并没有太大区别. 诀窍在于弄清楚如何表示那些在其他通道下面的隧道. 一旦我们解决了这些问题, 我们将研究一个新的 `Grid` 子类, 并做一些更多的 `to_png` 调整, 这样我们就可以绘制这些新的隧道通道了.

为了了解这些新通道是如何工作的, 让我们花点时间回顾一下图 5, *一个交织迷宫*, 第 138 页. 注意通道是如何以及何时相互上下交织的. 这并非完全任意——有四个重要的规则使这项工作明确无误.

-   *通道不能在另一个通道之上或之下死胡同.*
    这可以防止当一个通道似乎在另一个通道下面消失时可能发生的混淆.
-   *上下通道必须相互垂直.*
    一个通道不允许与它正在隧道下的通道完全平行移动. 否则, 再次, 会因为通道似乎消失而产生混淆.
-   *通道在其他通道之上或之下时不能改变方向.*
    一个走廊不能在向北移动时在一个单元格下隧道, 然后在向东移动时离开该单元格. 这与前一条规则有关——上下通道必须是完全垂直的.
-   *一个通道不能一次在两个连续的通道下隧道.*
    这更多是为了让我们自己更容易, 而不是出于任何真正的技术必要性. 这样实现起来更简单.

与其废弃我们到目前为止编写的所有那些可爱的代码, 如果我们能通过扩展我们现有的网格框架来让这个工作, 那就太好了.

甚至更好, 如果我们能把一个新的网格子类放入 (例如) 我们的递归回溯程序中, 并且让它生成交织迷宫而无需进一步调整, 那将是美妙的.

我们将像这样处理它. 让我们想象一下, 当一个通道在另一个通道下面移动时, 它实际上是移动到那个相同位置的一个不可见的单元格, 在另一个单元格的*下面*, 像这样:

#+CAPTION: 一个显示通道如何在另一个通道下面隧道的图示.

为讨论起见, 我们将把这些幻影单元格称为*下方单元格* (under-cells), 它们上面的单元格称为*上方单元格* (over-cells). 如果我们能让我们的网格透明地管理这些下方单元格, 而不向外部暴露任何关于它们的信息, 那么我们到目前为止看到的大多数迷宫算法都应该能正常工作, 无需进一步更改. 问题是, 这些下方单元格中相对较少的一部分会真正在迷宫中使用, 并且有一些严格的规则决定了哪些上方单元格可以容纳下方单元格. 由于这些原因, 事实证明最简单的方法是在满足某些条件时按需创建它们. 这些条件在决定给定单元格 (无论是上方单元格还是下方单元格) 存在哪些邻居时适用, 如下所示:

-   一个下方单元格不能被放置在另一个下方单元格的下面. (如果我们开始像那样嵌套它们, 迷宫会变得很难清晰地绘制, 到那时我们还不如制作真正的 3D 迷宫. 我们将在第 13 章, *将迷宫扩展到更高维度*, 第 209 页讲到那些.)
-   当考虑东边和西边的邻居时, 检查那些上方单元格中是否有任何一个是已经是*垂直通道*, 即纯粹南北向运行的通道. 如果是, 我们可以在其下方创建一个下方单元格, 并向那个方向再隧道一个单元格.
-   同样, 当考虑北边和南边的邻居时, 检查它们中是否有任何一个是已经是*水平通道*, 即东西向运行的通道. 如果是, 我们可以在那里创建一个下方单元格, 以便向那个方向隧道.
-   在任何一种情况下, 我们只有在另一侧确实有另一个单元格时才能在单元格下隧道. 隧道永远不应该让我们出界. (我们不是在这里重演*大逃亡*!)

我们将通过子类化 `Cell` 来实现这一点. 最终我们会有两种不同的单元格类型 (一种用于上方单元格, 一种用于下方单元格), 但我们将从上方单元格开始. 让我们通过覆盖 `neighbors` 方法来包含前面的逻辑.

*** 实现 OverCell 类
Implementing the OverCell Class

以下是我们新 `OverCell` 类的开始. 让我们把它放入 `weave_cells.rb`.

#+BEGIN_SRC ruby
weave_cells.rb
require 'cell'

class OverCell < Cell
  def neighbors
    list = super
    list << north.north if can_tunnel_north?
    list << south.south if can_tunnel_south?
    list << east.east if can_tunnel_east?
    list << west.west if can_tunnel_west?

    list
  end
#+END_SRC

在第 5 行调用 `super` 会给我们由我们原始的 `Cell` 类计算出的默认邻居集. 然后我们向那个列表追加, 添加要隧道的潜在目标. 例如, 在第 6 行, 我们添加这个单元格北邻居的北邻居, 只要可以向北隧道.

那些辅助方法 (`can_tunnel_north?` 和朋友们) 需要接下来定义. 在我们新的 `neighbors` 方法之后添加这些.

#+BEGIN_SRC ruby
  def can_tunnel_north?
    north && north.north &&
      north.horizontal_passage?
  end

  def can_tunnel_south?
    south && south.south &&
      south.horizontal_passage?
  end

  def can_tunnel_east?
    east && east.east &&
      east.vertical_passage?
  end

  def can_tunnel_west?
    west && west.west &&
      west.vertical_passage?
  end
#+END_SRC

这里我们编码了决定是否甚至可能在给定方向上隧道的逻辑. 以 `can_tunnel_north?` 方法为例. 我们只能从当前单元格向北隧道, 如果北边存在一个单元格, 那个邻居有一个北邻居, 并且是一个水平通道 (东西向).

我们接下来将添加那两个最后的辅助方法, `horizontal_passage?` 和 `vertical_passage?`.

#+BEGIN_SRC ruby
  def horizontal_passage?
    linked?(east) && linked?(west) &&
      !linked?(north) && !linked?(south)
  end

  def vertical_passage?
    linked?(north) && linked?(south) &&
      !linked?(east) && !linked?(west)
  end
#+END_SRC

这些并不太棘手. 如果一个单元格与其东、西邻居相连, 但不与其南、北邻居相连, 那么它就是一个水平通道. 垂直通道的定义类似.

好了. 我们的 `OverCell` 现在报告所有潜在的邻居, 包括那些需要一个下方单元格来隧道到它们的, 所以依赖于 `neighbors` 方法的算法 (比如 Recursive Backtracker 和 Aldous-Broder) 会自动被告知.

下一部分是确保当那些算法试图将一个单元格链接到一个需要隧道的邻居时, 我们添加了适当的下方单元格.

这需要再做一些更改. 其一, 我们需要让网格本身负责添加下方单元格, 因为它需要跟踪所有单元格以便绘制它们. 但要请求网格创建一个新的下方单元格, 单元格需要有一个对网格的引用!

让我们给它一个. 把这个构造函数方法放在我们 `OverCell` 类的顶部.

#+BEGIN_SRC ruby
  def initialize(row, column, grid)
    super(row, column)
    @grid = grid
  end
#+END_SRC

现在我们给了单元格一个对网格的句柄, 让我们覆盖 `link(cell)` 方法. 这就是我们将检查被链接的单元格是否需要一个隧道, 如果需要, 创建一个新的下方单元格作为两个单元格之间的链接的地方.

在 `weave_cells.rb` 中, 就在我们添加的那些辅助方法之后, 放入以下内容.

#+BEGIN_SRC ruby
  def link(cell, bidi=true)
    if north && north == cell.south
      neighbor = north
    elsif south && south == cell.north
      neighbor = south
    elsif east && east == cell.west
      neighbor = east
    elsif west && west == cell.east
      neighbor = west
    end

    if neighbor
      @grid.tunnel_under(neighbor)
    else
      super
    end
  end
#+END_SRC

别被这个方法的长度骗了——这里真的没发生什么事. 它的大部分, 第 2-10 行, 只是检查当前单元格和目标单元格之间是否存在一个共同的邻居. 如果有, 那么目标需要一个在那个位置的下方单元格来链接到它. 以第一个 if 语句为例 (第 2 行): 如果当前单元格的北邻居与目标单元格的南邻居相同, 我们就知道它们共同的那个邻居需要容纳一个下方单元格来将它们链接在一起.

那个下方单元格将由对网格的 `tunnel_under(over_cell)` 方法的调用创建, 在第 13 行. 稍安勿躁——我们很快就会讲到那个方法. 首先我们需要谈谈 `OverCell` 的姐妹类: 更简单的 `UnderCell`!

*** 实现 UnderCell 类
Implementing the UnderCell Class

`UnderCell` 不需要像 `OverCell` 那样管理那么多. 我们只需要它将自己插入到适当的单元格之间. 其他一切都将由网格或 `OverCell` 处理.

将以下内容添加到 `weave_cells.rb`, 在我们 `OverCell` 类的定义之后.

#+BEGIN_SRC ruby
class UnderCell < Cell
  def initialize(over_cell)
    super(over_cell.row, over_cell.column)

    if over_cell.horizontal_passage?
      self.north = over_cell.north
      over_cell.north.south = self
      self.south = over_cell.south
      over_cell.south.north = self
      link(north)
      link(south)
    else
      self.east = over_cell.east
      over_cell.east.west = self
      self.west = over_cell.west
      over_cell.west.east = self
      link(east)
      link(west)
    end
  end

  def horizontal_passage?
    east || west
  end

  def vertical_passage?
    north || south
  end
end
#+END_SRC

构造函数接受将要位于该单元格下方的上方单元格作为输入, 并将该上方单元格的坐标传递给原始构造函数 (第 3 行). 这使我们的新下方单元格与网格中的相同位置共存. 然后, 根据上方单元格是否是水平通道, 下方单元格将自己插入到将要链接到它的两个邻居之间 (水平上方单元格的第 6-9 行, 否则为第 14-17 行). 最后, 它将自己链接 (可以这么说, 开辟通道) 到适当的邻居.

`UnderCell` 类也实现了 `horizontal_passage?` 和 `vertical_passage?`, 以便我们的单元格不必关心它们的邻居是 `OverCell` 还是 `UnderCell` 实例. (多态性是不是很棒?)

*** 实现 WeaveGrid 类
Implementing the WeaveGrid Class

剩下要做的就是实现我们的 `WeaveGrid` 类, 它管理这两种不同的单元格类型. 我们将把我们的新类放入 `weave_grid.rb`.

#+BEGIN_SRC ruby
weave_grid.rb
require 'grid'
require 'weave_cells'

class WeaveGrid < Grid
  def initialize(rows, columns)
    @under_cells = []
    super
  end

  def prepare_grid
    Array.new(rows) do |row|
      Array.new(columns) do |column|
        OverCell.new(row, column, self)
      end
    end
  end

  def tunnel_under(over_cell)
    under_cell = UnderCell.new(over_cell)
    @under_cells.push under_cell
  end

  def each_cell
    super
    @under_cells.each do |cell|
      yield cell
    end
  end
end
#+END_SRC

构造函数没有添加太多, 只是初始化一个新数组 (第 6 行), 该数组将用于存放被创建的下方单元格. 那些单元格的创建由 `tunnel_under` 方法管理, 在第 18 行. 我们还需要确保我们的 `each_cell` 方法不忽略下方单元格 (第 26 行). 它需要报告网格中的每个单元格, 包括下方单元格.

那将足以*创建*一个交织迷宫, 但它还不能绘制一个. 我们的网格类可能知道如何渲染带有通道间隙的迷宫, 但它不知道如何处理这些新的下方单元格. 为此, 我们将覆盖我们的 `to_png_with_inset` 方法. 我们还将对 `to_png` 做一个小小的调整, 以便这些交织迷宫默认用内衬绘制.

将以下内容添加到我们的 `WeaveGrid` 类.

#+BEGIN_SRC ruby
  def to_png(cell_size: 10, inset: nil)
    super cell_size: cell_size, inset: (inset || 0.1)
  end

  def to_png_with_inset(img, cell, mode, cell_size, wall, x, y, inset)
    if cell.is_a?(OverCell)
      super
    else
      x1, x2, x3, x4, y1, y2, y3, y4 =
        cell_coordinates_with_inset(x, y, cell_size, inset)

      if cell.vertical_passage?
        img.line(x2, y1, x2, y2, wall)
        img.line(x3, y1, x3, y2, wall)
        img.line(x2, y3, x2, y4, wall)
        img.line(x3, y3, x3, y4, wall)
      else # horizontal
        img.line(x1, y2, x2, y2, wall)
        img.line(x1, y3, x2, y3, wall)
        img.line(x3, y2, x4, y2, wall)
        img.line(x3, y3, x4, y3, wall)
      end
    end
  end
#+END_SRC

第 2 行, 在新的 `to_png` 方法中, 只是在调用 `Grid` 上的原始 `to_png` 方法之前将默认内衬大小设置为 0.1. 而 `to_png_with_inset` 方法也没有涉及更多——当单元格是 `OverCell` 时, 它也只是调用超类的方法 (第 6 行). 不过, 当单元格*不是* `OverCell` 时, 它调用 `cell_coordinates_with_inset` 来获取不同墙壁的 x 和 y 坐标 (我*确实*说过那个方法以后会有用!) 在绘制下方单元格的走廊之前.

不用流汗! 我们现在应该准备好把这个放入我们的其他程序之一, 看看它是如何工作的. 请复制一份 `recursive_backtracker_demo.rb`, 称之为 `weave_maze.rb`. 然后将 `Grid` 引用更改为 `WeaveGrid`, 像这样:

#+BEGIN_SRC ruby
weave_maze.rb
require 'recursive_backtracker'
require 'weave_grid'

grid = WeaveGrid.new(20, 20)
RecursiveBacktracker.on(grid)

filename = "weave.png"
grid.to_png.save(filename)
puts "saved to #{filename}"
#+END_SRC

现在运行它, 我们应该会得到一个真正的、货真价实的、能与意大利面媲美的交织迷宫:

#+CAPTION: 一个 20x20 的交织迷宫.

成功! 我现在饿得想吃点意大利面了...

** 轮到你了
Your Turn

有人说, 如果你遵守规则, 你就会错过所有的乐趣. 至少在迷宫方面, 这似乎有些道理. 知道哪些规则可以弯曲 (甚至打破!) 可以打开整个可能性的洪流.

在本章中, 我们专注于打破禁止自我相交的规则——也就是说, 允许通道相互交叉. 我们通过移除死胡同来处理辫状迷宫, 然后通过在我们可爱的最短路径中间扔下熔岩坑来进一步复杂化事情. 我们研究了 Dijkstra 算法如何补偿这些陷阱和障碍——这些*权重*——并给你最有效 (最便宜) 的绕行路径. 我们实现了交织迷宫和一种通过在相邻单元格之间添加间隙来绘制它们的方法.

总而言之, 这是扎实的一天的工作!

不过, 你不应该惊讶地发现, 这再次只是触及了可能性的皮毛. 现在轮到你了. 想想下面的一些建议, 或者尝试一些你自己的.

*** 调整死胡同移除
Tweaking Dead-End Removal

在 `braid` 方法中尝试不同的条件. 在本章介绍的版本中, 它链接到一个随机的邻居 (尽管它偏好本身就是死胡同的邻居). 如果你让它偏好单元格死胡同方向的邻居呢? 也就是说, 如果单元格唯一的出口是向南, 试着链接到北边的单元格.

此外, 注意通过偏好将一个死胡同链接到另一个相邻的死胡同, 这个实现稍微扭曲了概率曲线. 将一个死胡同链接到另一个实际上是一举两得, 这意味着如果你要求移除一半的死胡同, 你可能会得到比你预期的更多的! 你要如何让 `braid` 方法更准确地处理那个 `p` 参数?

*** 稀疏迷宫
Sparse Mazes

一个*稀疏迷宫* (sparse maze) 是一个实际上不覆盖整个网格的迷宫, 就像下图所示.

#+CAPTION: 一个稀疏迷宫.

这些可以通过类似于辫状迷宫的方式剔除死胡同来创建, 但与其将那些单元格链接到一个额外的邻居, 你实际上是将它们从网格中完全移除. 实验一下, 看看你能想出什么.

*** 彩色辫状迷宫
Colored Braid Mazes

这是一个科学实验: 用不同的算法生成各种迷宫, 然后进行编织. 然后给生成的迷宫上色, 并比较它们. 编织是否显著地影响了算法的偏倚? 部分编织呢? 某些算法是否比其他算法受影响更大?

*** 最短路径游戏
Shortest Path Game

总的来说, 辫状迷宫往往比完美迷宫更容易解决, 因为有更多可能的出口方式. 然而, 添加一些约束可以恢复平衡, 甚至使这些辫状迷宫成为一个独特的挑战. 如果目标不仅仅是到达出口, 而是通过最短的可能路径到达出口呢? 设计一个游戏, 目标是在最少的步骤内导航一个辫状迷宫.

*** 寻找一个具有挑战性的路径
Finding a Challenging Path

我们已经看到了如何使用 Dijkstra 算法来找到迷宫中两个单元格之间的路径, 在本章中, 我们利用这些信息在那条路径上随机放置一个熔岩坑. 然而, 我们做得不是很聪明, 结果并不总是很有趣. 试着做得更好! 目标是拿一个辫状迷宫, 通过战略性地放置障碍物, 创建一个谜题, 玩家的挑战是找到一条有效的路径穿过它.

*** 彩色交织迷宫
Colored Weave Mazes

对于这个, 你只需要在 `Grid` 和 `WeaveGrid` 上的 `to_png_with_inset` 中填补缺失的实现. 这真的不太难——只是画出与通道相对应的矩形.

*** 用不同的算法进行交织
Weaving with Different Algorithms

递归回溯算法对于交织迷宫工作得很好, 但它不是唯一的可能性. 实验一下我们到目前为止涵盖的其他一些! 注意, 有些不会可靠地工作, 不过: 例如, Wilson 算法将需要一些努力, 因为它在链接单元格之前生成一条路径, 这可能会混淆我们编写的隧道逻辑. 另外, 正如它们所呈现的, 二叉树和 Sidewinder 对交织迷宫不起作用, 因为它们不依赖于 `neighbors` 方法. 你要如何克服这一点?

*** 其他网格的内衬墙
Inset Walls for Other Grids

我们在这里为常规网格实现了内衬墙, 但六边形网格, 或三角形网格呢? 就此而言, 第 7 章, *兜圈子*, 第 97 页的极坐标网格呢? 一旦你让其中一些工作起来, 思考在那些网格上实际的交织迷宫就是一小步了!

*** 在两个连续的走廊下隧道
Tunnel Under Two Consecutive Corridors

我们在本章中为自己设定的约束之一是, 一个通道可能不会试图在两个连续的走廊下面隧道. 这只是为了保持我们的实现简单, 而不是因为它实际上不可能. 你要如何改变我们的实现来移除这个约束?

这些交织迷宫是到另一个算法的一个很好的过渡, 称为 Kruskal 算法, 它可以用来生成迷宫. 在下一章中, 我们将看到它如何不仅可以用来生成随机迷宫, 还可以更好地控制我们的交织迷宫, 让我们指定通道交织的位置和频率.
* 第 10 章：改进你的编织
*Improving Your Weaving*

你可能已经注意到你在上一章写的那个程序, 那个生成交织迷宫的程序, 有点奇怪. 具体来说, 特别是如果你在用更小的迷宫做实验, 你可能看到有时候你那个本该生成交织迷宫的程序, 并没有. 你设置好它, 运行程序, 结果出来的只是一个无聊的、普通的、正常的迷宫.

问题在于上一章描述的技术实际上不是很可靠. 别误会——那个技术很容易理解, 实现起来很直接, 而且非常直观, 所以它有很多优点! 但因为它依赖于随机机会来决定何时在通道下隧道, 所以有可能生成一个完全不交织的迷宫. 多尴尬, 对吧? 那可不是你想要的结果, 特别是如果你刚叫一个朋友过来看“酷东西”.

理想情况下, 如果我们着手生成一个交织迷宫, 我们应该有信心得到一个. 甚至更好的是, 如果我们能以某种方式调整交叉的频率, 使它们或多或少地出现, 那就太好了, 而且——既然我们都说到这儿了——我们不妨提一下, 如果我们能确切地指定交叉应该在迷宫中的*哪个位置*, 那该多好啊.

那不是很整洁吗?

事实证明, 有一个算法可以做到! 或者更确切地说, 有这么一个随机迷宫算法, 恰好非常擅长微调这些交织迷宫. 它基于 Kruskal 算法, 我们即将探索它. 首先我们将看看 Kruskal 算法本身是如何工作的, 然后看看它如何能被应用于迷宫生成. 之后, 你将看到它如何能被用来让那些交织迷宫几乎可以随心所欲地配置.

** Kruskal 算法
Kruskal’s Algorithm

Kruskal 算法由数学家和计算机科学家 Joseph Kruskal 在 1956 年开发, 用于构建所谓的*最小生成树* (minimum spanning trees). 别被那些疯狂的词汇吓到——*生成树* (spanning tree) 实际上只是我们一直在生成的这些完美迷宫的花哨名称, 而*最小* (minimum) 只是指我们在上一章讨论的成本和权重.

基本上, Kruskal 试图解决以下问题. 假设你从一个图或网格开始, 其中每个可能连接相邻单元格的通道都被赋予了一个成本. 它可能看起来像下图这样.

#+CAPTION: 一个带权重的通道网格.

仅从中构建一个生成树 (我们可以说“完美迷宫”) 是很直接的: 你只需选择通道来连接所有的单元格, 而不形成任何回路. 我们到目前为止看过的算法基本上就是这么做的, 可能会给你下面的迷宫:

#+CAPTION: 从带权重的网格生成的一个迷宫.

不过, 这里的谜题是. 你如何从那个初始网格中构建一个其通道成本总和为最低总价值的迷宫? 什么是*最便宜*的可以构建的树?

Kruskal 的方法与我们到目前为止看到的算法有很大的不同. 完全没有随机行走——单元格实际上是非顺序访问的. 然而尽管如此, 它*确实*能行. 事情是这样的.

首先, 我们拿那个带权重通道的网格, 并给每个单元格分配一个唯一的标识符. 在下图中, 我们给每个单元格分配了一个字母表中的字母, 但简单地给它们编号也同样有效. 这些标识符代表唯一的集合, 每个集合包含一个单元格——但这很快就会改变!

#+CAPTION: 每个单元格都被分配到一个唯一的集合中.

一旦那些集合都确定了, 算法本身就开始一个循环, 在其中它反复地选择和处理相邻的单元格对. 对的选择是基于连接它们的通道的权重, 权重较小的优先. 在这里, 所有权重为 1 的通道都被高亮显示:

#+CAPTION: 所有权重为 1 的通道都被高亮显示.

在像这样的平局情况下, 我们可以选择我们喜欢的任何一个, 所以我们就选 G,H 对. 我们将那两个单元格链接在一起, 然后将它们*合并* (merge) 成一个集合. 这是通过选择两个集合中的一个, 并将另一个中的所有单元格移动到那一个中来完成的. 下图显示了 H 中的单元格被合并到了 G 集合中.

#+CAPTION: H 集合被合并到 G 集合中.

然后算法再次进行, 寻找下一个权重最低的通道. 还有几个权重为 1 的通道剩下, 所以那些都将被接下来处理, 导致以下单元格配置:

#+CAPTION: 所有权重为 1 的通道都被处理后.

正如接下来的图所示, 此时最便宜的通道的权重都是 2.

#+CAPTION: 所有权重为 2 的通道都被高亮显示.

因为我们可以任意打破平局, 让我们说算法选择了连接 G 和 L 集合的通道, 看看会发生什么. 两个单元格的集合被比较, 发现是不同的, 所以单元格被链接, 两个集合被合并在一起. 下一个图显示了 L 中的所有单元格现在都已被合并到 G 中.

#+CAPTION: L 集合被合并到 G 集合中.

这些合并影响了给定集合中的*所有*单元格, 无论那个集合有多大, 或者离通道有多远. 它们本质上是在识别出小的迷宫胚胎, 即网格中被链接在一起的子集!

这又持续了几次, 将所有由权重为 2 的通道连接的单元格链接在一起, 如下图所示.

#+CAPTION: 所有权重为 2 的通道都被处理后.

在接下来的几次迭代中, 所有权重为 3 的通道都将被处理, 继续生长那些小小的婴儿迷宫, 像这样:

#+CAPTION: 权重为 3 的通道被处理后.

进入下一轮, 最便宜的通道现在都是权重为 4, 我们遇到了我们第一个小麻烦. 考虑下图左侧高亮的通道. 如果我们选择那个通道并连接那两个单元格, 我们最终会连接两个都属于同一集合的单元格! 因为每个集合都代表一个自包含的小迷宫, 那将意味着向那个迷宫添加一个回路, 这是我们不允许的.

(尽管这确实暗示了一种生成辫状迷宫的有趣方式, 不是吗?)

我们通过完全跳过那条边来惊险地避免了灾难.

#+CAPTION: 算法避免了创建一个回路.

剩下的 4 权重通道被处理时没有意外, 给了我们下图:

#+CAPTION: 所有权重为 4 的通道都被处理后.

快到了! 剩下的最低成本通道都是 5, 在下图中高亮显示.

#+CAPTION: 所有权重为 5 的通道都被高亮显示.

我们可以忽略东南角的那一个, 因为那会连接两个都属于 G 的单元格. 这就给我们留下了三个可供选择. 让我们抓住东北角 D 集合中的那个单元格, 并将它合并到 A 集合中:

#+CAPTION: D 集合被合并到 A 集合中.

然后让我们通过连接 A 和 G 集合, 通过那两个剩下的 5 权重通道中的一个来完成这个.

#+CAPTION: A 和 G 集合被合并.

在这一点上, 网格中的每个单元格都属于同一个集合, A, 这意味着我们完成了! 最终的结果是一个完美的迷宫:

#+CAPTION: 一个完成的 Kruskal 算法迷宫.

简而言之, 那么, 算法是:
1.  将每个单元格分配到它自己的集合中.
2.  选择具有最低成本通道连接的相邻单元格对.
3.  如果两个单元格属于不同的集合, 就合并它们.
4.  重复 2 和 3, 直到只剩下一个集合.

我们可以在代码中完全按照描述的那样实现这个——连同连接单元格的带权重通道——但事实证明, 为了我们的目的, 我们可以稍微简化这个算法.

虽然通道权重在某些应用中很重要 (其中通道通常被称为*边* (edges), 单元格被称为*节点* (nodes)), 但在制作迷宫时它们通常不那么关键. 事实上, 要用 Kruskal 算法将一个网格变成一个迷宫, 我们首先必须给所有可能的通道分配随机的权重, 然后才能按那些权重的顺序选择它们.

那有点多余. 实际上, 将所有的通道放入一个大列表中, 然后从列表中随机选择它们要容易得多. 这个小小的改变将 Kruskal 算法转换成了*随机化 Kruskal 算法* (Randomized Kruskal’s algorithm).

让我们用代码实现它.

** 实现随机化 Kruskal 算法
Implementing Randomized Kruskal’s Algorithm

为了实现这个, 我们将创建一个新类来表示算法的*状态* (state)——它将在内部使用的信息集合. 一旦我们写好了这个 `State` 类, Kruskal 算法的其余部分就变得几乎微不足道了. 不过, 别光听我说. 看着吧!

正如你在前一节中看到的, Kruskal 最初要求每个单元格与一个唯一的集合相关联. 这表明, 至少, 我们的 `State` 类将需要跟踪那个关联. 我们需要一种方法来查询特定单元格属于哪个集合, 以及属于给定集合的单元格列表. 此外, 算法希望在每次迭代中选择随机的相邻单元格对, 所以我们或许可以通过保留一个那些单元格对的列表来帮助事情.

通过将以下内容放入一个名为 `kruskals.rb` 的新文件中来开始.

#+BEGIN_SRC ruby
kruskals.rb
class Kruskals
  class State
    attr_reader :neighbors

    def initialize(grid)
      @grid = grid
      @neighbors = []
      @set_for_cell = {}
      @cells_in_set = {}

      @grid.each_cell do |cell|
        set = @set_for_cell.length

        @set_for_cell[cell] = set
        @cells_in_set[set] = [ cell ]

        @neighbors << [cell, cell.south] if cell.south
        @neighbors << [cell, cell.east] if cell.east
      end
    end
  end
end
#+END_SRC

我们将 `State` 类嵌套在 `Kruskals` 类中, 因为它对任何其他算法都不会特别有用. `initialize` 构造函数 (第 6 行) 接受一个参数, 即要处理的网格. 第 8 行的 `@neighbors` 数组将用于跟踪相邻单元格的对, `@set_for_cell` (第 9 行) 将单元格映射到它们对应的集合标识符, 而 `@cells_in_set` (第 10 行) 则做相反的事情, 将集合标识符映射到属于那些集合的单元格.

然后每个单元格都被分配到一个新的集合中 (第 13-16 行), 并且 `@neighbors` 数组被构建起来, 每个邻居对都表示为一个简单的双元素数组.

现在, 回想一下, 算法会尝试合并每一对单元格, 只要它们不在同一个集合中. 为了帮助做出那个决定, 我们将添加一个 `can_merge?(left, right)` 方法, 它将比较这两个参数的集合. 在 `State` 类的 `initialize` 方法之后立即添加这个.

#+BEGIN_SRC ruby
    def can_merge?(left, right)
      @set_for_cell[left] != @set_for_cell[right]
    end
#+END_SRC

这里没有意外——它只是为每个单元格查询 `@set_for_cell` 映射并比较它们, 如果它们不同 (因此能够被合并), 则返回 `true`.

这就引出了合并操作本身. 在 `State` 类中, 就在 `can_merge?` 之后, 添加这个最后的方法.

#+BEGIN_SRC ruby
    def merge(left, right)
      left.link(right)

      winner = @set_for_cell[left]
      loser = @set_for_cell[right]
      losers = @cells_in_set[loser] || [right]

      losers.each do |cell|
        @cells_in_set[winner] << cell
        @set_for_cell[cell] = winner
      end

      @cells_in_set.delete(loser)
    end
#+END_SRC

这只是将两个单元格链接在一起 (第 2 行), 然后遍历 `loser` 集合 (即 `right` 属于的那个) 中的单元格. 该集合中的每个单元格都被移动到 `winner` 集合 (包含 `left` 的那个), 然后 `loser` 集合被移除 (第 13 行).

现在, 这是最好的部分. 有了那个类来为我们保存和维护状态, 随机化 Kruskal 算法变得如此简单, 让我头晕目眩. 在 `kruskals.rb` 的最后一个 `end` 关键字之前添加以下方法.

#+BEGIN_SRC ruby
  def self.on(grid, state=State.new(grid))
    neighbors = state.neighbors.shuffle

    while neighbors.any?
      left, right = neighbors.pop
      state.merge(left, right) if state.can_merge?(left, right)
    end

    grid
  end
#+END_SRC

说真的, 就这样! 给定一个网格和一个状态对象 (如果没有指定, 默认为一个新的 `State` 实例), 该方法只是设置一个所有邻居对的随机化列表, 然后循环遍历它们直到列表为空. 每次循环都会从列表中移除一对, 检查它们是否可以合并, 如果可以, 就合并它们.

现在用 `kruskals_demo.rb` 来测试一下.

#+BEGIN_SRC ruby
kruskals_demo.rb
require 'kruskals'
require 'grid'

grid = Grid.new(20, 20)
Kruskals.on(grid)

filename = "kruskals.png"
grid.to_png.save(filename)
puts "saved to #{filename}"
#+END_SRC

运行它并打开生成的 `kruskals.png`, 你应该会看到类似图中的东西.

#+CAPTION: 一个 20x20 的 Kruskal 算法迷宫.

看起来很随机!

** 用 Kruskal 更好地编织
Better Weaving with Kruskal

那么, 这就是随机化 Kruskal 算法, 你现在可能想知道这和交织迷宫有什么关系. 毕竟, 那是本章开始的方式, 我确实承诺过 Kruskal 会适用. 让我向你保证, 它确实如此.

回想一下上一章是如何介绍交织迷宫的, 算法在出现机会时随机尝试在通道之上或之下移动. 这当然行得通, 但它不是很一致. 有时你可能会得到一个有十几个交叉通道的迷宫, 而其他时候你可能只得到一个或两个 (或者根本没有).

然而, 我们希望能够生成具有一致、可预测数量的交叉的迷宫. 不同的应用有不同的需求, 所以能够为轻度编织的迷宫调低编织密度, 或者一直调到十一档以尽可能紧密地填充交叉, 将会很好.

那么我们能做什么呢?

嗯, 想象一下, 如果我们能决定这些交叉的位置. 那将让我们明确地声明编织会有多密集, 也会让我们将交叉通道拟合到特定的模式和设计中. 这个过程将从类似下图的东西开始, 其中一些这些交叉通道已经被放置 (也许是随机地) 在网格上.

#+CAPTION: 一个预先填充了一些交叉通道的网格.

从那里, 我们需要以某种方式生成一个完整的迷宫, 其中*包含*那些位置的交叉. 换句话说, 我们需要将那些未连接的、不相交的通道以某种方式*合并* (merge) 到最终的迷宫中...

听起来耳熟吗? 应该的. 这正是 Kruskal 算法所做的那种事情, 记住. 如果我们拿那个带有交叉的网格, 并用一个唯一的数字给每个连续的单元格分组编号, 我们会得到这个图, 一个非常像 Kruskal 起始状态的熟悉配置.

#+CAPTION: 将交叉通道视为 Kruskal 算法的起始集合.

事实上, 如果我们对那个网格应用 Kruskal 算法, 按照那些数字显示的起始集合进行排列, 我们实际上会得到一个包含了那些交叉的迷宫, 如图所示.

#+CAPTION: Kruskal 算法然后填充剩余的空间, 生成一个完整的迷宫.

换句话说, 正是我们想要的! 理论上, 我们可以把那些交叉放在我们想要的任何地方, 杂乱无章地遍布整个网格, 并产生一个*真正*密集的交织迷宫
* 第 11 章：与 Prim 一起成长
*Growing With Prim’s*

整个“最小生成树”问题原来有很多应用, 比如寻找构建电话线路的最佳方式, 或者构建计算机网络的最佳方式. Kruskal 算法是解决它的方法之一, 但不是唯一的方法, 这意味着我们应该能够找到其他可以为我们所用的算法.

(Mwa-hahahaha!)

果然, 还有另一个算法, 叫做 Prim 算法, 而且果然, 它可以很容易地适应随机迷宫生成. 我们将看看这个算法是如何工作的, 然后我们将看到它在迷宫中通常实现的两种方式: 一个简化版本, 和一个“真实”版本. 最后, 我们将看一个与之密切相关的算法, 叫做生长树 (Growing Tree) 算法, 它实际上不仅可以被配置为像 Prim 算法一样工作, 甚至可以像递归回溯算法 (Recursive Backtracker) 一样!

** 介绍 Prim 算法
Introducing Prim’s Algorithm

Prim 算法最初是由捷克数学家 Vojtěch Jarník 在 1930 年开发的, 但它的名字来源于 1957 年独立重新发现它的计算机科学家 Robert C. Prim. 它的工作方式与 Dijkstra 算法类似, 从网格中的一个点开始, 然后像水流一样向外移动, 但在 Prim 的情况下, 它做的不仅仅是测量距离和成本. Prim 算法的最终结果是那些花哨的最小生成树之一——或者, 在我们的情况下, 一个迷宫.

和 Kruskal 算法一样, Prim 算法通过考虑单元格之间的连接权重——通道成本——而不是单个单元格本身来工作. 我们将看看这是如何组合在一起的, 但然后我们将退一步, 考虑一些使它更容易实现的简化.

所以, 和 Kruskal 算法一样, 我们从一个网格开始, 并标明所有潜在连接的成本. 假设我们的网格是这样设置的, 带有给定的通道成本:

#+CAPTION: 一个带权重的通道网格.

Prim 算法, 像 Dijkstra 算法一样, 从一个任意的单元格开始向外工作, 所以我们的下一步是选择一个起点. 让我们选择这个:

#+CAPTION: 算法从一个随机选择的单元格开始.

我们在这里用黄色给它上色, 以表示它已被添加到迷宫中. (白色的单元格还不在迷宫中——它们仍在等待机会. 不过, 等我们完成时, 它们都将被涂成黄色.)

接下来, 我们查看所有从那个起始单元格出发的可能通道, 并选择成本最低的一个. 在这种情况下, 它是成本为 1 的通道, 向西走, 所以我们选择那个并将当前单元格与其西边的邻居链接起来, 像这样:

#+CAPTION: 算法选择成本最低的通道并添加邻居单元格到迷宫中.

注意我们现在也把那个邻居涂成黄色, 因为它已被添加到迷宫中. 我们正在向外生长迷宫, 一次一个通道.

现在我们再做一次, 只是这一次我们想选择连接到我们*任何*已访问单元格的最低成本通道. 这就像一滩水从第一个单元格开始, 现在它可以向外泛滥到它接触到的任何单元格. 事实证明, 成本最低的单元格是标记为 2 的那个, 从我们的第一个单元格向南走, 所以我们选择它并链接那两个单元格:

#+CAPTION: 算法再次选择成本最低的通道.

你可能已经猜到下一步是什么了——我们将再次这样做, 寻找连接到那三个单元格中任何一个的最低成本通道. 不过, 这一次, 我们打了个平手: 有两个单元格, 都值 3. 在这种情况下, 我们通过任意选择一个来打破平局, 所以我们将选择这一个:

#+CAPTION: 算法在平局情况下任意选择一个通道.

算法就这样继续下去, 每次都选择下一个成本最低的通道. 再过几次迭代, 我们可以看到迷宫开始成形:

#+CAPTION: 迷宫继续生长, 一次一个通道.

不过, 最终, 我们可能会遇到像这样的情况:

#+CAPTION: 算法遇到一个可能创建回路的通道.

这是另一个平局, 这我们很熟悉, 但请注意东南角的通道. 它连接了两个已经在迷宫中的单元格. 如果选择那个通道, 它会增加一个循环, 这是我们不希望的. 解决方案是像我们对 Kruskal 算法那样做, 跳过那些连接, 只考虑那些链接到一个还不在迷宫中的单元格的连接. 在这种情况下, 这给我们留下了另外两个可能的通道. 我们任意选择一个, 像这样:

#+CAPTION: 算法避免了回路, 选择了另一条通道.

算法重复进行, 直到每个单元格都被添加到迷宫中, 此时你将得到类似下面的东西:

#+CAPTION: 一个完成的 Prim 算法迷宫.

完美. (字面意思!)

现在我们已经走过了完整算法的工作原理, 让我们看看实现它的两种方法, 从一个我们将称之为“简化” Prim 算法的常见变体开始.

** 简化 Prim 算法
Simplified Prim’s Algorithm

Prim 算法的简化版本在迷宫生成器中相当常见, 并且通常被许多来源简称为“Prim 算法”. 然而, 与真正的算法不同, 这些简化版本实际上不关心通道的不同成本和权重. 事实上, 这些算法往往与你在一个每个通道成本都相同的网格上运行真正的 Prim 算法所得到的结果相似.

回想一下算法是如何开始的, 在随机选择一个单元格作为起点之后: 它寻找连接到那个起始单元格的最低成本通道. 但如果每个通道都有相同的权重, 它们都会打平, 我们将通过在候选者中随机选择来打破平局.

所以如果整个网格中的每个通道都有相同的权重, Prim 算法在每一步都只会随机选择一个连接通道. 这恰好是这些简化算法基本上所做的, 有一个显著的区别: 它们不是选择*通道*, 而是通常选择*单元格*.

我们可以实现几种可能的变体, 但我们将在这里坚持使用最简单的之一. 将以下内容放入 `prims.rb`.

#+BEGIN_SRC ruby
prims.rb
class SimplifiedPrims
  def self.on(grid, start_at: grid.random_cell)
    active = []
    active.push(start_at)

    while active.any?
      cell = active.sample
      available_neighbors = cell.neighbors.select { |n| n.links.empty? }

      if available_neighbors.any?
        neighbor = available_neighbors.sample
        cell.link(neighbor)
        active.push(neighbor)
      else
        active.delete(cell)
      end
    end

    grid
  end
end
#+END_SRC

这个过程从第 4 行开始, 初始化一个名为 `active` 的数组, 然后将我们的起点添加到其中 (默认是网格中的一个随机位置). 然后, 算法的其余部分只要该列表中有单元格就会重复进行.

每次循环, 算法从那个活动列表中随机选择一个单元格 (第 8 行), 然后找到那个单元格尚未被链接的邻居 (第 9 行).

如果没有任何这样的邻居, 这意味着被选中的单元格被迷宫包围, 将无法产生更多的通道. 在那种情况下, 单元格将从活动列表中移除 (第 16 行), 过程再次进行. 否则, 从那些可用的邻居中随机选择一个邻居, 然后链接到当前单元格并添加到活动列表中 (第 12-14 行).

用以下程序测试该算法:

#+BEGIN_SRC ruby
prims_demo.rb
require 'prims'
require 'grid'

grid = Grid.new(20, 20)
SimplifiedPrims.on(grid)

filename = "prims-simple.png"
grid.to_png.save(filename)
puts "saved to #{filename}"
#+END_SRC

运行它应该会生成类似下面的迷宫:

#+CAPTION: 一个 20x20 的简化 Prim 算法迷宫.

这看起来不错, 但你可能会察觉到一些算法偏倚的迹象. 如果迷宫被着色, 这尤其明显, 如下图所示. 在这里, Dijkstra 算法 (如*为你的迷宫着色*, 第 47 页所述) 是从与 Prim 算法相同的单元格开始运行的:

#+CAPTION: 一个着色的简化 Prim 算法迷宫, 显示出径向偏倚.

那种径向纹理是均匀加权通道的结果. 在其他所有条件都相同的情况下, 算法将尝试简单地从起始单元格均匀地向外扩散, 创造出那种“碎玻璃”图案.

不过, 只要稍加努力, 我们可以做得更好. 它所需要的只是我们更忠于原始算法, 并将成本考虑在内.

** 真正的 Prim 算法
True Prim’s Algorithm

尽管我们接下来将要实现的算法被称为“真正的” Prim 算法, 它仍然是稍微修改过的. 它不是给*通道*分配权重, 而是给*单元格*分配权重, 然后根据那些成本来选择单元格. 这给了我们与完全通道加权的 Prim 算法非常相似的迷宫, 而且工作量要少得多.

再次打开 `prims.rb` 并在底部添加以下类:

#+BEGIN_SRC ruby
class TruePrims
  def self.on(grid, start_at: grid.random_cell)
    active = []
    active.push(start_at)

    costs = {}
    grid.each_cell { |cell| costs[cell] = rand(100) }

    while active.any?
      cell = active.min { |a,b| costs[a] <=> costs[b] }
      available_neighbors = cell.neighbors.select { |n| n.links.empty? }

      if available_neighbors.any?
        neighbor = available_neighbors.min { |a,b| costs[a] <=> costs[b] }
        cell.link(neighbor)
        active.push(neighbor)
      else
        active.delete(cell)
      end
    end

    grid
  end
end
#+END_SRC

它与简化版的算法几乎相同, 除了高亮的部分. 首先, 创建了一个 `costs` 映射, 随机地给每个单元格分配一个成本 (0-99). 然后用那个映射来通过数组的 `min` 方法找到成本最低的单元格. 这实际上在每次循环中最多做两次——一次在活动列表上找到成本最低的活动单元格, 然后再次找到那个单元格可用的邻居中成本最低的那个.

#+BEGIN_QUOTE
为简单起见, 前面的代码使用 Ruby 的 `Array#min` 方法来找到最便宜的单元格. 不过, 在实际使用中, 像*优先队列*这样的东西会更有效率!
#+END_QUOTE

运行它, 我们得到一个纹理明显不同的迷宫:

#+CAPTION: 一个 20x20 的真正 Prim 算法迷宫.

用与简化算法相同的方式给它着色, 我们可以看到径向纹理消失了:

#+CAPTION: 一个着色的真正 Prim 算法迷宫, 显示出更均匀的纹理.

事实上, 这个迷宫的纹理与你从 Kruskal 算法得到的非常相似, 这不应该令人惊讶, 因为这两种算法都旨在生成同一种迷宫.

所以, 你有了两种 Prim 算法的风格: 简化版和所谓的真实版. 每一种都生成纹理截然不同的迷宫, 然而算法本身却几乎相同. 事实上, 它们之间唯一的显著区别是选择单元格的方式.

这个简单的观察原来是另一个迷宫算法的基础, 叫做*生长树*. 让我们接下来看看它.

** 生长树算法
The Growing Tree Algorithm

让我们暂停一下, 再考虑一下我们看过的 Prim 算法的两个版本. 两者都通过从一个任意的单元格开始工作, 然后通过选择相邻的单元格从那个单元格向外生长. 在简化版的情况下, 相邻的单元格是随机选择的. 对于“真实”版本, 单元格是根据它们的成本选择的.

但那些几乎不是从那个列表中选择单元格的唯二方法. 如果你总是试图选择离起点最近的单元格呢? 或者那个最近被添加到列表中的单元格? 或者——这是一个好主意——如果你以某种方式组合多个条件, 一半时间随机挑选, 另一半时间根据权重挑选呢?

我们这里所拥有的就是生长树 (Growing Tree) 算法的基础. 它的工作方式是这样的:
1.  从网格中随机选择一个单元格. 将其添加到活动列表中.
2.  从活动列表中选择一个单元格.
3.  选择那个单元格的一个随机的、未访问过的邻居. 将两者链接在一起, 并将邻居添加到活动列表中.
4.  重复步骤 2 和 3, 直到每个单元格都被链接.

魔法发生在第 2 步, 选择一个单元格的地方. 通过插入不同的单元格选择标准, 可以构建出截然不同的迷宫. 事实上, 本章中简化版和真实版 Prim 算法的实现实际上只是这个生长树算法的特例!

让我们来实现这个. 我们将使用 Ruby 的*块* (blocks) (匿名函数) 来定义如何选择单元格.

将以下代码放入 `growing_tree.rb`.

#+BEGIN_SRC ruby
growing_tree.rb
class GrowingTree
  def self.on(grid, start_at: grid.random_cell)
    active = []
    active.push(start_at)

    while active.any?
      cell = yield active
      available_neighbors = cell.neighbors.select { |n| n.links.empty? }

      if available_neighbors.any?
        neighbor = available_neighbors.sample
        cell.link(neighbor)
        active.push(neighbor)
      else
        active.delete(cell)
      end
    end

    grid
  end
end
#+END_SRC

再次, 你会注意到它与我们已经见过的 Prim 算法实现几乎相同, 有一个显著的区别. 高亮的一行使用 Ruby 的 `yield` 关键字来调用任何已经传递给 `on(grid)` 方法的匿名代码块. 活动单元格的列表被传递给那个匿名块, 它应该返回列表中的一个单元格.

要看它在实践中是如何工作的, 看看下面的代码.

#+BEGIN_SRC ruby
growing_tree_demo.rb
require 'growing_tree'
require 'grid'

def save(grid, filename)
  grid.to_png.save(filename)
  puts "saved to #{filename}"
end

grid = Grid.new(20, 20)
GrowingTree.on(grid) { |list| list.sample }
save(grid, "growing-tree-random.png")

grid = Grid.new(20, 20)
GrowingTree.on(grid) { |list| list.last }
save(grid, "growing-tree-last.png")

grid = Grid.new(20, 20)
GrowingTree.on(grid) { |list| (rand(2) == 0) ? list.last : list.sample }
save(grid, "growing-tree-mix.png")
#+END_SRC

这很像我们之前的所有程序, 但引入了一个单独的方法 `save`, 来集中保存网格为图像.

有趣的部分在高亮的行上, 生长树算法被应用到一个网格上. 在第一个中, 提供了一个块, 它只是从传递给它的列表中返回一个随机元素 (`list.sample`). 第二个总是返回列表的最后一个元素 (`list.last`), 第三个则变得棘手, 一半时间选择最后一个元素, 另一半时间选择一个随机元素.

运行那个程序将生成三个不同的图像. 打开它们, 看看你得到了什么. 下图并排显示了三个不同的迷宫, 包括着色以更清晰地看到不同的纹理.

#+CAPTION: 三个用生长树算法生成的迷宫: 随机选择, 最后选择, 和混合选择.

左边的图像是每次迭代中从活动列表中随机挑选单元格的地方, 正如我们所料, 它看起来完全像简化 Prim 算法生成的迷宫. 不过, 中间的那个——那看起来也很熟悉. 通过总是选择活动列表中的*最后一个*元素, 我们生成了一个带有长长的、蜿蜒的通道的迷宫...

是*递归回溯算法*!

如果你需要, 回顾一下*递归回溯算法*, 第 73 页来刷新你对那个算法的记忆. 回想一下, 它总是将栈顶的单元格视为当前单元格, 并总是在每一步选择一个随机的未访问邻居.

将那与生长树在总是选择活动列表的最后一个元素时所做的进行比较. 在算法的每一步, 生长树都会向列表的末尾添加一个新元素. 通过在下一次再次选择那个新添加的元素, 它实际上变得与递归回溯中的当前单元格相同.

换句话说, 通过一个单一的、极其简单的改变, 生长树算法可以重新创建简化 Prim 算法或递归回溯算法!

不过, 事情变得更好了. 让我们看看我们生成的第三张图片, 那张一半时间选择最后一个单元格, 另一半时间选择一个随机单元格的图片. 特别是如果你看彩色版本, 你可以看到一个模糊的径向纹理, 让人想起简化 Prim 算法, 但你也可以看到通道倾向于稍微蜿蜒一下. 换句话说, 我们已经将简化 Prim 算法的方面与递归回溯算法的方面合并了, 给了我们两种算法的特征.

这就像我们在玩那两种算法的 DNA!

这和听起来一样强大. 想要更多的死胡同? 更频繁地选择随机. 想要更长的通道? 更频繁地选择最后一个元素. 这就像我们被给了一个滑块来控制生成的迷宫的纹理!

** 轮到你了
Your Turn

我们刚刚给你的工具箱添加了一个相当强大的工具. 在看了 Prim 算法的两个简单变体后, 我们看到了它们如何能被泛化成第三个算法, 生长树, 并进一步看到生长树可以被配置为同时模仿不同算法的属性!

有很多不同的方向你可以走. 如果你不确定接下来要尝试什么, 可以考虑下面的一些想法, 但不要害怕跳到完全不同的方向!

*** “修改版” Prim 算法
“Modified” Prim’s Algorithm

如前所述, Prim 算法有几种“简化”的变体. 其中一个, 通常被称为“修改版” Prim 算法, 比本章中给出的简化版给出了稍微更好的结果. 实现起来有点麻烦, 这使它成为一个很好的“轮到你了”挑战!

它的工作方式是这样的:
1.  初始化三个集合: `in`, `frontier`, 和 `out`.
2.  将起始单元格放入 `in` 集合中, 将其所有邻居放入 `frontier` 集合中. 将所有剩余的单元格添加到 `out` 集合中.
3.  只要 `frontier` 集合中有单元格, 就从中随机移除一个, 将其添加到 `in` 集合中, 并将其链接到一个随机的 `in` 邻居. 然后将其所有的 `out` 邻居移动到 `frontier` 集合中, 然后重复.

试试看, 看看你的想法!

*** “最真实”的 Prim 算法
“Truest” Prim’s Algorithm

尝试通过构建和使用一个邻居对的列表, Kruskal 风格, 来实现一个真正的 Prim 算法. 将列表初始化为只包含包含起始单元格的那些对, 并在算法的每一步从 (并扩展) 那个列表中选择包含新单元格的对.

一旦你让它工作起来, 想想如何将它与本章中介绍的真正 Prim 实现进行比较. 给迷宫上色和计算死胡同是两种方法, 但你还能想到什么其他方法来量化这两种算法的迷宫有多么不同或相似?

*** 其他单元格选择方法
Other Cell Selection Methods

生长树在本章中介绍了三种不同的单元格选择方法: 随机, 最后, 和两者的混合. 不过, 这些只触及了表面. 你还能想到什么其他的单元格选择方法? 这里有几个可以尝试的可能性:
-   *最老的*——总是选择列表中的第一个单元格.
-   *中位数*——总是选择列表中的中间单元格.
-   *同一单元格*——随机选择, 但一旦你选择了一个单元格一次, 就一次又一次地选择它, 直到它没有更多的未访问邻居. 然后再选择另一个随机单元格, 重复.
-   *最远的*——总是选择离前一个被选择的单元格最远的单元格.

*** 带单元格成本的生长树
Growing Tree with Cell Costs

如果你跟踪单元格成本并用它们来驱动生长树的单元格选择呢? 如果你在最后选择和成本选择之间做一个混合呢? 那与最后选择和随机选择的混合相比如何? 当你将简化 Prim 算法与真正 Prim 算法拼接在一起时会发生什么?

*** 通道方式的生长树
Passage-wise Growing Tree

生长树通常保留一个单元格的列表, 如本章所述, 但如果你跟踪通道呢? 你可以用它来实现“真正的” Prim 算法, 这是一回事, 但其他选择方法的工作方式是否不同?

*** 配置邻居选择
Configure Neighbor Selection

仔细看本章中给出的真正 Prim 算法的实现, 并将其与生长树实现进行比较, 你可能会注意到, 真正 Prim 算法实际上是根据权重选择邻居单元格的, 而生长树只是随机选择它们. 如果你也让那变得可配置呢? 当生长树总是想选择当前单元格西边的邻居时会发生什么? 你甚至可以添加区域变化, 东半部的单元格倾向于向北走, 而西半部的单元格偏好向东.

现在你已经有机会探索生长树和朋友们了, 我们不妨通过探索两个特别新颖的样本来完成你的迷宫算法库. 一个模糊地类似于 Sidewinder, 但另一个...嗯. 继续读下去看看
* 第 12 章：合并，分割
*Combining, Dividing*

这么多算法! 从二叉树和 Sidewinder, 到 Kruskal 和 Prim 以及生长树, 你已经学到了很多关于生成随机迷宫的不同方法. 准确地说, 有十种方法——如果我们算上 Dijkstra 的话, 就是十一种.

只剩下两种要介绍了!

第一种, 叫做 Eller 算法, 是一种快速, 高效, 巧妙的技术, 似乎是 Sidewinder 算法和 Kruskal 算法不太可能的结合的产物.

第二种是一种独特的算法, 叫做递归分割 (Recursive Division), 它的运作方式与我们到目前为止涵盖的任何其他算法都非常不同. 它的分形性质有一些有趣的后果, 我们将利用它在我们的迷宫中产生*房间* (rooms).

但首先, Eller 算法. 我们开始吧!

** Eller 算法
Eller’s Algorithm

Eller 算法是由 Marlin Eller 在 1982 年发明的. 它与 Sidewinder (见第 12 页) 有一些显著的相似之处, 但又通过结合 Kruskal (见第 158 页) 的一些特性, 设法避免了那个算法的显著偏倚.

像 Sidewinder 一样, 它通过一次只考虑一行来工作, 同时建立集合 (Kruskal 风格) 来跟踪哪些单元格可以从哪些其他单元格到达. 让我们通过一个例子来工作.

为方便起见, 我们将从顶行开始, 我们将用黄色高亮显示当前行, 以便跟踪我们所在的位置.

#+CAPTION: 一个 4x5 网格, 顶行高亮显示.

我们做的第一件事是给那一行中的每个单元格分配一个数字, 实际上是把每个单元格都放在它自己的一个集合中, 就像我们为 Kruskal 做的那样 (但在一个更小的规模上). 像这样:

#+CAPTION: 顶行的每个单元格都被分配到一个唯一的集合中.

然后, 我们随机地链接相邻的单元格, 但*只有*在它们不属于同一个集合的情况下. 和 Kruskal 算法一样, 当我们链接相邻的单元格时, 我们也合并这两个集合. 假设我们决定链接单元格 1 和 2 (将两者都合并到集合 1), 以及单元格 3 和 4 (合并到集合 3). 我们得到类似下面的东西:

#+CAPTION: 相邻的单元格被随机链接, 它们的集合被合并.

下一步是从每个*剩余的*集合中随机选择*至少*一个单元格, 并向南开辟通道. 如果我们愿意, 我们可以从任何给定的集合中选择多个单元格, 但我们必须至少选择一个. 在选择了一些单元格并向南开辟之后, 我们可能会得到类似下面的东西:

#+CAPTION: 每个集合中至少有一个单元格向南开辟通道.

注意, 向南开辟也把那些单元格添加到了链接它们的单元格的集合中, 让我们能够跟踪哪些单元格最终在行之间是连接的. (这是这个算法和 Sidewinder 之间的一个关键区别!)

向南开辟那些通道完成了那一行, 我们前进到下一行:

#+CAPTION: 算法前进到下一行.

这一行中的三个单元格已经属于一个集合, 因为它们与前一行中的单元格相连. 不过, 另外两个单元格需要被分配到新的集合中. 我们可以随心所欲地分配这些新集合, 只要它们是唯一的. 在这里, 我们选择了从前一行结束的地方继续计数:

#+CAPTION: 新行中未分配的单元格被分配到新的集合中.

然后我们再来一遍. 我们:
1.  随机链接相邻的单元格 (只要它们不共享一个集合),
2.  从每个集合中选择至少一个单元格向南开辟, 然后
3.  前进到下一行.

#+CAPTION: 算法在第二行重复这个过程.

我们对每一行都重复这三个步骤, 一直到底部. 当我们到达最后一行时, 我们的迷宫看起来像这样:

#+CAPTION: 算法到达最后一行.

在这一点上, 我们做了一些稍微不同的事情. 那些集合中的每一个都可以被看作是一条松散的线, 从我们刚刚构建的这块挂毯的边缘垂下. 为了让迷宫整齐地完成, 那些线必须都被系好. 也就是说, 那些剩余的集合需要被合并在一起.

我们通过查看最后一行中的每个单元格, 然后将每一个与其邻居链接 (和合并), 只要那些邻居属于不同的集合来做到这一点. (你永远不会合并两个属于同一集合的单元格! 那会在迷宫中引入一个回路.) 最终的结果是这样的:

#+CAPTION: 一个完成的 Eller 算法迷宫.

不错! 接下来让我们看看它在代码中是如何工作的.

** 实现 Eller 算法
Implementing Eller’s Algorithm

Eller 算法严格地一次只处理一行, 所以我们的实现将利用这一点, 依赖于一个以行为中心的状态对象. 一旦我们有了那个状态对象, 算法的其余部分就很快地组合在一起了.

我们将从 `RowState` 类开始, 我们将把它放在 `Ellers` 类的命名空间下. 它们都将放在 `ellers.rb` 中.

#+BEGIN_SRC ruby
ellers.rb
class Ellers
  class RowState
    def initialize(starting_set=0)
      @cells_in_set = {}
      @set_for_cell = []
      @next_set = starting_set
    end
  end
end
#+END_SRC

这当然还不多, 但它确实让我们开始了. `initialize` 方法有一个 `starting_set` 参数 (默认为 0), 它将用于确定新集合使用什么值. 然后它设置了一些实例变量, 将用于在当前行内跟踪集合.

接下来的三个方法允许我们查询和操纵那些集合. 在 `RowState` 类中, 就在那个 `initialize` 方法之后, 添加这些.

#+BEGIN_SRC ruby
    def record(set, cell)
      @set_for_cell[cell.column] = set
      @cells_in_set[set] = [] if !@cells_in_set[set]
      @cells_in_set[set].push cell
    end

    def set_for(cell)
      if !@set_for_cell[cell.column]
        record(@next_set, cell)
        @next_set += 1
      end
      @set_for_cell[cell.column]
    end

    def merge(winner, loser)
      @cells_in_set[loser].each do |cell|
        @set_for_cell[cell.column] = winner
        @cells_in_set[winner].push cell
      end

      @cells_in_set.delete(loser)
    end
#+END_SRC

`record` 方法为给定的单元格记录一个给定的集合. `set_for` 方法检查给定的单元格是否已经属于一个集合 (如果没有, 它会给它分配一个), 然后返回那个集合. 而 `merge` 则将 `loser` 集合中的所有单元格移动到 `winner` 集合中.

以下两个方法完成了 `RowState` 类.

#+BEGIN_SRC ruby
    def next
      RowState.new(@next_set)
    end

    def each_set
      @cells_in_set.each { |set, cells| yield set, cells }
      self
    end
#+END_SRC

`#next` 方法返回一个新的 `RowState` 实例, 从当前实例结束的地方开始计数集合. 而 `each_set` 方法则迭代当前行中的集合, 将每个集合及其单元格集合传递给附加的块.

那么, 剩下要做的就是实现 Eller 算法本身. 将以下方法放在 `RowState` 类结束之后, 但在 `Ellers` 命名空间内.

#+BEGIN_SRC ruby
  def self.on(grid)
    row_state = RowState.new

    grid.each_row do |row|
      row.each do |cell|
        next unless cell.west

        set = row_state.set_for(cell)
        prior_set = row_state.set_for(cell.west)

        should_link = set != prior_set &&
                      (cell.south.nil? || rand(2) == 0)

        if should_link
          cell.link(cell.west)
          row_state.merge(prior_set, set)
        end
      end

      if row.south
        next_row = row_state.next

        row_state.each_set do |set, list|
          list.shuffle.each_with_index do |cell, index|
            if index == 0 || rand(3) == 0
              cell.link(cell.south)
              next_row.record(row_state.set_for(cell), cell.south)
            end
          end
        end

        row_state = next_row
      end
    end
  end
#+END_SRC

我们做的第一件事是创建一个 `RowState` 对象, 然后开始遍历网格中的每一行. 对于我们得到的每一行, 我们按顺序考虑它的单元格 (第 5 行), 跳过最西边的单元格 (第 6 行), 因为我们将尝试将每个单元格链接到它的西边邻居, 而它没有.

第 8 行和第 9 行查询行状态以获取当前单元格和其西边邻居所属的集合, 然后我们检查我们是否应该将这两个单元格链接在一起 (第 11-12 行). 记住, 我们只能在它们属于不同集合的情况下链接它们! 假设它们是不同的集合, 如果我们在最后一行 (即 `cell.south.nil?`), 我们将总是链接它们; 否则我们随机决定.

如果事情发展到单元格需要被链接, 我们就链接它们, 然后将两个集合合并在一起 (第 16 行). 在这里, 我们向西合并, 以便当前单元格的集合消失并被前一个单元格的集合取代.

一旦我们完成了当前行中相邻单元格的链接, 我们就进入第二阶段: 选择哪些单元格向南链接. 我们只有在实际上有南边一行的情况下才这样做 (第 20 行). 它的工作原理是首先为下一行准备一个新的 `RowState` 实例 (第 21 行), 然后查看当前行中的每个单元格集合 (第 23 行). 对于那些集合中的每一个, 我们随机化相关的单元格列表 (第 24 行) 并遍历它们.

因为我们必须从每个集合中至少向南开辟一个单元格, 我们要求索引为 0 的单元格是那个幸运儿 (第 25 行). (记住, 我们在前一行洗牌了列表, 所以这里的“第一个”单元格实际上是随机选择的.) 如果集合中有多个单元格, 后续的单元格有三分之一的机会被选中. (顺便说一句, 这些几率没有什么神奇之处. 随意实验一下!)

如果单元格被选中, 我们从它向南开辟 (第 26 行), 然后将那个南边的单元格放入与我们刚刚选择的单元格相同的集合中 (第 27 行).

在为当前行中的每个集合都这样做之后, 我们然后用新的行状态替换当前的行状态 (第 32 行), 然后再做一遍.

都明白了吗?

让我们用我们通常的演示程序来试试看. 将以下内容放入 `ellers_demo.rb`.

#+BEGIN_SRC ruby
ellers_demo.rb
require 'ellers'
require 'grid'

grid = Grid.new(20, 20)
Ellers.on(grid)

filename = "ellers.png"
grid.to_png.save(filename)
puts "saved to #{filename}"
#+END_SRC

运行它将产生类似下面的可爱小迷宫:

#+CAPTION: 一个 20x20 的 Eller 算法迷宫.

要看这与 Sidewinder 如何比较, 我们可以生成和着色两个迷宫, 一个使用 Eller 算法, 一个使用 Sidewinder. 把它们并排放置, 我们得到以下结果:

#+CAPTION: 一个 Eller 算法迷宫和一个 Sidewinder 算法迷宫的比较.

左边是用 Eller 算法生成的迷宫, 右边是 Sidewinder. 你几乎不可能错过 Sidewinder 迷宫中那条明显的垂直条纹! 正如他们所说: 一分钱一分货.

不过, 有时候, 你能得到比你付出的更多. 让我们看一个真正大于其各部分之和的算法.

** 递归分割
Recursive Division

递归分割 (Recursive Division) 算法在我们到目前为止看过的算法中是独特的, 原因有二. 首先, 它将迷宫视为一个*分形* (fractal)——一个其组成部分都与整体相同 (或几乎相同) 的形状. 其次, 与其他算法开辟*通道* (passages) 不同, 这个算法从一个广阔的开放空间开始, *添加墙壁* (adds walls) 直到产生一个迷宫. 这种性质的算法被称为*墙壁添加者* (wall adders) (与*通道开辟者* (passage carvers) 相对).

它的工作原理是将网格分成两个子网格, 在它们之间添加一堵墙和一个连接它们的单一通道. 然后在每一边递归地重复该算法, 直到通道达到所需的大小.

让我们来过一遍.

我们从一个开放的网格开始, 没有内部墙壁. (网格线在这里用浅灰色显示, 以便更容易地看到单元格在哪里, 但它们只是为了说明.)

#+CAPTION: 一个没有内部墙壁的开放网格.

我们沿着那些网格线中的任何一条, 水平或垂直地将网格分成两半. 在这里, 我们垂直地分割它, 在西边留下两列, 在东边留下三列.

#+CAPTION: 网格被垂直分割成两半.

接下来我们在墙上添加一个通道, 在那堵墙的任何地方. 让我们说我们把它放在这里:

#+CAPTION: 在分割墙上添加一个通道.

这就完成了一次算法的迭代. 这个过程现在在每一半上递归地重复. 让我们接下来处理西边, 将其水平地分成两半, 并留下一个单一的通道来连接这两个区域.

#+CAPTION: 西半部被水平分割.

这个过程再次重复, 在这里将西北区域分成两半:

#+CAPTION: 西北区域再次被分割.

在这一点上, 最新分割创建的区域太小了, 无法再分割——我们不想把单个单元格分成两半——所以我们跳过, 开始处理剩余的区域.

#+CAPTION: 算法移动到下一个区域.

当我们都完成, 将所有区域处理到单个单元格的大小时, 我们就有了一个迷宫:

#+CAPTION: 一个完成的递归分割迷宫.

接下来让我们确定一个实现.

** 实现递归分割
Implementing Recursive Division

该算法真的和描述的一样简单. 首先, 我们将通过将每个单元格链接到它的邻居来“清空”网格 (有效地移除所有内部墙壁), 然后通过添加墙壁来递归地将网格分成两半.

与我们实现的其他算法不同, 我们将把这个分成几个不同的方法来帮助递归. 不过, 这一切都将从我们典型的 `on(grid)` 方法开始. 将以下内容放入 `recursive_division.rb`.

#+BEGIN_SRC ruby
recursive_division.rb
class RecursiveDivision
  def self.on(grid)
    @grid = grid
    @grid.each_cell do |cell|
      cell.neighbors.each { |n| cell.link(n, false) }
    end

    divide(0, 0, @grid.rows, grid.columns)
  end
#+END_SRC

第 6-8 行将每个单元格链接到它的每个邻居. (我们向 `link` 方法传递 `false` 以防止它创建 reciprocal 连接. 毕竟我们已经在遍历每个单元格了.) 然后, 第 10 行触发递归, 开始将网格分成两半的过程.

让我们接下来看看 `divide`. 在 `on` 方法之后立即添加这个:

#+BEGIN_SRC ruby
  def self.divide(row, column, height, width)
    return if height <= 1 || width <= 1

    if height > width
      divide_horizontally(row, column, height, width)
    else
      divide_vertically(row, column, height, width)
    end
  end
#+END_SRC

第 2 行的条件测试区域是否太小以至于无法细分. 如果是, 则该特定区域的递归结束. 否则, 我们决定是水平还是垂直地分割该区域. 尽管这可以随机完成, 但根据区域的宽高比进行分割往往能得到好的结果, 并避免产生带有许多长垂直或水平通道的区域.

最后两个方法彼此非常相似. 在 `RecursiveDivision` 类的末尾添加这些.

#+BEGIN_SRC ruby
  def self.divide_horizontally(row, column, height, width)
    divide_south_of = rand(height-1)
    passage_at = rand(width)

    width.times do |x|
      next if passage_at == x

      cell = @grid[row+divide_south_of, column+x]
      cell.unlink(cell.south)
    end

    divide(row, column, divide_south_of+1, width)
    divide(row+divide_south_of+1, column, height-divide_south_of-1, width)
  end

  def self.divide_vertically(row, column, height, width)
    divide_east_of = rand(width-1)
    passage_at = rand(height)

    height.times do |y|
      next if passage_at == y

      cell = @grid[row+y, column+divide_east_of]
      cell.unlink(cell.east)
    end

    divide(row, column, height, divide_east_of+1)
    divide(row, column+divide_east_of+1, height, width-divide_east_of-1)
  end
#+END_SRC

让我们关注 `divide_horizontally`. (你会看到 `divide_vertically` 非常相似.)

我们做的第一件事, 在第 2 行和第 3 行, 是决定在哪里分割区域, 以及连接两半的通道应该在哪里. 我们在这里是水平分割, 所以目标网格线将紧邻被选中的任何一行的南边.

然后, 对于那条分割线上的每个单元格 (除了我们的通道将要经过的地方), 我们将从其南边的邻居那里 `unlink` 单元格 (第 8-9 行), 有效地在两个单元格之间建起一堵墙.

一旦那堵墙建好了, 分隔了两半, 第 12 行和第 13 行就在那些新区域上调用 `divide`, 进一步递归到网格中.

就是这样!

让我们把我们的演示程序组合起来, 这样我们就可以测试它了. 创建 `recursive_division_demo.rb`, 并让它看起来像下面这样:

#+BEGIN_SRC ruby
recursive_division_demo.rb
require 'recursive_division'
require 'grid'

grid = Grid.new(20, 20)
RecursiveDivision.on(grid)

filename = "recursive_division.png"
grid.to_png.save(filename)
puts "saved to #{filename}"
#+END_SRC

运行它将通过递归分割产生一个迷宫:

#+CAPTION: 一个 20x20 的递归分割迷宫.

就这样!

** 递归分割偏倚
The Recursive Division Bias

如果你看得足够久, 你可能会开始看到这个算法偏倚的证据——一种由重复地将网格减半造成的某种“方块感”的纹理. 不过, 如果它看起来有点微妙, 那没关系. 我们可以给网格上色, 使纹理更明显.

下图显示了一个由递归分割算法生成并用 Dijkstra 算法着色的 100×100 迷宫. 墙壁已被省略以使纹理更清晰.

#+CAPTION: 一个着色的递归分割迷宫, 显示出其“方块感”的偏倚.

迷宫的“像素化”纹理现在更清晰地呈现出来了. (从某种程度上说, 它真的很美!) 但我们看到的是什么? 这个纹理到底意味着什么?

嗯, 它表明迷宫中存在一些区域, 它们实际上是被框起来的——被封闭在这些矩形区域中, 很少有通道通向外面. 回想一下, 当我们分割一个区域时, 我们总是在两半之间留下一个确切的通道. 这就产生了一种瓶颈, 从迷宫的一侧到另一侧的任何路径都必须通过那个通道.

结果就是那种方块感的纹理和一个相对直接的迷宫解法. 你所要做的就是寻找相关的瓶颈. 毕竟, 解法路径无论如何都得通过它们, 不是这样就是那样!

** 用递归制作房间
Making Rooms with Recursion

所以, 这是一个新颖的算法, 但在这一点上, 它似乎用途相当有限. 我的意思是, 那个彩色版本很漂亮, 但除非你追求某种立体主义艺术, 否则很难看出你为什么会使用这个算法.

答案, 我的朋友, 是*房间*.

回想一下我们 `divide` 方法的顶部, 我们在那里测试区域的宽度和高度. 目的是看区域是否已经变得足够小, 但如果你随机地强制递归在那之前停止, 你可以阻止其中一些变得那么小. 这导致了开放区域——房间, 或庭院, 或停车场, 或任何在你的迷宫上下文中说得通的东西.

让我们试试!

再次打开 `recursive_division.rb`, 并找到 `divide` 方法的第一行, 即如果高度或宽度太小就返回的那一行. 试着用下面这行替换它:

#+BEGIN_SRC ruby
return if height <= 1 || width <= 1 ||
          height < 5 && width < 5 && rand(4) == 0
#+END_SRC

现在运行演示程序, 你应该会得到一个类似下面的迷宫:

#+CAPTION: 一个带房间的递归分割迷宫.

看那个! 现在它是一个平面图了. 所有那些方块感的纹理都需要一些帮助来伪装成一个办公区.

** 轮到你了
Your Turn

就这样: 你被承诺的那十几个算法中的最后一个. Eller 算法的工作方式就像是 Sidewinder 和 Kruskal 联姻的后代, 而递归分割...嗯...递归分割在做它自己的事情, 通过将东西切成两半来制作分形迷宫.

把玩一下这些, 看看它们会带你到哪里. 当你读到它们时, 你有什么想法? 追逐那些, 做点什么! 也许下面的想法可以让你开始.

*** 无限 Eller...
Infinitely Eller’s…

你已经看到了 Eller 算法如何一次只在一行上操作, 一直到最后一行. 但如果你从不给它最后一行呢? 你将如何使用这个算法生成一个任意 (无限?) 长的迷宫?

*** Eller 算法在别处
Eller’s Algorithm Elsewhere

Eller, 像 Sidewinder 一样, 确实在常规的正方形网格上工作得最好. 然而, 只要有一点创造力, 它可以被改造成在六边形网格, 甚至圆形网格上工作. 你会怎么做呢?

*** 不规则分割
Irregular Divisions

这是一个具有挑战性的! 正如你所见, 递归分割算法的方块感来自于使用水平和垂直线来将区域分成两半. 如果用来分割那些区域的线不必是直的呢? 你将如何将那些区域分割成非矩形的区域?

*** 混合算法
Mixing Algorithms

你看到了当递归分割算法被强制提前停止递归时出现的房间. 如果, 与其让那些房间空着, 你在里面运行一些其他的迷宫算法呢? 那些“房间”中的每一个, 毕竟, 都是小小的微型网格!

*** 墙壁添加者 vs. 通道开辟者
Wall Adders versus Passage Carvers

一些算法作为通道开辟者 (比如递归回溯) 工作得最好, 一些作为墙壁添加者 (比如递归分割) 工作得最好. 但有些可以被改造成使用任何一种技术. 记住,“墙壁添加者”只是描述了一个算法创建墙壁而不是通道的过程. 记住这一点, 你将如何实现 Aldous-Broder 算法 (见第 55 页) 作为一个墙壁添加者? 还有哪些其他算法在以那种方式考虑时可以工作?

你可能以为你已经完成了, 既然你已经学完了所有十二种迷宫算法. 不过, 等等. 最令人震撼的部分还在后头! 我们将开始把你的迷宫带到更高的维度...

* 第 13 章：将迷宫扩展到更高维度
*Extending Mazes into Higher Dimensions*

到目前为止, 我们生成的所有迷宫基本上都是平面的, 牢固地粘在一个平面的表面上. 导航这些迷宫, 无论它们是常规的, 极坐标的, 六边形的, 还是三角形的网格, 你都只能在两个维度上移动, 即北或南, 东或西, 或它们的某种组合.

诚然, 交织迷宫试图摆脱这种约束, 确实设法通过在其他通道之上或之下移动, 将其部分通道短暂地提升到那个平面之上. 尽管如此, 交织迷宫的大部分仍然可悲地是二维的. 我们可以说, 最多, 一个交织迷宫是*二维半*的.

现在, 这些二维 (或二维半) 迷宫对于许多事情来说已经足够了——像《吃豆人》(Pac-Man) 和《毁灭战士》(Doom) 这样的游戏 (仅举两例) 只用两个轴来约束移动就已经足够好了, 谢谢你. 在本书的这一点上, 我们已经用二维迷宫做了很多事情.

但是, 一旦我们添加了第三个维度, 甚至第四个维度, 我们能做的事情就多得多了. 洞穴系统, 办公楼, 地下城, 和死星, 时间旅行, 和传送门跳跃只是其中的一小部分.

在本章中, 我们将研究这些更高维度的迷宫, 并讨论这到底意味着什么. 我们将从三维*常规网格* (regular grids) (那些单元格是矩形的) 开始, 介绍需要对我们的 `Grid` 类进行的更改以适应第三个维度, 我们将讨论如何将我们的迷宫算法应用于这些修改后的网格. 一旦我们让三维工作起来, 我们将简要地看看更高的维度对迷宫做了什么, 通过考虑四维网格来震撼心灵.

** 理解维度
Understanding Dimensions

像“二维”或“三维”这样的短语中的“维度 (dimension)”一词, 指的是在某个空间内指定任何点所需的坐标数量. 在我们的二维迷宫的情况下, 我们已经用行和列——两个坐标, 因此, 两个维度——来描述了那些点 (或单元格).

如果你拿走所有的维度, 移除所有的坐标, 你就发现了一个*零维空间* (zero-dimensional space). 这样的空间似乎极其具有禅意, 没有位置感, 只有存在感. (哇哦. 伙计!) 就我们的迷宫而言, 单个单元格是一个零维空间, 因为没有其他单元格的上下文, 它就没有位置的概念. 你无法从这样一个独立的单元格去任何地方. 它本身不是很令人兴奋, 但如果你拿一堆这些零维单元格并将它们堆叠在一起, 你就可以制作一个*一维网格* (one-dimensional grid), 像这样:

#+CAPTION: 从零维单元格构建的一维网格.

你可以看到, 这样的网格只允许你沿着一个单一的轴移动, 比如南北或东西. 结果, 其中的每个单元格都可以简单地通过它离其中一端的距离来寻址, 比如 1 或 3. 一个坐标, 一个维度.

在这样的网格上的迷宫会比在零维空间中的好一点, 但也好不到哪里去. 仍然不会有分支, 没有蜿蜒, 也没有死胡同. 它将是一条单一的, 笔直的通道. 下图显示了一个在东西轴上的一维迷宫.

#+CAPTION: 一个一维迷宫.
Start Here
End Here

再次, 不太激动人心, 但如果你拿几个它们并将它们堆叠在一起, 你最终会得到一个二维网格, 像这样:

#+CAPTION: 从一维行构建的二维网格.

这就回到了我们开始的地方! 这样一个网格中的每个单元格都必须通过它的*行* (row) 和它的*列* (column)——两个坐标——来寻址. 前图中的网格是一个*常规网格*——由正方形组成——但它也可以是一个六边形网格, 三角形网格, 极坐标网格, 或其他更奇特的东西. 没关系——如果单元格由两个坐标寻址, 网格就是二维的.

让我们把这些提升到一个新的水平. 我们将看看带有第三个维度的网格.

** 介绍 3D 迷宫
Introducing 3D Mazes

所以, 零维单元格组合成一维行, 一维行堆叠成二维网格. 那么, 应该可以得出, *二维网格*可以堆叠成*三维网格*...这正是事实, 如下图所示.

#+CAPTION: 从二维层级构建的三维网格.

当我们把这些独立的 2D 网格中的每一个都看作是更大的 3D 网格中的*层级* (levels) 时, 事情就变得很清楚了, 这样一个网格中的每个单元格都必须由三个坐标来寻址: *行* (row), *列* (column), 和*层级* (level).

三个坐标. 三个维度.

不过, 像那样显示, 很难看到每个层级, 所以我们通常不以透视方式渲染它, 而是将它显示为一组平面图, 像这样:

#+CAPTION: 用平面图表示的三维网格.

底层, 或层级, 在最左边, 随着越来越高的层级向右移动.

那么, 这给了我们一种描述和显示三维网格的方法. 我们现在需要的只是一种使用像这样的布局来生成三维迷宫的方法. 最简单的方法 (如果不是最灵活的方法) 是生成一堆二维迷宫, 将它们堆叠起来, 然后在单个点连接相邻的层级, 像这样:

#+CAPTION: 通过在单个点连接两个二维迷宫来创建的三维迷宫.

这工作得很好, 只要每个层级最初都是一个完美的迷宫, 结果也将是一个. 还记得 Kruskal 算法是如何通过一次链接那些小的原始迷宫来工作的吗? 这里真的就是同样的事情. 就好像 Kruskal 算法来了, 并在那个点上将那些相邻的迷宫链接在了一起.

这种方法可以满足许多应用. 只要只有一个位置链接相邻的层级, 你就可以将每个层级视为 (和生成) 一个独立的二维迷宫.

然而, 如果你想要一个在多个地方在层级之间上下移动的迷宫呢? 如果你想要一条一直通到塔顶, 然后再一直回到塔底的解法路径呢? 如果你希望它仍然是一个完美的迷宫, 你就不能只是在多个点添加梯子, 因为你一旦这样做, 你就*添加了一个回路*.

看看. 让我们标记前一个图中由梯子链接的两个单元格. 我们称下方的单元格为 A, 上方的为 B, 像这样:

#+CAPTION: 一个双层迷宫, 单元格 A 和 B 由梯子连接.

如前所述, 只要两个组件迷宫是完美的, 生成的双层迷宫也是完美的. 但如果我们现在在两者之间添加另一个链接, 我们就有问题了. 假设我们添加另一个梯子, 链接下图所示的两个迷宫, 连接下层迷宫的点 C 到上层迷宫的点 D.

#+CAPTION: 添加第二个梯子 (在 C 和 D 之间) 会创建一个回路.

现在, 因为它们本身都是完美的迷宫, 我们知道一个事实, 即通过下层迷宫连接 A 到 C 恰好有一条路径, 通过上层迷宫从 B 到 D 恰好有一条路径. 但因为 A 和 B 是链接的, C 和 D 也是链接的, 我们现在有*两种*方式从 A 到 C: 通过下层迷宫, A 到 C, 以及通过上层迷宫, A 到 B 到 D 到 C.

一个回路! 我们根本无法通过在完美的二维迷宫之间添加多个连接来得到一个完美的三维迷宫. 我们必须转向其他方法.

幸运的是, 那些其他方法原来很直接. 我们需要扩展我们的网格, 给它增加一个维度, 然后在其上运行我们选择的迷宫算法.

** 添加第三维度
Adding a Third Dimension

回想一下第 2 章, *自动化和展示你的迷宫*, 第 17 页, 当我们第一次研究网格背后的代码时, 我们用一个二维数组实现了 `prepare_grid` 方法. 那不仅仅是巧合——那正是决定我们网格几何形状的东西! 我们将通过向那个数组添加第三个维度来给网格添加第三个维度.

如果事情那么简单, 这将是一个非常短的章节. 不过, 好消息是, 其他的更改都与那个数组修改相关的次要附带损害. 单元格需要被告知它们新的上/下邻居, 网格需要知道如何迭代其他层级中的单元格, 等等.

这真的不算太糟, 最棒的是, 一旦我们做了那些更改, 我们看过的*大多数*算法都会自动工作. 即使是那些因这些更改而中断的, 也可以通过一些简单的修改来使其恢复正常. 你会看到的.

让我们来实现这个. 为简单起见, 把所有东西——网格和单元格——都放在同一个文件中, 叫做 `grid3d.rb`. 从新的单元格类开始, 像这样:

#+BEGIN_SRC ruby
grid3d.rb
require 'grid'

class Cell3D < Cell
  attr_reader :level
  attr_accessor :up, :down

  def initialize(level, row, column)
    @level = level
    super(row, column)
  end

  def neighbors
    list = super
    list << up if up
    list << down if down
    list
  end
end
#+END_SRC

`Cell3D` 类只是扩展了我们原始的 `Cell` 类, 并添加了 `level` (第三个维度, 类似于 `row` 和 `column`), 以及用于上和下方向邻居的访问器. `neighbors` 方法也被覆盖以包含那两个新邻居.

网格本身几乎同样直接, 但我们需要重新实现一些假设网格只有一个层级高的其他方法. 这里的想法是更改我们的网格, 以便它不仅能表示一个单一的 (二维) 层级, 还能表示多个堆叠在一起的层级. 同样地, 在 `grid3d.rb` 中, 就在 `Cell3D` 的定义之后, 放入以下内容.

#+BEGIN_SRC ruby
grid3d.rb
class Grid3D < Grid
  attr_reader :levels

  def initialize(levels, rows, columns)
    @levels = levels
    super(rows, columns)
  end

  def prepare_grid
    Array.new(levels) do |level|
      Array.new(rows) do |row|
        Array.new(columns) do |column|
          Cell3D.new(level, row, column)
        end
      end
    end
  end

  def configure_cells
    each_cell do |cell|
      level, row, col = cell.level, cell.row, cell.column

      cell.north = self[level, row - 1, col]
      cell.south = self[level, row + 1, col]
      cell.west  = self[level, row, col - 1]
      cell.east  = self[level, row, col + 1]
      cell.down  = self[level - 1, row, col]
      cell.up    = self[level + 1, row, col]
    end
  end

  def [](level, row, column)
    return nil unless level.between?(0, @levels - 1)
    return nil unless row.between?(0, @grid[level].count - 1)
    return nil unless column.between?(0, @grid[level][row].count - 1)
    @grid[level][row][column]
  end

  def random_cell
    level = rand(@levels)
    row = rand(@grid[level].count)
    column = rand(@grid[level][row].count)

    @grid[level][row][column]
  end

  def size
    @levels * @rows * @columns
  end

  def each_level
    @grid.each do |level|
      yield level
    end
  end

  def each_row
    each_level do |rows|
      rows.each do |row|
        yield row
      end
    end
  end
end
#+END_SRC

我们在这里所做的只是重新实现了那些假设网格是二维的方法——`prepare_grid`, `configure_cells`, 数组访问器, 等等——并让它们意识到那个第三个维度. 我们还添加了一个新方法 `each_level`, 用于迭代网格的每个二维层级.

那就行了! 有了网格意识到第三个维度, 每个单元格现在都更新以包含其“上”和“下”邻居 (即上面和下面层级上的那些), 我们的大多数算法应该就能正常工作了. 随意试一试...但请注意, 我们还没有办法绘制这些 3D 迷宫. 我们当前的 `to_png` 需要更多注意.

** 显示 3D 迷宫
Displaying a 3D Maze

我们将把这些迷宫画成一组平面图, 下层在左边, 上层在右边. 上下通道将由相应单元格中绘制的红色箭头表示, 指示每个通道通向哪个相邻的楼层. 例如, 一个 3×3×3 的迷宫可能看起来像这样:

#+CAPTION: 图 6—一个 3×3×3 迷宫

指向右边的箭头就像通往上面层级的楼梯, 指向左边的箭头是通往下方的楼梯. 如果我们从底层 (最左边的那个) 的西北角进入迷宫, 我们可能会向东走两步到东北角, 走楼梯到中间层级的同一个角, 向西走一步, 然后再上一层楼梯, 最终到达第三层.

有点烧脑!

但它能行, 而且实现起来并不太难. 它像这样组合在一起. 将以下内容放入 `grid3d.rb`, 在 `Grid3D` 类定义的末尾.

#+BEGIN_SRC ruby
  def to_png(cell_size: 10, inset: 0, margin: cell_size/2)
    inset = (cell_size * inset).to_i

    grid_width = cell_size * columns
    grid_height = cell_size * rows

    img_width = grid_width * levels + (levels - 1) * margin
    img_height = grid_height

    background = ChunkyPNG::Color::WHITE
    wall = ChunkyPNG::Color::BLACK
    arrow = ChunkyPNG::Color.rgb(255, 0, 0)

    img = ChunkyPNG::Image.new(img_width + 1, img_height + 1, background)

    [:backgrounds, :walls].each do |mode|
      each_cell do |cell|
        x = cell.level * (grid_width + margin) + cell.column * cell_size
        y = cell.row * cell_size

        if inset > 0
          to_png_with_inset(img, cell, mode, cell_size, wall, x, y, inset)
        else
          to_png_without_inset(img, cell, mode, cell_size, wall, x, y)
        end

        if mode == :walls
          mid_x = x + cell_size / 2
          mid_y = y + cell_size / 2

          if cell.linked?(cell.down)
            img.line(mid_x-3, mid_y, mid_x-1, mid_y+2, arrow)
            img.line(mid_x-3, mid_y, mid_x-1, mid_y-2, arrow)
          end

          if cell.linked?(cell.up)
            img.line(mid_x+3, mid_y, mid_x+1, mid_y+2, arrow)
            img.line(mid_x+3, mid_y, mid_x+1, mid_y-2, arrow)
          end
        end
      end
    end

    img
  end
#+END_SRC

这个实现引入了一个新参数 `margin`, 它代表了网格不同层级之间的间距. 默认情况下, 它将是一个单元格宽度的一半.

接下来, 我们需要弄清楚我们的图像会有多大. 弄清楚单个网格的大小很容易——这正是我们在我们第一个 `to_png` 实现中所做的, 也是我们在这里第 4 行和第 5 行所做的. 图像本身将保持一个网格高, 但宽度将是每个层级一个网格宽, 再加上相邻层级对之间的那个边距. 第 7 行替我们计算了那个.

在实际绘制迷宫之前, 我们做的最后一件事是为我们的箭头设置颜色, 在第 12 行. 我们用纯红色, 将绿色和蓝色分量都设为零.

然后, 我们进行实际的绘制. 我们可以重用我们之前章节中实现的大部分内容——我们所要做的就是计算每个单元格的正确位置, 然后让我们的单个单元格绘制方法完成剩下的工作. 第 18 行计算单元格西北角的 x 坐标, 下一行对 y 坐标做同样的事情.

一旦单元格被绘制, 剩下要做的就是为通往上下方向的通道绘制箭头. 这发生在第 27-40 行, 绘制每个箭头都相对于当前单元格的中心.

有了这一点, 我们可以尝试构建和绘制一个 3D 迷宫. 递归回溯算法在这里是一个非常安全的选择——它对网格几何形状的变化非常宽容——所以我们在这里用它. 将以下内容放入 `grid3d_demo.rb`.

#+BEGIN_SRC ruby
grid3d_demo.rb
require 'grid3d'
require 'recursive_backtracker'

grid = Grid3D.new(3, 3, 3)
RecursiveBacktracker.on(grid)

filename = "3d.png"
grid.to_png(cell_size: 20).save(filename)
puts "saved to #{filename}"
#+END_SRC

到现在为止, 这应该都很熟悉了, 尽管我们正在绘制更大的单元格 (一边 20 像素), 这样上下箭头就不会那么拥挤. 生成的迷宫应该看起来很像图 6, *一个 3×3×3 迷宫*, 第 216 页中的那个. 实验不同的维度, 看看你得到了什么!

你可能也想实验其他算法——你应该这么做!——但不是我们看过的所有算法都能按实现的那样工作. 需要注意的有 Kruskal, 二叉树, 和 Sidewinder——而且说实话, 即使是那些也可以被改造成在 3D 网格上工作. 在每种情况下, 都是我们的实现有问题, 而不是算法本身.

在 Kruskal 的情况下, 我们 `State` 类的实现是硬编码的, 在形成邻居对列表时, 将每个单元格与其*南*和*东*邻居匹配. 添加*上*或*下*作为额外的邻居 (在 `State#initialize` 方法中) 就可以解决那个问题.

对于 Sidewinder, 每当一个单元格的游程被结束时, 我们的实现会从那个游程中选择一个单元格并添加一个向*北*的通道. 如果我们把它改成在*北*和*上*之间选择 (或者如果一个或另一个邻居不存在, 那么就用可用的那个), 那么我们就会得到一个 3D-capable 的 Sidewinder.

而对于二叉树, 诀窍是把它变成一个*三元树*. 在每个单元格, 与其只在*北*和*东*之间选择, 不如尝试在*北*, *东*, 和*上* (或*下*) 之间选择. 生成的算法完全乐于在三维网格上生成迷宫.

试试那些, 看看它们是如何运作的! 当你准备好了, 我们将做最后一次, 简短的停留——在第四维度.

** 表示四维
Representing Four Dimensions

你现在已经看到了模式是如何组合在一起的. 零维单元格构成一维*行* (rows) (或*列* (columns)), 它们组合在一起构成二维*层级* (levels), 它们堆叠在一起构成三维*世界* (worlds).

那么当你拿那些三维世界并将它们沿着另一个轴, 垂直于我们已有的三个轴堆叠时会发生什么呢? (暂时忽略想象一个同时垂直于我们已有三个轴的方向是相当困难的.) 你可能可以猜到我们将得到一个四维网格, 而你将完全正确.

为了说明在第四维度中堆叠, 我们可以拿那些三维网格并将它们在页面上垂直排列, 如第 220 页的图所示.

这个网格是 2×4×4×4——两组三维网格 (或*世界*), 每一个都由四个二维网格 (*层级*) 组成, 而那些二维网格中的每一个都是一个 4×4 的单元格网格 (*行*和*列*). 四个坐标, 四个维度. 相邻三维网格之间的移动是通过*此/彼* (hither/yon) 轴, 类似于*上/下* (up/down) 但在第四维度.

邻接的工作方式与三维网格完全相同, 但也连接了*此*单元格 (那些在当前 3D 网格之上的) 和*彼*单元格 (那些在下面的 3D 网格中的). 下图显示了一个 3×3×3×3 的网格, 一个单元格用绿色绘制, 所有与之相邻的单元格用黄色绘制.

#+CAPTION: 图 7—表示一个 4D 堆栈

实现这样一个网格和实现第三维度一样容易——向保存单元格的数组添加另一个维度, 向 `Cell` 类添加新的邻居访问器 (`hither` 和 `yon`), 并更新各种 `Grid` 方法以适应这个新维度. 一旦你做了那些更改, 你就可以真正地疯狂起来, 生成令人费解的四维迷宫, 就像图 8, *一个 4D 迷宫*, 第 221 页那样.

移动的工作方式与三维迷宫完全相同, 左右箭头充当指向*上*和*下*的楼梯. 我们还添加了指向*此*和*彼*的箭头. 如果你把它们想象成在你世界之间传送的传送门, 图片可能会开始变得更有意义一点!

#+CAPTION: 图 8—一个 4D 迷宫

** 轮到你了
Your Turn

就这样, 一次对第三和 (简要地!) 第四维度的旋风之旅. 我们已经看到了如何修改 `Grid` 和 `Cell` 类以适应这些新维度, 并看到了一种在这些类型的网格上可视化迷宫的方法.

有了这些知识, 你会去哪里? 如果你发现自己缺少一个目的地, 也许可以考虑下面的一些:

*** 改变网格类型
Changing the Grid Type

本章中的示例和插图都基于*常规网格*——基于方形 (或立方体) 单元格的网格. 如果你堆叠*六边形网格*, 或*三角形网格*呢?

*** 三维圆形迷宫
Three-Dimensional Circle Mazes

尝试将一堆极坐标网格 (来自第 7 章, *兜圈子*, 第 97 页) 堆叠在一起, 形成一个圆柱形塔式迷宫! 如果你感觉特别有冒险精神, 试着随着层级的增加改变圆的半径, 将其减小到一个点以形成一个圆锥. 更具冒险精神的是, 通过改变每个层级的半径来制作一个“死星”, 使它们形成一个球体. (如果你负责, 欧比旺可能永远也找不到那个牵引光束的关闭开关!)

*** 强制一个层级偏倚
Forcing a Level Bias

在这些三维网格上运行我们的迷宫算法, 我们最终会得到在层级之间非常频繁移动的路径. 然而, 在现实生活中, 一个多层建筑只在少数几个位置在楼层之间移动. 你要如何修改这些算法, 以便它们更喜欢选择相邻的南北或东西单元格, 然后再退回到上/下邻居?

*** 第一人称视角
A First-Person Perspective

使用你喜欢的任何工具, 从一个随机生成的三维迷宫内部实现一个第一人称视角. 要么允许用户自己导航它, 要么只是动画化一个最长路径的飞越.

*** 单元格作为多面体
Cells as Polyhedra

对于一个真正的挑战, 考虑一个由相互锁定的*多面体* (polyhedra) 组成的三维网格! 例如, 菱形十二面体可以被堆叠以平铺一个三维空间. 不过, 如果你走这条路, 就告别简单的平面图; 你需要发挥创造力才能将结果可视化! 第一人称视角对于像这样的迷宫可能是理想的...

*** 更高的维度
Even Higher Dimensions

如果你觉得这个材料还不够让你头脑发热, 那么我们再上一层楼呢? 就像你可以将一个 2D 迷宫画到一个 3D 物体上一样, 你可以“画”一个 3D 迷宫到一个 4D 物体上. 这到底意味着什么? 这意味着你前面还有一些研究要做! *超立方体* (Tesseracts), *双圆柱体* (duocylinders), 和 *glomes* 只是你可能会遇到的一些疯狂的名字. 看看你能想出什么!

你现在对这些网格已经相当熟练了, 并且在上面构建迷宫也相当自在了. 你甚至可以在三维和四维中构建它们! 是时候学习一个新技巧了: 在*非平面* (non-planar) 表面上构建迷宫.

* 第 14 章：弯曲和折叠你的迷宫
*Bending and Folding Your Mazes*

这是一段疯狂的旅程, 但我们快到终点了. 迷宫算法, 源于非矩形镶嵌的网格, 圆形, 交织, 和辫子, 甚至在三维和四维中构建那些迷宫——所有这些都把我们带到了这一点.

让我们以一声巨响结束. 让我们震撼一些心灵.

考虑一下你到目前为止生成的那些迷宫, 它们都整齐地构建在平坦、可预测的表面上. 即使是三维的那些也是由整齐的平面层级组成的. 但如果你拿其中一个迷宫稍微*弯曲* (bend) 一下, 扭曲表面使其在一个或多个维度上弯曲会怎么样? 如果你甚至走得更远, 把它*折叠* (fold) 起来呢?

当走廊环绕一个球体的表面, 或者带你绕着一条丝带的内部时, 那些第一人称射击游戏就会有一种完全不同的感觉. 想象一个游戏, 你可以看到你的目标在头顶上的迷宫拱形处, 或者怪物可能就潜伏在不远处的通道里, 被一个不太遥远的地平线所隐藏!

这些就是所谓的*平面迷宫* (planair mazes), 对于一种不寻常的谜题来说, 这是一个不寻常的名字. 在圆柱体, 立方体, 圆锥体, 金字塔, 球体, 和环面上的迷宫都是这些平面迷宫的例子, 我得老实说: 这是一个可以轻易成为一整本书的主题. 我们只有时间尝尝鲜, 但希望那足以让你去探索更多.

在本章中, 我们将研究四种不同的表面: 圆柱体 (cylinders), 莫比乌斯带 (Möbius strips), 立方体 (cubes), 和球体 (spheres). 在每种情况下, 你都将学习如何在该表面上生成一个迷宫. 对于前三种, 我们将使用简单的纸艺技术来可视化生成的迷宫, 对于最后一种, 我们将借助一个 3D 渲染器来在球体表面上绘制我们的迷宫.

** 圆柱形迷宫
Cylinder Mazes

圆柱形迷宫是一个很好的起点, 因为它们实际上非常, 非常容易. 你可以通过生成一个矩形迷宫, 打印出来, 然后把它绕着一个汤罐包裹起来, 使两端接触, 来制作一个简单的, 像这样:

#+CAPTION: 一个被卷成圆柱形的矩形迷宫.

这种方法的问题在于, 你最终会在迷宫的东西边界相遇的地方留下一条接缝:

#+CAPTION: 一个带有明显接缝的圆柱形迷宫.

这听起来耳熟吗? 你可能还记得我们在*关于圆形迷宫的讨论结束时*, 第 110 页遇到了一个类似的问题. 我们可以用我们当时使用的同样技巧来解决这里的问题: 覆盖 `[]` 方法以确保 `column` 参数从一侧平滑地环绕到另一侧. 通过这种方式, 东部和西部边界上的列被认为是实际上相邻的.

我们的圆柱形网格实现的全部内容看起来像这样:

#+BEGIN_SRC ruby
cylinder_grid.rb
require 'grid'

class CylinderGrid < Grid
  def [](row, column)
    return nil unless row.between?(0, @rows - 1)
    column = column % @grid[row].count
    @grid[row][column]
  end
end
#+END_SRC

我们在这里做通常的练习, 并制作一个演示程序来测试它:

#+BEGIN_SRC ruby
cylinder_demo.rb
require 'cylinder_grid'
require 'recursive_backtracker'

grid = CylinderGrid.new(7, 16)
RecursiveBacktracker.on(grid)

filename = "cylinder.png"
grid.to_png.save(filename)
puts "saved to #{filename}"
#+END_SRC

生成的迷宫会看起来有点奇怪:

#+CAPTION: 一个扁平的、未卷曲的圆柱形迷宫.

不过请记住, 这个迷宫是打算*环绕*的, 所以东西边缘实际上应该是相邻的. 这里的尺寸是故意选择的, 以给出一个与汤罐标签相似的宽高比, 所以如果你愿意, 你可以将你的图像放大到大约 8.25" x 3.625" (21cm x 9.2cm), 打印出来, 并用它来伪装你食品储藏室里最不喜欢的罐头. 运气好的话, 厨师会被你圆柱形迷宫的无缝性所催眠, 以至于你能提出一些更可口的东西作为替代!

让我们把事情再提升一个档次, 考虑在一个莫比乌斯带上放置一个迷宫.

** 莫比乌斯迷宫
Möbius Mazes

莫比乌斯带 (Möbius strip) (有时拼写为 Moebius, 或 Mobius) 是一种只有一个面的新颖表面. 你可以很容易地制作一个, 方法是拿一条纸, 将一端扭转 180°, 然后将两端粘在一起. 结果 (假设你碰巧用了格子纸) 会看起来像这样:

#+CAPTION: 一个莫比乌斯带.

一只蚂蚁沿着这张纸条的表面爬行, 会发现它在回到起点之前已经遍历了两面. 像魔法一样!

这简直是在乞求在上面放一个迷宫, 事实证明我们用很少的努力就能做到. 它实际上非常像一个圆柱形迷宫, 但带有一个*扭转*——字面意思! 我们需要拿那个圆柱形迷宫, 给它一个 180° 的扭转. 困难就在这里. 一个圆柱形迷宫只需要存在于纸的一面, 因为它有一个明确定义的内部和外部. 添加那个扭转意味着我们的迷宫需要存在于*两面*, 以一种当我们将它扭转并连接两端时, 边缘和通道都能正确对齐的方式.

我们可以尝试通过生成两个图像, 每个对应于纸条的一面, 然后尝试将它们背靠背打印来做到这一点, 但让打印机正确地对齐两个图像将是一项极其繁琐的工作. 我们可以更容易地做到这一点.

首先, 我们在一个又长又薄的网格上生成我们的迷宫, 像下面这样:

#+CAPTION: 一个长而薄的网格上的迷宫.

然后, 我们将那个网格分成两半, 并生成一个两半并排的单一图像, 像这样:

#+CAPTION: 迷宫被分成两半, 并排排列.

在打印图像并剪掉多余的纸后, 我们将结果纵向对折, 这样迷宫的两半最终会背靠背:

#+CAPTION: 打印出的迷宫被对折.

这给了我们纸条两面的迷宫, 正是我们最后一步所需要的! 不仅如此, 像这样折叠纸张也使两半相对于彼此上下翻转, 这意味着当我们最终给纸张一个半扭转并连接两端时, 边缘被正确地定向. 是不是很巧妙? 去承认吧. 你正渴望尝试这个.

将以下内容放入 `moebius_grid.rb`.

#+BEGIN_SRC ruby
moebius_grid.rb
require 'cylinder_grid'

class MoebiusGrid < CylinderGrid
  def initialize(rows, columns)
    super(rows, columns*2)
  end

  def to_png(cell_size: 10, inset: 0)
    grid_height = cell_size * rows
    mid_point = columns / 2

    img_width = cell_size * mid_point
    img_height = grid_height * 2

    inset = (cell_size * inset).to_i

    background = ChunkyPNG::Color::WHITE
    wall = ChunkyPNG::Color::BLACK

    img = ChunkyPNG::Image.new(img_width + 1, img_height + 1, background)

    [:backgrounds, :walls].each do |mode|
      each_cell do |cell|
        x = (cell.column % mid_point) * cell_size
        y = cell.row * cell_size

        y += grid_height if cell.column >= mid_point

        if inset > 0
          to_png_with_inset(img, cell, mode, cell_size, wall, x, y, inset)
        else
          to_png_without_inset(img, cell, mode, cell_size, wall, x, y)
        end
      end
    end

    img
  end
end
#+END_SRC

我们子类化我们的 `CylinderGrid`, 这样我们就得到了东西向的环绕, 然后在构造函数中我们做了一些可能看起来有点奇怪的事情: 第 5 行告诉超类让我们的网格*两倍宽*于我们指定的. 这样做的目的是让我们能够说明纸条需要多长——然后自动为纸条的另一面补偿网格.

实现的其余部分只是我们更新的 `to_png` 方法. 它本质上是我们之前看到的, 但有一些调整. 在第 10 行, 我们计算我们将要分割网格的列. 那个中点用于在第 12 行确定图像的宽度, 之后的一行将图像的高度设置为网格高度的两倍. (回想一下, 我们正在渲染网格的两半, 一个在另一个之上.)

中点值也用于计算图像中每个单元格的位置. 第 24 行使用模运算来确保网格的两半都渲染在彼此旁边, 第 27 行将网格的下半部分移动到上半部分之下. 其他一切都和以前一样——调用适当的方法来绘制每个单元格, 并简单地传入坐标以确保单元格被绘制在它们应该在的地方.

使用以下代码来测试我们的新 `MoebiusGrid`.

#+BEGIN_SRC ruby
moebius_demo.rb
require 'moebius_grid'
require 'recursive_backtracker'

grid = MoebiusGrid.new(5, 50)
RecursiveBacktracker.on(grid)

filename = "moebius.png"
grid.to_png.save(filename)
puts "saved to #{filename}"
#+END_SRC

这里给出的网格尺寸是凭经验选择的, 以给出一个能整齐地扭曲和连接的条带, 但请随意实验不同的大小, 看看你得到了什么. 记住, 列数描述了条带*一面*的宽度——网格本身实际上会是两倍长!

从那个小程序中获取图像, 并通过前面描述的过程 (打印, 剪切, 折叠等), 你应该会得到类似下面的东西:

#+CAPTION: 一个完成的莫比乌斯带迷宫.

带它去你的下一次派对! 它会成为一个很棒的谈资.

** 立方体迷宫
Cube Mazes

接下来是立方体迷宫. 我们不是在讨论立方体*内部*的通道网络; 那会给我们带来我们在上一章中介绍过的 3D 迷宫. 相反, 我们在这里考虑的是纯粹在立方体*表面*上渲染的迷宫.

与圆柱形迷宫相比, 这些绝对是一个升级. 诚然, 它们与圆柱体有一些共同之处 (一只蚂蚁在立方体上可以愉快地绕一圈), 但还有更多. 为了帮助理解差异, 我们需要一种简单的方法来可视化立方体是如何构建的.

从想象一个立方体开始, 就像一个大的纸板箱. 如果你展开那个盒子, 把它在接缝处拆开并平放, 你最终会得到六个方形的面, 排列得像下图所示. 我们将这些面从零到五标记, 以便更容易地引用它们.

#+CAPTION: 图 9—一个展开的立方体

这里的目标是在每个面上画一个网格, 并安排事物, 使每个面边界上的单元格与相邻面边界上的单元格相邻.

** 实现立方体网格
Implementing a Cube Grid

这恰好提出了一种将立方体作为一个整体来表示的方法: 作为六个独立的面. 我们就这么做, 将每个面存储为不同的二维网格. 每个单元格将跟踪它所属的面, 行和列.

让我们继续实现这个. 将以下内容放入 `cube_grid.rb`.

#+BEGIN_SRC ruby
cube_grid.rb
require 'grid'

class CubeCell < Cell
  attr_reader :face

  def initialize(face, row, column)
    @face = face
    super(row, column)
  end
end

class CubeGrid < Grid
  alias dim rows

  def initialize(dim)
    super(dim, dim)
  end

  def prepare_grid
    Array.new(6) do |face|
      Array.new(dim) do |row|
        Array.new(dim) do |column|
          CubeCell.new(face, row, column)
        end
      end
    end
  end
end
#+END_SRC

这里没有真正的意外. `CubeCell` 子类化了 `Cell`, 只是添加了 `face` 属性. `CubeGrid` 的开始也几乎同样简单. 它将 `rows` 属性别名为 `dim` (即“维度”), 构造函数接受一个参数作为该值 (每个面上的行数和列数). `prepare_grid` 方法然后使用 `dim` 来为六个面中的每一个实例化一个 2D 网格.

这个实现可能看起来很像我们上一章的三维网格, 但不要被愚弄——立方体的表面实际上是二维的! 我们只是添加了那个第三个坐标——`face`——作为组织子网格的便利.

接下来, 我们将覆盖一些更多的方法来适应这个立方体几何的六个面. 在 `CubeGrid` 类中, 在 `prepare_grid` 方法之后, 也添加这些.

#+BEGIN_SRC ruby
  def each_face
    @grid.each do |face|
      yield face
    end
  end

  def each_row
    each_face do |face|
      face.each do |row|
        yield row
      end
    end
  end

  def random_cell
    face = rand(6)
    row = rand(dim)
    column = rand(dim)

    @grid[face][row][column]
  end

  def size
    6 * dim * dim
  end
#+END_SRC

这些将让我们能够迭代我们网格的面, 行和单元格, 以及随机选择一个单元格并计算网格中单元格的总数.

一旦我们有了这些, 我们就到达了最困难的部分: 确定单元格的邻接关系. 具体来说, 我们需要识别哪些单元格与边界上的其他单元格相邻, 这里有一些非常疯狂的边缘情况. 我们将在 `configure_cells` 和 `[]` 方法中像这样设置基础:

#+BEGIN_SRC ruby
  def configure_cells
    each_cell do |cell|
      face, row, column = cell.face, cell.row, cell.column

      cell.west = self[face, row, column-1]
      cell.east = self[face, row, column+1]
      cell.north = self[face, row-1, column]
      cell.south = self[face, row+1, column]
    end
  end

  def [](face, row, column)
    return nil if face < 0 || face >= 6
    face, row, column = wrap(face, row, column)
    @grid[face][row][column]
  end
#+END_SRC

这应该看起来都很熟悉, 除了数组访问器中高亮显示的那一行. 我们将添加一个新方法 `wrap`, 它接受给定的 face/row/column 三元组, 并且——如果行或列溢出了它所在的面——计算出它们溢出到的面上的实际坐标是什么. 这将允许 `configure_cells` 方法按预期工作, 它只是从行或列中加一或减一来获得正确的邻居, 即使那会越过到相邻的面.

这就是边缘情况出现的地方, 但它们并不都是坏的. 让我们从一个简单的开始. 再次考虑我们展开的立方体 (图 9, *一个展开的立方体*, 第 229 页), 并想象从面 0 移动到 1, 到 2, 到 3, 然后回到 0. 那里的过渡很直接——你会从一个面的最后一列, 到下一个面的第 0 列, 同时保持在同一行. 同样, 反向移动会把你从一个面的第一列带到下一个面的最后一列. 下图说明了这一点:

#+CAPTION: 一个展开的立方体, 显示了面 0, 1, 2 和 3 之间的水平过渡.

足够简单. 要是它们都能那么直接就好了! 让我们看一个更棘手的: 当你从面 #4 向东移动时会发生什么?

啊, 现在事情变得有趣了. 假设我们在面 #4 的最后一列, 在某一行 r, 我们想向东移动. 心里把立方体折叠起来, 你可以看到面 #4 的东边界实际上与面 #2 的*北*边界相邻. 这意味着在移动到面 #2 时, 我们从行 r 移动到列 n-r, 我们的行变成 0. (我们将让 n 是每个面上最后一行或一列的索引.) 看看:

#+CAPTION: 一个展开的立方体, 显示了从面 #4 到面 #2 的过渡.

哇哦!

花点时间考虑一下其他过渡, 比如从面 #5 向西移动, 或者 (也许最难想象的) 从面 #3 向北移动. 这些就是我们需要在我们新的 `wrap` 方法中封装的过渡类型. 一旦你让自己头疼地试图想象这些不同的连接, 就继续在 `CubeGrid` 类中添加以下内容:

#+BEGIN_SRC ruby
  def wrap(face, row, column)
    n = dim-1

    if row < 0
      return [4, column, 0]       if face == 0
      return [4, n, column]       if face == 1
      return [4, n-column, n]     if face == 2
      return [4, 0, n-column]     if face == 3
      return [3, 0, n-column]     if face == 4
      return [1, n, column]       if face == 5
    elsif row >= dim
      return [5, n-column, 0]     if face == 0
      return [5, 0, column]       if face == 1
      return [5, column, n]       if face == 2
      return [5, n, n-column]     if face == 3
      return [1, 0, column]       if face == 4
      return [3, n, n-column]     if face == 5
    elsif column < 0
      return [3, row, n]          if face == 0
      return [0, row, n]          if face == 1
      return [1, row, n]          if face == 2
      return [2, row, n]          if face == 3
      return [0, 0, row]          if face == 4
      return [0, n, n-row]        if face == 5
    elsif column >= dim
      return [1, row, 0]          if face == 0
      return [2, row, 0]          if face == 1
      return [3, row, 0]          if face == 2
      return [0, row, 0]          if face == 3
      return [2, 0, n-row]        if face == 4
      return [2, n, row]          if face == 5
    end

    [face, row, column]
  end
#+END_SRC

给定一个面, 行和列, 这个方法将计算并返回坐标对应的实际面, 行和列. 默认情况下——如果行和列在当前面的网格范围内——该方法只是返回参数值, 未经改变 (第 34 行). 但如果行或列小于 0, 或大于网格的维度, 魔法就发生了!

嗯, 并非真正的魔法. 例如, 考虑我们之前的简单情况. 假设我们在面 #1 的东边界上, 我们向东移动. 我们的面是 1, 我们的列现在等于 `dim`. (我们之前在列 `dim-1`——面的最后一列——然后向东移动, 加了一.) 这意味着 `wrap` 方法在第 25 行 (column >= dim) 处采用分支, 然后在第 27 行 (因为我们在面 #1 上) 处采用. 新的坐标被确定为面 #2, 列 0, 行与之前相同.

那么, 剩下要做的就是实现一种显示我们立方体网格的方法. 我们将覆盖 `to_png` 来生成一个图像, 其中立方体的面像图 9, *一个展开的立方体*, 第 229 页那样展开, 这将允许我们打印它, 剪下来, 并将它折叠成一个整洁的小立方体! 除了 `to_png`, 我们还需要覆盖 `to_png_without_inset` (做一个小小的改变), 我们将添加一个简单的方法来绘制立方体面的淡淡轮廓 (以帮助折叠).

我们将从 `to_png` 开始. 请在 `CubeGrid` 的末尾添加以下内容.

#+BEGIN_SRC ruby
  def to_png(cell_size: 10, inset: 0)
    inset = (cell_size * inset).to_i

    face_width = cell_size * dim
    face_height = cell_size * dim

    img_width = 4 * face_width
    img_height = 3 * face_height

    offsets = [,,,,,]

    background = ChunkyPNG::Color::WHITE
    wall = ChunkyPNG::Color::BLACK
    outline = ChunkyPNG::Color.rgb(0xd0, 0xd0, 0xd0)

    img = ChunkyPNG::Image.new(img_width + 1, img_height + 1, background)

    draw_outlines(img, face_width, face_height, outline)

    [:backgrounds, :walls].each do |mode|
      each_cell do |cell|
        x = offsets[cell.face] * face_width + cell.column * cell_size
        y = offsets[cell.face] * face_height + cell.row * cell_size

        if inset > 0
          to_png_with_inset(img, cell, mode, cell_size, wall, x, y, inset)
        else
          to_png_without_inset(img, cell, mode, cell_size, wall, x, y)
        end
      end
    end

    img
  end
#+END_SRC

它与我们原始的 `to_png` 方法非常相似, 有一些小小的改变. 第 4 行和第 5 行计算单个面的尺寸, 然后在第 7 行和第 8 行用于计算整个图像的尺寸.

从概念上讲, 我们正在将面与一个三行四列的网格对齐, 所以我们将用它来更容易地定位每个面. 第 10 行的 `offsets` 变量描述了每个面在该更大网格中的位置 (列和行). 第 22 行和第 23 行使用那些偏移来计算每个单元格的位置.

另外, 注意在第 18 行调用我们新的 `draw_outlines` 方法. 没有那个调用, 我们的迷宫也完全可以接受, 但这将围绕每个面添加一些淡淡的轮廓, 帮助我们在剪下迷宫后更好地知道在哪里折叠.

事实上, 让我们接下来看看那个方法. 在我们的 `to_png` 方法之后立即添加以下内容.

#+BEGIN_SRC ruby
  def draw_outlines(img, height, width, outline)
    # face #0
    img.rect(0, height, width, height*2, outline)

    # faces #2 & #3
    img.rect(width*2, height, width*4, height*2, outline)
    # line between faces #2 & #3
    img.line(width*3, height, width*3, height*2, outline)

    # face #4
    img.rect(width, 0, width*2, height, outline)

    # face #5
    img.rect(width, height*2, width*2, height*3, outline)
  end
#+END_SRC

它非常简单——只是用我们的轮廓颜色 (一种浅灰色) 绘制一些矩形和线条.

最后要看的一点是我们对 `to_png_without_inset` 的重新实现. 默认的实现只会在单元格在那些方向上没有邻居时才绘制单元格的北墙或西墙. 不过, 这对我们的立方体迷宫来说是不够的! 一个单元格可能有一个北邻居, 但那个邻居可能在另一个面上. 因为我们正在绘制迷宫的方式, 那两个邻居将不会用共享的墙来绘制...这意味着墙将不会被绘制. 我们不能那样!

请在 `draw_outlines` 方法之后立即添加以下方法.

#+BEGIN_SRC ruby
  def to_png_without_inset(img, cell, mode, cell_size, wall, x, y)
    x1, y1 = x, y
    x2 = x1 + cell_size
    y2 = y1 + cell_size

    if mode == :backgrounds
      color = background_color_for(cell)
      img.rect(x, y, x2, y2, color, color) if color
    else
      if cell.north.face != cell.face && !cell.linked?(cell.north)
        img.line(x1, y1, x2, y1, wall)
      end

      if cell.west.face != cell.face && !cell.linked?(cell.west)
        img.line(x1, y1, x1, y2, wall)
      end

      img.line(x2, y1, x2, y2, wall) unless cell.linked?(cell.east)
      img.line(x1, y2, x2, y2, wall) unless cell.linked?(cell.south)
    end
  end
#+END_SRC

注意高亮的行——那是我们的新版本与原始版本的不同之处, 确保即使一个单元格在那些方向上有邻居, 只要它们碰巧在不同的面上, 墙壁也会被绘制.

好了! 我们现在应该能够通过编写一个简单的演示程序来测试它了, 像下面这样.

#+BEGIN_SRC ruby
cube_demo.rb
require 'cube_grid'
require 'recursive_backtracker'

grid = CubeGrid.new(10)
RecursiveBacktracker.on(grid)

filename = "cube.png"
grid.to_png.save(filename)
puts "saved to #{filename}"
#+END_SRC

运行它应该会生成一个像下面这样的图像:

#+CAPTION: 一个 10x10 的立方体迷宫, 展开.

打印出来, 并小心地沿着迷宫的外部剪切. 然后, 在所有的灰线上折叠, 边走边 liberally 地用胶带粘起来以保持所有东西在一起, 当一切都完成后, 你可能会得到一个像这样令人眼花缭乱的东西:

#+CAPTION: 一个折叠和粘合的立方体迷宫.

但现在是时候告别纸艺了. 对于我们的最后一个表面, 我们将寻找一种方法来生成我们迷宫的实际 3D 渲染, 这次是在一个球体的表面上.

** 球形迷宫
Sphere Mazes

在球体表面上创建迷宫与在圆形内部创建迷宫有很多共同之处. 这不应该令人惊讶! 毕竟, 半球只是一个被其原点抬起的圆, 像这样:

#+CAPTION: 一个圆被挤压成一个半球.

我们可以通过将两个半球放在一起来创建一个球体, 这意味着我们应该能够通过依赖我们的极坐标网格 (来自第 7 章, *兜圈子*, 第 97 页) 来实现一个球形网格. 我们需要更改许多关于测量单元格的计算 (半球可能与圆形有关, 但这并不意味着它们穿同样尺码的衬衫), 我们的 `to_png` 方法需要重写, 但这是一个开始.

所以这是我们将要做的. 我们将子类化我们的 `PolarGrid` 来制作一个 `HemisphereGrid`, 然后将其中两个粘合在一起制作一个 `SphereGrid`. 为方便起见, 我们将把所有这些都放在同一个文件中.

让我们从 `HemisphereGrid` 开始. 将以下内容放入 `sphere_grid.rb`:

#+BEGIN_SRC ruby
sphere_grid.rb
require 'polar_grid'

class HemisphereCell < PolarCell
  attr_reader :hemisphere

  def initialize(hemisphere, row, column)
    @hemisphere = hemisphere
    super(row, column)
  end
end

class HemisphereGrid < PolarGrid
  attr_reader :id

  def initialize(id, rows)
    @id = id
    super(rows)
  end

  def size(row)
    @grid[row].length
  end

  def prepare_grid
    grid = Array.new(@rows)

    angular_height = Math::PI / (2 * @rows)

    grid = [ HemisphereCell.new(id, 0, 0) ]

    (1...@rows).each do |row|
      theta = (row + 1) * angular_height
      radius = Math.sin(theta)
      circumference = 2 * Math::PI * radius

      previous_count = grid[row - 1].length
      estimated_cell_width = circumference / previous_count
      ratio = (estimated_cell_width / angular_height).round

      cells = previous_count * ratio
      grid[row] = Array.new(cells) { |col| HemisphereCell.new(id, row, col) }
    end

    grid
  end
end
#+END_SRC

我们的 `HemisphereCell` 类足够简单——它只是子类化了 `PolarCell`, 并添加了一个用于跟踪单元格属于哪个半球的属性 (第 4 行).

`HemisphereGrid` 类也相当直接——添加了一个 `id` 属性来指示正在表示两个半球中的哪一个 (第 13 行), 以及一个用于查询给定行中单元格数量的简单方法 (第 20 行).

我们的 `prepare_grid` 方法是我们开始搞数学的地方. 在概念上, 它与 `PolarGrid` 的相同方法非常相似, 但计算已经适应了球面. 特别是, 注意 `angular_height` 变量 (第 27 行), 这是每行以*弧度*为单位的高度. (在一个奇特的数学命运转折中, 这也恰好是如果我们把它构建在一个单位球体上时行之间的物理距离.)

然后, 在第 32-34 行, 该 `angular_height` 被用来计算由给定行描述的圆的半径, 最终告诉我们那一行应该有多少个单元格.

好了! 现在我们有了半球形网格的一个很好的定义, 我们可以用它来构建我们的球体. 在 `HemisphereGrid` 之后, 将以下内容添加到同一个文件中.

#+BEGIN_SRC ruby
class SphereGrid < Grid
  def initialize(rows)
    unless rows.even?
      raise ArgumentError, "argument must be an even number"
    end

    @equator = rows / 2
    super(rows, 1)
  end

  def prepare_grid
    Array.new(2) { |id| HemisphereGrid.new(id, @equator) }
  end

  def configure_cells
    belt = @equator - 1
    size(belt).times do |index|
      a, b = self[0, belt, index], self[1, belt, index]
      a.outward << b
      b.outward << a
    end
  end

  def [](hemi, row, column)
    @grid[hemi][row, column]
  end

  def size(row)
    @grid.size(row)
  end

  def each_cell
    @grid.each do |hemi|
      hemi.each_cell { |cell| yield cell }
    end
  end

  def random_cell
    @grid.sample.random_cell
  end
end
#+END_SRC

首先, 构造函数检查为网格指定的行数是否为偶数 (第 3 行). 这是因为我们正在使用两个半球来实现整个球体, 所以总行数需要能被二整除. 赤道线接下来被计算 (第 7 行), 并在 `prepare_grid` 方法中用于初始化两个半球 (第 12 行).

记住, 那些 `HemisphereGrid` 实例已经配置好了它们自己的单元格, 但那还不够. 我们需要告诉那些半球赤道上的单元格它们彼此相邻. 这就是 `configure_cells` 在第 17-21 行所做的.

其余的方法是不言自明的, 只是提供了查询网格单元格的方法.

差不多了! 我们仍然缺少那个会绘制我们迷宫的 `to_png` 方法, 但我们把它留到最后是有原因的. 我们将在这里做一些稍微不同的事情.

** 安装 POV-Ray
Installing POV-Ray

除非你以前玩过 POV-Ray, 否则你可能还没有安装它. 幸运的是, 它是免费的, 而且设置起来相当轻松. 如果你在 Windows 机器上, 你可以从 http://povray.org/download 下载一个安装程序.

如果你在 Mac OS X 上, 你可以使用 Homebrew:ª

#+BEGIN_SRC sh
$ brew install povray
#+END_SRC

或 MacPorts:ᵇ

#+BEGIN_SRC sh
$ sudo port install povray
#+END_SRC

如果你在 Linux 上, POV-Ray 将通过你的包管理器提供.

ª. http://brew.sh
ᵇ. https://www.macports.org

我们将使用同样的技术来绘制我们的迷宫, 扭曲靠近极点的单元格以适应一个矩形网格. 然后, POV-Ray 将采用该投影并将其应用到一个球体上, 像模型飞机上的贴花一样整齐地包裹在地球上, 并一次性修复失真. 这让我们能够通过绘制一个 2D 图像, 一种我们已经非常熟悉的技术, 来在 3D 表面上渲染一个迷宫.

事情是这样组合在一起的. 将以下 `to_png` 方法添加到 `SphereGrid` 类的末尾.

#+BEGIN_SRC ruby
  def to_png(ideal_size: 10)
    img_height = ideal_size * @rows
    img_width = @grid.size(@equator - 1) * ideal_size

    background = ChunkyPNG::Color::WHITE
    wall = ChunkyPNG::Color::BLACK

    img = ChunkyPNG::Image.new(img_width + 1, img_height + 1, background)

    each_cell do |cell|
      row_size = size(cell.row)
      cell_width = img_width.to_f / row_size

      x1 = cell.column * cell_width
      x2 = x1 + cell_width

      y1 = cell.row * ideal_size
      y2 = y1 + ideal_size

      if cell.hemisphere > 0
        y1 = img_height - y1
        y2 = img_height - y2
      end

      x1 = x1.round; y1 = y1.round
      x2 = x2.round; y2 = y2.round

      if cell.row > 0
        img.line(x2, y1, x2, y2, wall) unless cell.linked?(cell.cw)
        img.line(x1, y1, x2, y1, wall) unless cell.linked?(cell.inward)
      end

      if cell.hemisphere == 0 && cell.row == @equator - 1
        img.line(x1, y2, x2, y2, wall) unless cell.linked?(cell.outward)
      end
    end

    img
  end
#+END_SRC

`ideal_size` 参数 (第 1 行) 是一个理想单元格应该有多高和多宽——但请记住我们在那张世界地图上看到的失真! 我们将在我们的迷宫中看到同样类型的失真. 目标不是让单元格在我们的投影中都被画成相同的大小, 而是让它们一旦我们把它映射到一个球体上后大小大致相似.

那个 `ideal_size` 参数用于在第 2 行和第 3 行计算我们图像的大小. 特别是, 注意计算宽度的那一行: 它取赤道上的行数 (单元格数量最多的行) 并用它来确定图像应该有多宽. 当我们去计算一个特定单元格有多宽时 (在第 12 行), 那个图像宽度被除以当前行中的实际单元格数. 如果行中很少有单元格, 结果可能会比理想尺寸宽得多. (特别记住两极——它们每个只有一个单元格!)

一旦我们知道了我们单元格的尺寸, 我们就计算矩形每个角的 x 和 y 坐标, 然后我们做了一些可能有点出乎意料的事情. 第 20-23 行*翻转了南半球的 y 坐标*.

嗯?

记住我们的球体由两个半球组成, 而我们的 `HemisphereGrid` 类的实现方式, 每个半球都将极点视为顶部. 然而, 我们已经将南半球上下颠倒了, 所以我们在那里的计算是向后的. 我们通过简单地从图像的高度中减去计算出的 y 坐标来修复它.

最后一个小问题: 我们为每个单元格画“顶” (或朝向极点) 的墙, 假设下一行将处理“底” (朝向赤道) 的墙. 然而, 当涉及到赤道本身时, 它恰好是两个半球的底部, 如果我们不特别考虑它, 它会被完全忽略. 第 33-35 行确保赤道被绘制.

让我们试一试. 我们的演示应用现在应该完全不令人意外了:

#+BEGIN_SRC ruby
sphere_demo.rb
require 'sphere_grid'
require 'recursive_backtracker'

grid = SphereGrid.new(20)
RecursiveBacktracker.on(grid)

filename = "sphere-map.png"
grid.to_png.save(filename)
puts "saved to #{filename}"
#+END_SRC

运行它将生成我们的迷宫图像并将其保存到 `sphere-map.png`. 去打开它. 它应该看起来像这样:

#+CAPTION: 一个用于球体的圆柱投影迷宫.

是不是很狂野? 两极都是单个单元格, 所以那些单元格被拉伸到边到边, 失真随着行接近赤道而越来越小.

这绝对很有趣, 但还不是很有用. 我们需要把它应用到一个球体上才能看到它的全部荣耀!

这就是 POV-Ray 发挥作用的地方. POV-Ray 接受一个描述场景的文本文件, 并创建相应的图像. 为了有用, 我们的场景将需要包括一个相机 (从中绘制图像的场景内的位置), 一个光源 (以照亮我们的球体), 和球体本身.

将以下内容放入 `sphere.pov`.

#+BEGIN_SRC povray
sphere.pov
#version 3.7;
#include "colors.inc"

background { color White }

camera {
  location <0,0,-2.5>
  look_at <0,0,0>
}

light_source {
  <-50, 50, -50>
  color White
}

sphere {
  <0,0,0>, 1
  texture {
    pigment {
      image_map {
        png "sphere-map.png"
        map_type 1
      }
    }
    finish { ambient 0.3 diffuse 0.5 specular 0.2 }
  }

  rotate z*30
  rotate -x*30
}
#+END_SRC

不深入 POV-Ray 的场景描述语言, 让我只指出 (希望) 显而易见的事情: 场景包括一个相机, 一个光源, 和一个球体. 然后它将我们的 `sphere-map.png` 图像作为纹理应用到那个球体上 (连同一些材质属性, 比如漫反射和镜面照明), 最后以一个俏皮的角度旋转球体.

要生成这个场景的图像, 我们只需从命令行调用 POV-Ray, 像这样:

#+BEGIN_SRC sh
$ povray +A sphere.pov
...
POV-Ray finished
#+END_SRC

我们传入场景文件 `sphere.pov` 作为参数之一. 另一个参数 `+A`, 告诉 POV-Ray 对图像进行抗锯齿处理, 这样球体的边缘和迷宫的线条就会被平滑, 看起来清晰整洁.

POV-Ray 在渲染时会输出相当多的信息, 所以不要惊慌——它按预期工作. 当一切都完成后, 最终的图像将被保存到 `sphere.png`.

#+CAPTION: 一个渲染在球体表面的迷宫.

Voilà!

** 轮到你了
Your Turn

所以我们来到了这次短暂地涉足平面迷宫海洋的尽头. 你已经看到了如何在像圆柱体, 莫比乌斯带, 立方体, 和球体这样的表面上构建它们, 你已经通过在真实和虚拟空间中构建那些物体来锻炼了你的纸艺和 3D 建模技能. 你能听到可能性在呼唤你了吗?

试试下面的想法, 或者追逐一些你自己的. 看看你能想出什么!

*** 渲染圆柱形迷宫
Rendering Cylinder Mazes

所以你已经看到了如何使用 POV-Ray 来绘制一个带迷宫的球体. 为一个圆柱体这样做非常相似. POV-Ray 文档¹相当平易近人, 尽管它声称是“为 Unix 设计的” (它实际上适用于所有平台). 仔细看看, 看看你是否能弄清楚如何拿你为球形迷宫所拥有的东西, 为一个圆柱体做同样的事情.

*** 矩形棱柱
Rectangular Prisms

一个立方体只是一个更通用的形状, 称为*矩形棱柱* (rectangular prism) 的特例. 想象拿一个立方体, 并沿着一个或多个轴拉伸它, 这样面就不再都是形状或面积相等的了. 结果不再是一个立方体, 但它仍然是一个棱柱! 你将如何在一个这样的表面上绘制一个迷宫?

*** 圆锥形迷宫
Cone Mazes

你已经做过圆形迷宫和圆柱形迷宫. 如果你把两者结合起来会怎么样? 你最终会得到一个*圆锥形迷宫* (cone maze). 你将如何着手在这样一个形状的表面上实现一个迷宫?

*** 端盖
End Caps

我们在本章中看到的圆柱形迷宫纯粹存在于圆柱体的侧面. 也就是说, 圆柱体是*开放的*, 因为它在顶部和底部没有盖子. 但这些盖子是圆形的...而你恰好知道如何生成圆形迷宫. 你将如何将两个圆形迷宫合并到一个圆柱形迷宫中, 作为圆柱体的顶盖和底盖?

*** 奇数行数
An Odd Number of Rows

我们的球形迷宫实现要求你给它一个偶数行数, 这样两个半球可以平等地代表球体的两半. 你仍然可以用奇数行数来使那工作, 但你需要将赤道行视为一个特殊情况. 你将如何解决那个?

*** 真实的墙壁
Real Walls

将迷宫画到这些表面上绝对很有趣, 但这只是第一步. 你将如何着手为墙壁生成*实际的几何形状*? 这不像听起来那么难, 但你需要确保你理解了用于推导这些网格测量值的数学. 这一切都归结为两件事: 能够将你迷宫中的一个点映射到表面上的一个物理点, 以及能够计算那个点的*法向量* (normal vector)——即垂直于给定位置的表面的方向.

*** 四维物体
Four-Dimensional Objects

如果这个材料还没有让你足够头脑发热, 那我们再上一层楼呢? 就像你可以将一个 2D 迷宫画到一个 3D 物体上一样, 你可以“画”一个 3D 迷宫到一个 4D 物体上. 这到底意味着什么? 这意味着你前面还有一些研究要做! *超立方体* (Tesseracts), *双圆柱体* (duocylinders), 和 *glomes* 只是你可能会遇到的一些疯狂的名字. 看看你能想出什么!

¹ http://www.povray.org/documentation

你现在对这些网格已经相当熟练了, 并且在上面构建迷宫也相当自在了. 你甚至可以在三维和四维中构建它们! 是时候学习一个新技巧了: 在*非平面* (non-planar) 表面上构建迷宫.

你已经完成了, 我的朋友. 你已经深入到随机迷宫生成的海洋中, 你已经从另一边浮出水面. 你在那里没有发现魔法——只有规则, 和逻辑, 和一个广阔的*可能性*的海洋.

你已经尝到了滋味. 你已经瞥见了用这些工具可能做到的事情. 你接下来要去哪里?

无论它在哪里, 我希望有迷宫.

* 附录 1
** 迷宫算法总结
Summary of Maze Algorithms

除非你经常使用这些算法, 否则你很可能会发现对它们的记忆随着时间的推移而淡忘. 没关系! 你已经学过一次了; 通常你只需要一点点复习就能让它们重新清晰地回到你的脑海中. 本附录的全部目的就是帮助你跳过完整的课程, 快速回顾每种算法的显著特点和注意事项. 浏览它们, 略读下一附录中的分析, 然后直接回到你自己的项目中去!

*** Aldous-Broder

*简而言之 (In a nutshell):* 从网格中的任意位置开始, 在单元格之间随机移动. 如果移动到先前未访问过的单元格, 就开辟一条通道. 当所有单元格都被访问过后结束.

#+CAPTION: Aldous-Broder 算法生成的迷宫示例及其着色版本.

*典型特征 (Typical features):* 启动速度快, 但可能需要很长时间才能完成. 值得注意的是, 它是*无偏倚的 (unbiased)*, 意味着它保证能完美地随机生成迷宫, 不偏好任何特定的纹理或特征. (也请参见 Wilson 算法.)

*更多信息 (More information):* *Aldous-Broder 算法*, 见第 55 页.

*** Binary Tree

*简而言之 (In a nutshell):* 对于网格中的每个单元格, 随机向北或向东开辟通道.

#+CAPTION: Binary Tree 算法生成的迷宫示例及其着色版本.

*典型特征 (Typical features):* 强烈的对角线纹理, 倾向于网格的东北角. 走廊贯穿北行和东列的整个长度. 难以与掩码和一些非矩形网格一起使用.

*变体 (Variations):* 如果你选择南而不是北, 或者西而不是东, 纹理会改变. 此外, 该算法很容易适应 3D (及更高) 网格, 方法是在每个单元格处添加向上或向下作为选择.

*更多信息 (More information):* *二叉树算法*, 见第 6 页, 以及*实现二叉树算法*, 见第 22 页.

*** Eller's

*简而言之 (In a nutshell):* 一次一行, 按顺序考虑网格. 将当前行中未访问的单元格分配到不同的集合中. 随机链接属于不同集合的相邻单元格, 并在链接时合并集合. 对于每个剩余的集合, 选择至少一个单元格并向南开辟, 同时将该南向单元格也添加到该集合中. 对网格中的每一行重复此过程. 在最后一行, 链接所有属于不同集合的相邻单元格.

#+CAPTION: Eller's 算法生成的迷宫示例及其着色版本.

*典型特征 (Typical features):* 最后一行由于需要合并多个集合, 往往墙壁较少. 难以与掩码和非矩形网格一起使用.

*变体 (Variations):* 通过一次只在内存中保留一行并且从不渲染最后一行, 来渲染一个无限长的迷宫.

*更多信息 (More information):* *Eller 算法*, 见第 189 页.

*** Growing Tree

*简而言之 (In a nutshell):* 这个算法是 Prim 算法的泛化. 首先创建一个集合并向其中添加一个任意单元格. 然后, 从集合中选择一个单元格. 如果该单元格没有未访问的邻居, 就将其从集合中移除; 否则选择一个未访问的邻居并将两者链接在一起. 将该邻居添加到集合中. 重复直到集合为空.

#+CAPTION: Growing Tree 算法生成的三种不同迷宫及其着色版本.

*典型特征 (Typical features):* 很大程度上取决于用于从集合中选择下一个单元格的方法. 迷宫可以是径向纹理的 (像*简化 Prim 算法*), 也可以是扭曲和蜿蜒的 (像*递归回溯算法*), 或者介于两者之间.

*变体 (Variations):* 改变从集合中选择单元格的方式. 随机选择会得到*简化 Prim 算法*. 选择最近添加的单元格会得到*递归回溯算法*. 对单元格进行加权并选择最重的会得到*真实 Prim 算法*. 组合不同的选择方法以获得更大的多样性, 例如, 一半时间随机选择, 另一半时间选择最近添加的.

*更多信息 (More information):* *生长树算法*, 见第 183 页.

*** Hunt-and-Kill

*简而言之 (In a nutshell):* 从任意位置开始, 进行一次随机行走, 避免访问已经访问过的单元格. 当无法再移动时, 扫描网格, 寻找一个与已访问单元格相邻的未访问单元格. 如果找到, 连接两者, 并恢复随机行走. 当找不到任何未访问的单元格时, 算法终止.

#+CAPTION: Hunt-and-Kill 算法生成的迷宫示例及其着色版本.

*典型特征 (Typical features):* 长而曲折的通道 (“high river”), 死胡同相对较少. 与*递归回溯算法*密切相关, 但可能更慢, 因为它可能多次扫描每个单元格, 不过它的内存需求要低得多.

*更多信息 (More information):* *Hunt-and-Kill 算法*, 见第 67 页.

*** Kruskal's (Randomized)

*简而言之 (In a nutshell):* 首先将每个单元格分配到不同的集合中. 随机链接两个相邻的单元格, 但前提是它们属于不同的集合. 合并这两个单元格的集合. 重复直到只剩下一个集合.

#+CAPTION: Kruskal's (Randomized) 算法生成的迷宫示例及其着色版本.

*典型特征 (Typical features):* 大体上是无偏倚的 (参见*附录 2, 迷宫算法比较*, 第 257 页, 并注意 Kruskal 的迷宫与 Aldous-Broder 和 Wilson 生成的迷宫有多相似). 生成非常规则, 均匀的迷宫. 擅长生成由不相交子集联合而成的迷宫, 其中网格预先填充了一些已在不同区域连接的单元格.

*变体 (Variations):* 模板迷宫 (通过在网格的不同位置应用模板设计, 然后运行 Kruskal 算法来填充未完成的区域), 带有螺旋, 交织和其他图案.

*更多信息 (More information):* *Kruskal 算法*, 见第 158 页.

*** Prim's (Simplified)

*简而言之 (In a nutshell):* 用一个任意单元格初始化一个集合. 从集合中随机选择一个单元格. 如果它没有未访问的邻居, 就将其从集合中移除. 否则, 选择单元格的一个未访问的邻居, 将两者链接在一起, 并将该邻居添加到集合中. 重复直到集合为空.

#+CAPTION: Prim's (Simplified) 算法生成的迷宫示例及其着色版本.

*典型特征 (Typical features):* 以起始单元格为中心的强烈径向纹理. 迷宫往往比其他算法有更多的死胡同和更短的路径. 如果给该算法一个每个单元格权重都相同的网格, 它的行为与 *Prim's (True)* 完全相同.

*更多信息 (More information):* *简化 Prim 算法*, 见第 179 页.

*** Prim's (True)

*简而言之 (In a nutshell):* 首先, 给每个单元格分配一个随机权重, 并用一个任意单元格初始化一个集合. 从集合中选择权重最大的单元格. 如果它没有未访问的邻居, 就将其从集合中移除. 否则, 选择单元格的一个未访问的邻居, 将两者链接在一起, 并将该邻居添加到集合中. 重复直到集合为空.

#+CAPTION: Prim's (True) 算法生成的迷宫示例及其着色版本.

*典型特征 (Typical features):* 每个迷宫有非常多的死胡同, 路径通常相对较短. 从纹理上看, 迷宫呈现出一种“拼图”的外观.

*更多信息 (More information):* *真实 Prim 算法*, 见第 181 页.

*** Recursive Backtracker

*简而言之 (In a nutshell):* 从任意位置开始, 进行一次随机行走, 避免访问已经访问过的单元格. 当无法再移动时, 回溯到最近访问过的单元格, 并从那里恢复随机行走. 当它试图从它开始的单元格回溯时, 算法结束.

#+CAPTION: Recursive Backtracker 算法生成的迷宫示例及其着色版本.

*典型特征 (Typical features):* 长而曲折的通道 (“high river”), 死胡同相对较少. 与 *Hunt-and-Kill* 密切相关, 但可能更快, 因为它保证每个单元格只访问两次, 不过它需要相当多的内存来跟踪先前访问过的单元格.

*更多信息 (More information):* *递归回溯算法*, 见第 73 页.

*** Recursive Division

*简而言之 (In a nutshell):* 从一个没有内部墙壁的开放网格开始. 添加一堵墙, 将网格分成两半, 中间有一个通道连接两半. 在网格的每一侧递归地重复, 直到没有开放区域剩下.

#+CAPTION: Recursive Division 算法生成的迷宫示例及其着色版本.

*典型特征 (Typical features):* 倾向于具有方块状, 矩形的纹理. 解法路径通常很容易发现, 因为“瓶颈”——限制所有区域之间通行的通道.

*变体 (Variations):* 通过提前停止递归, 可以创建开放区域 (房间) 以产生让人联想到平面图的迷宫. 更具挑战性的是: 网格可以沿着不规则的线分割以消除方块状的纹理.

*更多信息 (More information):* *递归分割*, 见第 197 页.

*** Sidewinder

*简而言之 (In a nutshell):* 一次考虑网格的一行. 对于每一行, 链接相邻单元格的随机游程, 然后从每个游程中的一个随机单元格向北开辟. 特殊处理北行, 将所有单元格链接成一条单一的走廊.

#+CAPTION: Sidewinder 算法生成的迷宫示例及其着色版本.

*典型特征 (Typical features):* 强烈的垂直纹理. 一条走廊贯穿北行的整个长度. 难以与掩码和非矩形网格一起使用.

*变体 (Variations):* 如果你选择南而不是北, 或者如果你按列而不是按行运行算法并选择东或西而不是北, 纹理会改变. 此外, 该算法很容易适应 3D (及更高) 网格, 方法是在每次运行时在北和 (例如) 上或下之间进行选择.

*更多信息 (More information):* *Sidewinder 算法*, 见第 12 页, 以及*实现 Sidewinder 算法*, 见第 27 页.

*** Wilson's

*简而言之 (In a nutshell):* 选择一个任意单元格并将其添加到迷宫中. 从任何其他单元格开始, 进行一次*循环擦除* (loop-erased) 的随机行走, 直到你遇到一个属于迷宫的单元格, 然后添加生成的行走. 重复直到所有单元格都被添加.

#+CAPTION: Wilson's 算法生成的迷宫示例及其着色版本.

*典型特征 (Typical features):* 启动慢, 但随着路径被添加到迷宫中而迅速加速. 与 *Aldous-Broder* 一样, 它是*无偏倚的 (unbiased)*, 意味着它保证能完美地随机生成迷宫, 不偏好任何特定的纹理或特征.

*更多信息 (More information):* *Wilson 算法*, 见第 60 页.

* 附录 2：迷宫算法比较
Comparison of Maze Algorithms

盯着一个迷宫看并试图判断其美学是否适合你是一回事. 查看一个算法的实现并定量地将其与其他算法进行比较则要困难得多. 该算法生成死胡同的可能性有多大? 其平均最长路径与其他算法相比如何? 我们究竟如何才能知道这些事情呢?

为此, 我们求助于统计学. 这其实相当直接: 你在固定大小的网格上, 多次运行每个算法; 挑出你关心的数据; 然后分析它们. 这可能不会为你赢得任何博士学位, 而且这些数字本身肯定不会告诉你完整的故事, 但我们仍然可以从中得出一些有用的见解.

本附录中的图表是通过在 32×32 的网格上, 每种算法运行一千次创建的. 生长树 (Growing Tree) 算法采用了 50/50 的混合策略, 即一半时间选择最近添加的单元格, 一半时间随机选择一个单元格. 对每个网格测量并平均了以下数据点:

- 死胡同的数量
- 最长路径的长度 (包含的单元格数量)
- 具有水平或垂直通道的单元格数量 (东西向, 和南北向)
- “肘形”单元格的数量 (通道从一侧进入, 然后向右或向左转)
- 三向交叉口的数量
- 四向交叉口的数量

然后, 每个数字都被转换成整个网格的一部分. 例如, 如果某个特定迷宫的最长路径为 250 个单元格, 那么该数字将被除以网格中的单元格总数 (32×32, 或 1024), 以得出大约 0.244. 换句话说, 那条路径将覆盖网格中 24.4% 的单元格.

由于 Aldous-Broder 和 Wilson 算法是无偏倚的 (并且它们的输出在统计上彼此相同), 它们的平均值被用作比较所有其他算法的基线. 不过请记住, 平均值只讲述了故事的一部分! 这些图表中的数字可能隐藏着一些令人惊讶的事情, 这些事情可以通过更严格的分析来揭示. 你已被警告.

** 死胡同
Dead Ends

死胡同被定义为仅与一个邻居相连的单元格. 更少的死胡同和一条长路径可能暗示着可以让人走得很远的冗长支路.

下图显示了不同算法下每个迷宫的死胡同数量比较.

#+CAPTION: 各算法的死胡同数量比较

Aldous-Broder 和 Wilson 算法倾向于生成大约 30% 单元格为死胡同的迷宫. 真实 Prim (True Prim's) 算法产生的死胡同数量比这多约 50%, 而 Hunt-and-Kill 和递归回溯 (Recursive Backtracker) 算法产生的则显著更少.

** 最长路径
Longest Path

最长路径是使用 Dijkstra 算法计算的, 如*制作更具挑战性的迷宫*, 第 44 页所述. 在下图中, 它表示为迷宫中位于该最长路径上的单元格百分比.

#+CAPTION: 各算法的最长路径长度比较

递归回溯 (Recursive Backtracker) 在这里遥遥领先, 平均有 50% 的网格单元格存在于最长路径上. 简化 Prim (Simplified Prim's) 算法则位于另一端, 其最长路径覆盖的单元格不到 10%.

** 曲折度
Twistiness

曲折度是衡量通道改变方向频率的指标. 它被计算为通道从一侧进入, 并从左侧或右侧退出的单元格百分比.

#+CAPTION: 各算法的曲折度比较

Hunt-and-Kill 在这里拔得头筹, 紧随其后的是递归回溯 (Recursive Backtracker), 迷宫中大约有一半的单元格符合这一定义. 另一方面, 真实 Prim (True Prim's) 算法只有大约 10% 的时间会转弯.

** 笔直度
Directness

笔直度是曲折度的反义词. 它是衡量网格中有多少单元格是直行, 要么水平要么垂直的指标.

#+CAPTION: 各算法的笔直度比较

不过, 这可以被进一步分解, 通过分别显示水平通道和垂直通道的数字. 下图显示了每个迷宫中水平通道的相对数量.

#+CAPTION: 各算法的水平通道相对数量

下图给出了垂直通道的相应数据.

#+CAPTION: 各算法的垂直通道相对数量

正如你所预料的, 水平通道和垂直通道的基线几乎相同, 但这里有两个特别有趣的数据点是递归分割 (Recursive Division) 和 Eller 算法. 两者似乎都*极其*偏好垂直通道而非水平通道! Hunt-and-Kill 和 Sidewinder 也显示出一些类似的偏好.

** 交叉口
Intersections

最后, 交叉口给出了穿越迷宫时需要做决策的频率的指示. 下图显示了每种算法的三向交叉口的相对数量.

#+CAPTION: 各算法的三向交叉口相对数量

如你所见, 递归回溯 (Recursive Backtracker) 和 Hunt-and-Kill 提供的选择远少于其他算法! 即使在考虑四向交叉口时, 这种趋势仍在继续:

#+CAPTION: 各算法的四向交叉口相对数量

再次, 递归回溯 (Recursive Backtracker) 和 Hunt-and-Kill 趋于末尾, 尽管二叉树 (Binary Tree) 以恰好百分之零的通道为四向交叉口而位于尾尖. 很难比那更低了!

** 轮到你了
Your Turn

正如所指出的, 本附录中呈现的统计数据非常肤浅. 还有很多可以做的事情. 如果你对统计学感兴趣, 你可能想分析这些算法的其他方面. 也许下面的一些会激发你的灵感!

- 对偏离最长路径的路径长度进行分析. 这可以让你更好地了解某人可能会偏离多远 (尽管这将是一个计算成本高昂的数字!).
- 死胡同与路径长度的比率. 许多死胡同和更长的平均路径长度表明你可能会在一条支路上迷失得很深!
- 笔直度与曲折度的比率. 比率非常高的算法将有相对较少的转弯. 例如, 《吃豆人》(Pac-Man) 的迷宫会比曲折的更直接.

你还想尝试哪些测量方法? 看看你还能想出什么
